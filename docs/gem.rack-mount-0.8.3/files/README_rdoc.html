<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>README.rdoc</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../css/reset.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" />
    <script src="../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
    <script src="../js/main.js" type="text/javascript" charset="utf-8"></script>
</head>

<body>     
    <div class="banner">
        <h1>
            README.rdoc
        </h1>
        <ul class="files">
            <li>README.rdoc</li>
            <li>Last modified: Sat Oct 01 23:00:14 +0200 2011</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
    
    <div class="description">
        <h1><a href="../classes/Rack/Mount.html">Rack::Mount</a></h1>
<p>
A stackable dynamic tree based Rack router.
</p>
<p>
<a href="../classes/Rack/Mount.html">Rack::Mount</a> supports Rack&#8217;s
<tt>X-Cascade</tt> convention to continue trying routes if the response
returns <tt>pass</tt>. This allows multiple routes to be nested or stacked
on top of each other. Since the application endpoint can trigger the router
to continue matching, middleware can be used to add arbitrary conditions to
any route. This allows you to route based on other request attributes,
session information, or even data dynamically pulled from a database.
</p>
<h3>Usage</h3>
<p>
<a href="../classes/Rack/Mount.html">Rack::Mount</a> provides a plugin API
to build custom DSLs on top of.
</p>
<p>
The API is extremely minimal and only 3 methods are exposed as the public
API.
</p>
<table>
<tr><td valign="top"><tt><a href="../classes/Rack/Mount/RouteSet.html#M000041">Rack::Mount::RouteSet#add_route</a></tt>:</td><td>builder method for adding routes to the set

</td></tr>
<tr><td valign="top"><tt><a href="../classes/Rack/Mount/RouteSet.html#M000043">Rack::Mount::RouteSet#call</a></tt>:</td><td>Rack compatible recognition and dispatching method

</td></tr>
<tr><td valign="top"><tt>Rack::Mount::RouteSet#generate</tt>:</td><td>generates a route condition from identifiers or significant keys

</td></tr>
</table>
<h3>Example</h3>
<pre>
  require 'rack/mount'

  Routes = Rack::Mount::RouteSet.new do |set|
    # add_route takes a rack application and conditions to match with
    #
    # valid conditions methods are any method on Rack::Request
    # the values to match against may be strings or regexps
    #
    # See Rack::Mount::RouteSet#add_route for more options.
    set.add_route FooApp, { :request_method =&gt; 'GET', :path_info =&gt; %r{^/foo$} }, {}, :foo
  end

  # The route set itself is a simple rack app you mount
  run Routes

  # generate path for route named &quot;foo&quot;
  Routes.generate(:path_info, :foo) #=&gt; &quot;/foo&quot;
</pre>

    </div>
    

    

    
    

    
    

    

    

    

    

    

    
</div>
    </div>
  </body>
</html>