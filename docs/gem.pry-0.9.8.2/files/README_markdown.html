<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>README.markdown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../css/reset.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" />
    <script src="../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
    <script src="../js/main.js" type="text/javascript" charset="utf-8"></script>
</head>

<body>     
    <div class="banner">
        <h1>
            README.markdown
        </h1>
        <ul class="files">
            <li>README.markdown</li>
            <li>Last modified: Mon Feb 13 07:34:52 +0100 2012</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
    
    <div class="description">
        <p>
[![Build Status](<a
href="https://secure.travis-ci.org/pry/pry.png)](http://travis-ci.org/pry/pry">secure.travis-ci.org/pry/pry.png)](http://travis-ci.org/pry/pry</a>)
<center> ![Alt text](<img
src="http://dl.dropbox.com/u/26521875/pry_logo_350.png" />)
</p>
<p>
(C) John Mair (banisterfiend) 2011<br>
</p>
<p>
*<b>Please</b>* [DONATE](<a
href="http://www.pledgie.com/campaigns/15899">www.pledgie.com/campaigns/15899</a>)
to the <a href="../classes/Pry.html">Pry</a> project - <a
href="../classes/Pry.html">Pry</a> was a *<b>huge</b>* amount of work and
every donation received is encouraging and supports Pry&#8217;s continued
development!
</p>
<p>
*<b>Sponsors</b>*
</p>
<p>
[Atomic Object](<a
href="http://www.atomicobject.com/)<br">www.atomicobject.com/)<br</a>/>
[Bendyworks](<a href="http://bendyworks.com/)<br">bendyworks.com/)<br</a>/>
[Intridea](<a href="http://intridea.com/)<br">intridea.com/)<br</a>/>
</p>
<p>
**Other Resources**
</p>
<p>
[Skip to the website (recommended)](<a
href="http://pry.github.com">pry.github.com</a>) <br /> [Skip to the
wiki](<a
href="https://github.com/pry/pry/wiki">github.com/pry/pry/wiki</a>)
</center>
</p>
<p>
<a href="../classes/Pry.html">Pry</a> is a powerful alternative to the
standard IRB shell for Ruby. It is written from scratch to provide a number
of advanced features, some of these include:
</p>
<ul>
<li>Source code browsing (including core C source with the pry-doc gem)

</li>
<li>Documentation browsing

</li>
<li>Live help system

</li>
<li>Open methods in editors (`edit-method Class#method`)

</li>
<li>Syntax highlighting

</li>
<li>Command shell integration (start editors, run git, and rake from within <a
href="../classes/Pry.html">Pry</a>)

</li>
<li>Gist integration

</li>
<li>Navigation around state (`cd`, `ls` and friends)

</li>
<li>Runtime invocation (use <a href="../classes/Pry.html">Pry</a> as a
developer console or debugger)

</li>
<li>Exotic object support (BasicObject instances, IClasses, &#8230;)

</li>
<li>A Powerful and flexible command system

</li>
<li>Ability to view and replay history

</li>
<li>Many convenience commands inspired by IPython, Smalltalk and other advanced
REPLs

</li>
</ul>
<p>
<a href="../classes/Pry.html">Pry</a> also aims to be more than an IRB
replacement; it is an attempt to bring REPL driven programming to the Ruby
language. It is currently not as powerful as tools like [SLIME](<a
href="http://en.wikipedia.org/wiki/SLIME">en.wikipedia.org/wiki/SLIME</a>)
for lisp, but that is the general direction <a
href="../classes/Pry.html">Pry</a> is heading.
</p>
<p>
<a href="../classes/Pry.html">Pry</a> is also fairly flexible and allows
significant user [customization](<a
href="https://github.com/pry/pry/wiki/Customization-and-configuration">github.com/pry/pry/wiki/Customization-and-configuration</a>)
is trivial to set it to read from any object that has a `readline` method
and write to any object that has a `puts` method - many other aspects of <a
href="../classes/Pry.html">Pry</a> are also configurable making it a good
choice for implementing custom shells.
</p>
<p>
<a href="../classes/Pry.html">Pry</a> comes with an executable so it can be
invoked at the command line. Just enter `pry` to start. A `.pryrc` file in
the user&#8217;s home directory will be loaded if it exists. Type `pry
&#8212;help` at the command line for more information.
</p>
<p>
Try `gem install pry-doc` for additional documentation on Ruby Core
methods. The additional docs are accessed through the `show-doc` and
`show-method` commands.
</p>
<ul>
<li>Install the [gem](<a
href="https://rubygems.org/gems/pry">rubygems.org/gems/pry</a>): `gem
install pry`

</li>
<li>Browse the comprehensive [documentation at the official <a
href="../classes/Pry.html">Pry</a> wiki](<a
href="https://github.com/pry/pry/wiki">github.com/pry/pry/wiki</a>)

</li>
<li>Read the [YARD API documentation](<a
href="http://rdoc.info/github/pry/pry/master/file/README.markdown">rdoc.info/github/pry/pry/master/file/README.markdown</a>)

</li>
<li>See the [source code](<a
href="http://github.com/pry/pry">github.com/pry/pry</a>)

</li>
</ul>
<p>
<a href="../classes/Pry.html">Pry</a> also has `rubygems-test` support; to
participate, first install <a href="../classes/Pry.html">Pry</a>, then:
</p>
<ol>
<li>Install rubygems-test: `gem install rubygems-test`

</li>
<li>Run the test: `gem test pry`

</li>
<li>Finally choose &#8216;Yes&#8217; to upload the results.

</li>
</ol>
<p>
### Commands
</p>
<p>
Nearly every piece of functionality in a <a
href="../classes/Pry.html">Pry</a> session is implemented as a command.
Commands are not methods and must start at the beginning of a line, with no
whitespace in between. Commands support a flexible syntax and allow
&#8216;options&#8217; in the same way as shell commands, for example the
following <a href="../classes/Pry.html">Pry</a> command will show a list of
all private instance methods (in scope) that begin with &#8216;pa&#8217;
</p>
<pre>
    pry(YARD::Parser::SourceParser):5&gt; ls -Mp --grep ^pa
    [:parser_class, :parser_type=, :parser_type_for_filename]
</pre>
<p>
### Navigating around state
</p>
<p>
<a href="../classes/Pry.html">Pry</a> allows us to pop in and out of
different scopes (objects) using the `cd` command. This enables us to
explore the run-time view of a program or library. To view which variables
and methods are available within a particular scope we use the versatile
[ls command.](<a
href="https://gist.github.com/c0fc686ef923c8b87715">gist.github.com/c0fc686ef923c8b87715</a>)
</p>
<p>
Here we will begin <a href="../classes/Pry.html">Pry</a> at top-level, then
<a href="../classes/Pry.html">Pry</a> on a class and then on an instance
variable inside that class:
</p>
<pre>
    pry(main)&gt; class Hello
    pry(main)*   @x = 20
    pry(main)* end
    =&gt; 20
    pry(main)&gt; cd Hello
    pry(Hello):1&gt; ls -i
    =&gt; [:@x]
    pry(Hello):1&gt; cd @x
    pry(20:2)&gt; self + 10
    =&gt; 30
    pry(20:2)&gt; cd ..
    pry(Hello):1&gt; cd ..
    pry(main)&gt; cd ..
</pre>
<p>
The number after the `:` in the pry prompt indicates the nesting level. To
display more information about nesting, use the `nesting` command. E.g
</p>
<pre>
    pry(&quot;friend&quot;:3)&gt; nesting
    Nesting status:
    0. main (Pry top level)
    1. Hello
    2. 100
    3. &quot;friend&quot;
    =&gt; nil
</pre>
<p>
We can then jump back to any of the previous nesting levels by using the
`jump-to` command:
</p>
<pre>
    pry(&quot;friend&quot;:3)&gt; jump-to 1
    Ending Pry session for &quot;friend&quot;
    Ending Pry session for 100
    =&gt; 100
    pry(Hello):1&gt;
</pre>
<p>
### Runtime invocation
</p>
<p>
<a href="../classes/Pry.html">Pry</a> can be invoked in the middle of a
running program. It opens a <a href="../classes/Pry.html">Pry</a> session
at the point it&#8217;s called and makes all program state at that point
available. It can be invoked on any object using the `my_object.pry` syntax
or on the current binding (or any binding) using `binding.pry`. The <a
href="../classes/Pry.html">Pry</a> session will then begin within the scope
of the object (or binding). When the session ends the program continues
with any modifications you made to it.
</p>
<p>
This functionality can be used for such things as: debugging, implementing
developer consoles and applying hot patches.
</p>
<p>
code:
</p>
<pre>
    # test.rb
    require 'pry'

    class A
      def hello() puts &quot;hello world!&quot; end
    end

    a = A.new

    # start a REPL session
    binding.pry

    # program resumes here (after pry session)
    puts &quot;program resumes here.&quot;
</pre>
<p>
<a href="../classes/Pry.html">Pry</a> session:
</p>
<pre>
    pry(main)&gt; a.hello
    hello world!
    =&gt; nil
    pry(main)&gt; def a.goodbye
    pry(main)*   puts &quot;goodbye cruel world!&quot;
    pry(main)* end
    =&gt; nil
    pry(main)&gt; a.goodbye
    goodbye cruel world!
    =&gt; nil
    pry(main)&gt; exit

    program resumes here.
</pre>
<p>
### Command Shell Integration
</p>
<p>
A line of input that begins with a &#8217;.&#8217; will be forwarded to the
command shell. This enables us to navigate the file system, spawn editors,
and run git and rake directly from within <a
href="../classes/Pry.html">Pry</a>.
</p>
<p>
Further, we can use the `shell-mode` command to incorporate the present
working directory into the <a href="../classes/Pry.html">Pry</a> prompt and
bring in (limited at this stage, sorry) file name completion. We can also
interpolate Ruby code directly into the shell by using the normal `#{}`
string interpolation syntax.
</p>
<p>
In the code below we&#8217;re going to switch to `shell-mode` and edit the
`.pryrc` file in the home directory. We&#8217;ll then cat its contents and
reload the file.
</p>
<pre>
    pry(main)&gt; shell-mode
    pry main:/home/john/ruby/projects/pry $ .cd ~
    pry main:/home/john $ .emacsclient .pryrc
    pry main:/home/john $ .cat .pryrc
    def hello_world
      puts &quot;hello world!&quot;
    end
    pry main:/home/john $ load &quot;.pryrc&quot;
    =&gt; true
    pry main:/home/john $ hello_world
    hello world!
</pre>
<p>
We can also interpolate Ruby code into the shell. In the example below we
use the shell command `cat` on a random file from the current directory and
count the number of lines in that file with `wc`:
</p>
<pre>
    pry main:/home/john $ .cat #{Dir['*.*'].sample} | wc -l
    44
</pre>
<p>
### Code Browsing
</p>
<p>
You can browse method source code with the `show-method` command. Nearly
all Ruby methods (and some C methods, with the pry-doc gem) can have their
source viewed. Code that is longer than a page is sent through a pager
(such as less), and all code is properly syntax highlighted (even C code).
</p>
<p>
The `show-method` command accepts two syntaxes, the typical ri
`Class#method` syntax and also simply the name of a method that&#8217;s in
scope. You can optionally pass the `-l` option to show-method to include
line numbers in the output.
</p>
<p>
In the following example we will enter the `Pry` class, list the instance
methods beginning with &#8216;re&#8217; and display the source code for the
`rep` method:
</p>
<pre>
    pry(main)&gt; cd Pry
    pry(Pry):1&gt; ls -M --grep ^re
    [:re, :readline, :rep, :repl, :repl_epilogue, :repl_prologue, :retrieve_line]
    pry(Pry):1&gt; show-method rep -l

    From: /home/john/ruby/projects/pry/lib/pry/pry_instance.rb @ line 143:
    Number of lines: 6

    143: def rep(target=TOPLEVEL_BINDING)
    144:   target = Pry.binding_for(target)
    145:   result = re(target)
    146:
    147:   show_result(result) if should_print?
    148: end
</pre>
<p>
Note that we can also view C methods (from Ruby Core) using the `pry-doc`
plugin; we also show off the alternate syntax for `show-method`:
</p>
<pre>
    pry(main)&gt; show-method Array#select

    From: array.c in Ruby Core (C Method):
    Number of lines: 15

    static VALUE
    rb_ary_select(VALUE ary)
    {
        VALUE result;
        long i;

        RETURN_ENUMERATOR(ary, 0, 0);
        result = rb_ary_new2(RARRAY_LEN(ary));
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (RTEST(rb_yield(RARRAY_PTR(ary)[i]))) {
            rb_ary_push(result, rb_ary_elt(ary, i));
        }
        }
        return result;
    }
</pre>
<p>
### Documentation Browsing
</p>
<p>
One use-case for <a href="../classes/Pry.html">Pry</a> is to explore a
program at run-time by `cd`-ing in and out of objects and viewing and
invoking methods. In the course of exploring it may be useful to read the
documentation for a specific method that you come across. Like
`show-method` the `show-doc` command supports two syntaxes - the normal
`ri` syntax as well as accepting the name of any method that is currently
in scope.
</p>
<p>
The <a href="../classes/Pry.html">Pry</a> documentation system does not
rely on pre-generated `rdoc` or `ri`, instead it grabs the comments
directly above the method on demand. This results in speedier documentation
retrieval and allows the <a href="../classes/Pry.html">Pry</a> system to
retrieve documentation for methods that would not be picked up by `rdoc`.
<a href="../classes/Pry.html">Pry</a> also has a basic understanding of
both the rdoc and yard formats and will attempt to syntax highlight the
documentation appropriately.
</p>
<p>
Nonetheless The `ri` functionality is very good and has an advantage over
Pry&#8217;s system in that it allows documentation lookup for classes as
well as methods. <a href="../classes/Pry.html">Pry</a> therefore has good
integration with `ri` through the `ri` command. The syntax for the command
is exactly as it would be in command-line - so it is not necessary to quote
strings.
</p>
<p>
In our example we will enter the `Gem` class and view the documentation for
the `try_activate` method:
</p>
<pre>
    pry(main)&gt; cd Gem
    pry(Gem):1&gt; show-doc try_activate

    From: /Users/john/.rvm/rubies/ruby-1.9.2-p180/lib/ruby/site_ruby/1.9.1/rubygems.rb @ line 201:
    Number of lines: 3

    Try to activate a gem containing path. Returns true if
    activation succeeded or wasn't needed because it was already
    activated. Returns false if it can't find the path in a gem.
    pry(Gem):1&gt;
</pre>
<p>
We can also use `ri` in the normal way:
</p>
<pre>
    pry(main) ri Array#each
    ----------------------------------------------------------- Array#each
         array.each {|item| block }   -&gt;   array
    ------------------------------------------------------------------------
         Calls _block_ once for each element in _self_, passing that element
         as a parameter.

            a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
            a.each {|x| print x, &quot; -- &quot; }

         produces:

            a -- b -- c --
</pre>
<p>
### Gist integration
</p>
<p>
If the `gist` gem is installed then method source or documentation can be
gisted to github with the `gist-method` command. The `gist-method` command
accepts the same two syntaxes as `show-method`. In the example below we
will gist the C source code for the `Symbol#to_proc` method to github:
</p>
<pre>
    pry(main)&gt; gist-method Symbol#to_proc
    https://gist.github.com/5332c38afc46d902ce46
    pry(main)&gt;
</pre>
<p>
You can see the actual gist generated here: [<a
href="https://gist.github.com/5332c38afc46d902ce46](https://gist.github.com/5332c38afc46d902ce46">gist.github.com/5332c38afc46d902ce46](https://gist.github.com/5332c38afc46d902ce46</a>)
</p>
<p>
### Edit methods
</p>
<p>
You can use `edit-method Class#method` or `edit-method my_method` (if the
method is in scope) to open a method for editing directly in your favorite
editor. <a href="../classes/Pry.html">Pry</a> has knowledge of a few
different editors and will attempt to open the file at the line the method
is defined.
</p>
<p>
You can set the editor to use by assigning to the `Pry.editor` accessor.
`Pry.editor` will default to `$EDITOR` or failing that will use `nano` as
the backup default. The file that is edited will be automatically reloaded
after exiting the editor - reloading can be suppressed by passing the
`&#8212;no-reload` option to `edit-method`
</p>
<p>
In the example below we will set our default editor to
&#8220;emacsclient&#8221; and open the `<a
href="../classes/Pry.html#M000358">Pry#repl</a>` method for editing:
</p>
<pre>
    pry(main)&gt; Pry.editor = &quot;emacsclient&quot;
    pry(main)&gt; edit-method Pry#repl
</pre>
<p>
### Live Help System
</p>
<p>
Many other commands are available in <a href="../classes/Pry.html">Pry</a>;
to see the full list type `help` at the prompt. A short description of each
command is provided with basic instructions for use; some commands have a
more extensive help that can be accessed via typing `command_name
&#8212;help`. A command will typically say in its description if the
`&#8212;help` option is avaiable.
</p>
<p>
### Use <a href="../classes/Pry.html">Pry</a> as your Rails Console
</p>
<pre>
    pry -r ./config/environment
</pre>
<p>
MyArtChannel has kindly provided a hack to replace the `rails console`
command in Rails 3: [<a
href="https://gist.github.com/941174](https://gist.github.com/941174">gist.github.com/941174](https://gist.github.com/941174</a>)
This is not recommended for code bases with multiple developers, as they
may not all want to use <a href="../classes/Pry.html">Pry</a>.
</p>
<p>
### Limitations:
</p>
<ul>
<li>Tab completion is currently a bit broken/limited this will have a major
overhaul in a future version.

</li>
</ul>
<p>
### Syntax Highlighting
</p>
<p>
Syntax highlighting is on by default in <a
href="../classes/Pry.html">Pry</a>. You can toggle it on and off in a
session by using the `toggle-color` command. Alternatively, you can turn it
off permanently by putting the line `Pry.color = false` in your `~/.pryrc`
file.
</p>
<p>
### Future Directions
</p>
<p>
Many new features are planned such as:
</p>
<ul>
<li>Increase modularity (rely more on plugin system)

</li>
<li>Much improved tab completion (using [Bond](<a
href="http://github.com/cldwalker/bond">github.com/cldwalker/bond</a>))

</li>
<li>Much improved documentation system, better support for YARD

</li>
<li>Better support for code and method reloading and saving code

</li>
<li>Extended and more sophisticated command system, allowing piping

</li>
</ul>
<p>
between commands and running commands in background
</p>
<p>
### Contact
</p>
<p>
Problems or questions contact me at [github](<a
href="http://github.com/banister">github.com/banister</a>)
</p>
<p>
### Contributors
</p>
<p>
<a href="../classes/Pry.html">Pry</a> is primarily the work of [John Mair
(banisterfiend)]((<a
href="http://github.com/banister">github.com/banister</a>)), for full list
of contributors see the [CONTRIBUTORS](<a
href="https://github.com/pry/pry/blob/master/CONTRIBUTORS">github.com/pry/pry/blob/master/CONTRIBUTORS</a>)
file.
</p>

    </div>
    

    

    
    

    
    

    

    

    

    

    

    
</div>
    </div>
  </body>
</html>