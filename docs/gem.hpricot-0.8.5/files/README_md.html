<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>README.md</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../css/reset.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" />
    <script src="../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
    <script src="../js/main.js" type="text/javascript" charset="utf-8"></script>
</head>

<body>     
    <div class="banner">
        <h1>
            README.md
        </h1>
        <ul class="files">
            <li>README.md</li>
            <li>Last modified: Tue Jan 03 01:57:20 +0100 2012</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
    
    <div class="description">
        <p>
# <a href="../classes/Hpricot.html">Hpricot</a>, Read Any HTML
</p>
<p>
<a href="../classes/Hpricot.html">Hpricot</a> is a fast, flexible HTML
parser written in C. It&#8217;s designed to be very accommodating (like
Tanaka Akira&#8217;s HTree) and to have a very helpful library (like some
JavaScript libs &#8212; JQuery, Prototype &#8212; give you.) The XPath and
CSS parser, in fact, is based on John Resig&#8217;s JQuery.
</p>
<p>
Also, <a href="../classes/Hpricot.html">Hpricot</a> can be handy for
reading broken XML files, since many of the same techniques can be used. If
a quote is missing, <a href="../classes/Hpricot.html">Hpricot</a> tries to
figure it out. If tags overlap, <a
href="../classes/Hpricot.html">Hpricot</a> works on sorting them out. You
know, that sort of thing.
</p>
<p>
*Please read this entire document* before making assumptions about how this
software works.
</p>
<p>
## An Overview
</p>
<p>
Let&#8217;s clear up what <a href="../classes/Hpricot.html">Hpricot</a> is.
</p>
<ul>
<li><a href="../classes/Hpricot.html">Hpricot</a> is *a standalone library*. It
requires no other libraries. Just Ruby!

</li>
<li>While priding itself on speed, <a
href="../classes/Hpricot.html">Hpricot</a> *works hard to sort out bad
HTML* and pays a small penalty in order to get that right. So that&#8217;s
slightly more important to me than speed.

</li>
<li>*If you can see it in Firefox, then <a
href="../classes/Hpricot.html">Hpricot</a> should parse it.* That&#8217;s
how it should be! Let me know the minute it&#8217;s otherwise.

</li>
<li>Primarily, <a href="../classes/Hpricot.html">Hpricot</a> is used for
reading HTML and tries to sort out troubled HTML by having some idea of
what good HTML is. Some people still like to use <a
href="../classes/Hpricot.html">Hpricot</a> for XML reading, but *remember
to use the Hpricot::XML() method* for that!

</li>
</ul>
<p>
## The <a href="../classes/Hpricot.html">Hpricot</a> Kingdom
</p>
<p>
First, here are all the links you need to know:
</p>
<ul>
<li><a
href="http://wiki.github.com/hpricot/hpricot">wiki.github.com/hpricot/hpricot</a>
is the <a href="../classes/Hpricot.html">Hpricot</a> wiki and <a
href="http://github.com/hpricot/hpricot/issues">github.com/hpricot/hpricot/issues</a>
is the bug tracker. Go there for news and recipes and patches. It&#8217;s
the center of activity.

</li>
<li><a href="http://github.com/hpricot/hpricot">github.com/hpricot/hpricot</a>
is the main Git repository for <a
href="../classes/Hpricot.html">Hpricot</a>. You can get the latest code
there.

</li>
<li>See <a href="COPYING.html">COPYING</a> for the terms of this software.
(Spoiler: it&#8217;s absolutely free.)

</li>
</ul>
<p>
If you have any trouble, don&#8217;t hesitate to contact the author. As
always, I&#8217;m not going to say &#8220;Use at your own risk&#8221;
because I don&#8217;t want this library to be risky. If you trip on
something, I&#8217;ll share the liability by repairing things as quickly as
I can. Your responsibility is to report the inadequacies.
</p>
<p>
## Installing <a href="../classes/Hpricot.html">Hpricot</a>
</p>
<p>
You may get the latest stable version from Rubyforge. Win32 binaries, Java
binaries (for JRuby), and source gems are available.
</p>
<pre>
    $ gem install hpricot
</pre>
<p>
## An <a href="../classes/Hpricot.html">Hpricot</a> Showcase
</p>
<p>
We&#8217;re going to run through a big pile of examples to get you
jump-started. Many of these examples are also found at <a
href="http://wiki.github.com/hpricot/hpricot/hpricot-basics">wiki.github.com/hpricot/hpricot/hpricot-basics</a>,
in case you want to add some of your own.
</p>
<p>
### Loading <a href="../classes/Hpricot.html">Hpricot</a> Itself
</p>
<p>
You have probably got the gem, right? To load Hpricot:
</p>
<pre>
    require 'rubygems'
    require 'hpricot'
</pre>
<p>
If you&#8217;ve installed the plain source distribution, go ahead and just:
</p>
<pre>
    require 'hpricot'
</pre>
<p>
### Load an HTML Page
</p>
<p>
The <tt>Hpricot()</tt> method takes a string or any IO object and loads the
contents into a document object.
</p>
<pre>
    doc = Hpricot(&quot;&lt;p&gt;A simple &lt;b&gt;test&lt;/b&gt; string.&lt;/p&gt;&quot;)
</pre>
<p>
To load from a file, just get the stream open:
</p>
<pre>
    doc = open(&quot;index.html&quot;) { |f| Hpricot(f) }
</pre>
<p>
To load from a web URL, use <tt>open-uri</tt>, which comes with Ruby:
</p>
<pre>
    require 'open-uri'
    doc = open(&quot;http://qwantz.com/&quot;) { |f| Hpricot(f) }
</pre>
<p>
<a href="../classes/Hpricot.html">Hpricot</a> uses an internal buffer to
parse the file, so the IO will stream properly and large documents
won&#8217;t be loaded into memory all at once. However, the parsed document
object will be present in memory, in its entirety.
</p>
<p>
### Search for Elements
</p>
<p>
Use <tt>Doc.search</tt>:
</p>
<pre>
    doc.search(&quot;//p[@class='posted']&quot;)
    #=&gt; #&lt;Hpricot:Elements[{p ...}, {p ...}]&gt;
</pre>
<p>
<tt>Doc.search</tt> can take an XPath or CSS expression. In the above
example, all paragraph <tt>&lt;p&gt;</tt> elements are grabbed which have a
<tt>class</tt> attribute of <tt>&quot;posted&quot;</tt>.
</p>
<p>
A shortcut is to use the divisor:
</p>
<pre>
    (doc/&quot;p.posted&quot;)
    #=&gt; #&lt;Hpricot:Elements[{p ...}, {p ...}]&gt;
</pre>
<p>
### Finding Just One Element
</p>
<p>
If you&#8217;re looking for a single element, the <tt>at</tt> method will
return the first element matched by the expression. In this case,
you&#8217;ll get back the element itself rather than the
<tt>Hpricot::Elements</tt> array.
</p>
<pre>
    doc.at(&quot;body&quot;)['onload']
</pre>
<p>
The above code will find the body tag and give you back the <tt>onload</tt>
attribute. This is the most common reason to use the element directly: when
reading and writing HTML attributes.
</p>
<p>
### Fetching the Contents of an Element
</p>
<p>
Just as with browser scripting, the <tt>inner_html</tt> property can be
used to get the inner contents of an element.
</p>
<pre>
    (doc/&quot;#elementID&quot;).inner_html
    #=&gt; &quot;..contents..&quot;
</pre>
<p>
If your expression matches more than one element, you&#8217;ll get back the
contents of &#8217;&#8217;all the matched elements&#8217;&#8217;. So you
may want to use <tt>first</tt> to be sure you get back only one.
</p>
<pre>
    (doc/&quot;#elementID&quot;).first.inner_html
    #=&gt; &quot;..contents..&quot;
</pre>
<p>
### Fetching the HTML for an Element
</p>
<p>
If you want the HTML for the whole element (not just the contents), use
<tt>to_html</tt>:
</p>
<pre>
    (doc/&quot;#elementID&quot;).to_html
    #=&gt; &quot;&lt;div id='elementID'&gt;...&lt;/div&gt;&quot;
</pre>
<p>
### Looping
</p>
<p>
All searches return a set of <tt>Hpricot::Elements</tt>. Go ahead and loop
through them like you would an array.
</p>
<pre>
    (doc/&quot;p/a/img&quot;).each do |img|
      puts img.attributes['class']
    end
</pre>
<p>
### Continuing Searches
</p>
<p>
Searches can be continued from a collection of elements, in order to search
deeper.
</p>
<pre>
    # find all paragraphs.
    elements = doc.search(&quot;/html/body//p&quot;)
    # continue the search by finding any images within those paragraphs.
    (elements/&quot;img&quot;)
    #=&gt; #&lt;Hpricot::Elements[{img ...}, {img ...}]&gt;
</pre>
<p>
Searches can also be continued by searching within container elements.
</p>
<pre>
    # find all images within paragraphs.
    doc.search(&quot;/html/body//p&quot;).each do |para|
      puts &quot;== Found a paragraph ==&quot;
      pp para

      imgs = para.search(&quot;img&quot;)
      if imgs.any?
        puts &quot;== Found #{imgs.length} images inside ==&quot;
      end
    end
</pre>
<p>
Of course, the most succinct ways to do the above are using CSS or XPath.
</p>
<pre>
    # the xpath version
    (doc/&quot;/html/body//p//img&quot;)
    # the css version
    (doc/&quot;html &gt; body &gt; p img&quot;)
    # ..or symbols work, too!
    (doc/:html/:body/:p/:img)
</pre>
<p>
### Looping Edits
</p>
<p>
You may certainly edit objects from within your search loops. Then, when
you spit out the HTML, the altered elements will show.
</p>
<pre>
    (doc/&quot;span.entryPermalink&quot;).each do |span|
      span.attributes['class'] = 'newLinks'
    end
    puts doc
</pre>
<p>
This changes all <tt>span.entryPermalink</tt> elements to
<tt>span.newLinks</tt>. Keep in mind that there are often more convenient
ways of doing this. Such as the <tt>set</tt> method:
</p>
<pre>
    (doc/&quot;span.entryPermalink&quot;).set(:class =&gt; 'newLinks')
</pre>
<p>
### Figuring Out Paths
</p>
<p>
Every element can tell you its unique path (either XPath or CSS) to get to
the element from the root tag.
</p>
<p>
The <tt>css_path</tt> method:
</p>
<pre>
    doc.at(&quot;div &gt; div:nth(1)&quot;).css_path
      #=&gt; &quot;div &gt; div:nth(1)&quot;
    doc.at(&quot;#header&quot;).css_path
      #=&gt; &quot;#header&quot;
</pre>
<p>
Or, the <tt>xpath</tt> method:
</p>
<pre>
    doc.at(&quot;div &gt; div:nth(1)&quot;).xpath
      #=&gt; &quot;/div/div:eq(1)&quot;
    doc.at(&quot;#header&quot;).xpath
      #=&gt; &quot;//div[@id='header']&quot;
</pre>
<p>
## <a href="../classes/Hpricot.html">Hpricot</a> Fixups
</p>
<p>
When loading HTML documents, you have a few settings that can make <a
href="../classes/Hpricot.html">Hpricot</a> more or less intense about how
it gets involved.
</p>
<p>
## :fixup_tags
</p>
<p>
Really, there are so many ways to clean up HTML and your intentions may be
to keep the HTML as-is. So Hpricot&#8217;s default behavior is to keep
things flexible. Making sure to open and close all the tags, but ignore any
validation problems.
</p>
<p>
As of <a href="../classes/Hpricot.html">Hpricot</a> 0.4, there&#8217;s a
new <tt>:fixup_tags</tt> option which will attempt to shift the
document&#8217;s tags to meet XHTML 1.0 Strict.
</p>
<pre>
    doc = open(&quot;index.html&quot;) { |f| Hpricot f, :fixup_tags =&gt; true }
</pre>
<p>
This doesn&#8217;t quite meet the XHTML 1.0 Strict standard, it just tries
to follow the rules a bit better. Like: say <a
href="../classes/Hpricot.html">Hpricot</a> finds a paragraph in a link,
it&#8217;s going to move the paragraph below the link. Or up and out of
other elements where paragraphs don&#8217;t belong.
</p>
<p>
If an unknown element is found, it is ignored. Again, <tt>:fixup_tags</tt>.
</p>
<p>
## :xhtml_strict
</p>
<p>
So, let&#8217;s go beyond just trying to fix the hierarchy. The
<tt>:xhtml_strict</tt> option really tries to force the document to be an
XHTML 1.0 Strict document. Even at the cost of removing elements that get
in the way.
</p>
<pre>
    doc = open(&quot;index.html&quot;) { |f| Hpricot f, :xhtml_strict =&gt; true }
</pre>
<p>
What measures does <tt>:xhtml_strict</tt> take?
</p>
<pre>
 1. Shift elements into their proper containers just like :fixup_tags.
 2. Remove unknown elements.
 3. Remove unknown attributes.
 4. Remove illegal content.
 5. Alter the doctype to XHTML 1.0 Strict.
</pre>
<p>
## <a href="../classes/Hpricot.html#M000057">Hpricot.XML()</a>
</p>
<p>
The last option is the <tt>:xml</tt> option, which makes some slight
variations on the standard mode. The main difference is that :xml mode
won&#8217;t try to output tags which are friendlier for browsers. For
example, if an opening and closing <tt>br</tt> tag is found, XML mode
won&#8217;t try to turn that into an empty element.
</p>
<p>
XML mode also doesn&#8217;t downcase the tags and attributes for you. So
pay attention to case, friends.
</p>
<p>
The primary way to use Hpricot&#8217;s XML mode is to call the <a
href="../classes/Hpricot.html#M000057">Hpricot.XML</a> method:
</p>
<pre>
    doc = open(&quot;http://redhanded.hobix.com/index.xml&quot;) do |f|
      Hpricot.XML(f)
    end
</pre>
<p>
*Also, :fixup_tags is canceled out by the :xml option.* This is because
:fixup_tags makes assumptions based how HTML is structured. Specifically,
how tags are defined in the XHTML 1.0 DTD.
</p>

    </div>
    

    

    
    

    
    

    

    

    

    

    

    
</div>
    </div>
  </body>
</html>