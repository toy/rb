var search_data = {"index":{"info":[["BufferedTokenizer","lib/em/buftok.rb","classes/BufferedTokenizer.html"," < Object","BufferedTokenizer takes a delimiter upon instantiation, or acts line-based by default.  It allows input",1],["EventMachine","lib/em/callback.rb","classes/EventMachine.html"," < ","= EM::Completion A completion is a callback container for various states of completion. In it's most",1],["Channel","EventMachine","classes/EventMachine/Channel.html"," < Object","Provides a simple thread-safe way to transfer data between (typically) long running tasks in {EventMachine.defer}",1],["Completion","EventMachine","classes/EventMachine/Completion.html"," < Object","",1],["Connection","EventMachine","classes/EventMachine/Connection.html"," < Object","@private ",1],["ConnectionError","EventMachine","classes/EventMachine/ConnectionError.html"," < RuntimeError","Exceptions that are defined in rubymain.cpp ",1],["ConnectionNotBound","EventMachine","classes/EventMachine/ConnectionNotBound.html"," < RuntimeError","",1],["DNS","EventMachine","classes/EventMachine/DNS.html"," < ","",1],["Request","EventMachine::DNS","classes/EventMachine/DNS/Request.html"," < Object","",1],["RequestIdAlreadyUsed","EventMachine::DNS","classes/EventMachine/DNS/RequestIdAlreadyUsed.html"," < RuntimeError","",1],["Resolver","EventMachine::DNS","classes/EventMachine/DNS/Resolver.html"," < Object","",1],["Socket","EventMachine::DNS","classes/EventMachine/DNS/Socket.html"," < EventMachine::Connection","",1],["DatagramObject","EventMachine","classes/EventMachine/DatagramObject.html"," < Selectable","@private ",1],["DefaultDeferrable","EventMachine","classes/EventMachine/DefaultDeferrable.html"," < Object","DefaultDeferrable is an otherwise empty class that includes Deferrable. This is very useful when you",1],["Deferrable","EventMachine","classes/EventMachine/Deferrable.html"," < ","",1],["DeferrableChildProcess","EventMachine","classes/EventMachine/DeferrableChildProcess.html"," < EventMachine::Connection","EM::DeferrableChildProcess is a sugaring of a common use-case involving EM::popen. Call the #open method",1],["Error","EventMachine","classes/EventMachine/Error.html"," < Exception","@private ",1],["EvmaKeyboard","EventMachine","classes/EventMachine/EvmaKeyboard.html"," < StreamObject","@private ",1],["EvmaTCPClient","EventMachine","classes/EventMachine/EvmaTCPClient.html"," < StreamObject","@private ",1],["EvmaTCPServer","EventMachine","classes/EventMachine/EvmaTCPServer.html"," < Selectable","@private ",1],["EvmaUDPSocket","EventMachine","classes/EventMachine/EvmaUDPSocket.html"," < DatagramObject","@private ",1],["EvmaUNIXClient","EventMachine","classes/EventMachine/EvmaUNIXClient.html"," < StreamObject","@private ",1],["EvmaUNIXServer","EventMachine","classes/EventMachine/EvmaUNIXServer.html"," < Selectable","@private ",1],["FileNotFoundException","EventMachine","classes/EventMachine/FileNotFoundException.html"," < Exception","",1],["FileStreamer","EventMachine","classes/EventMachine/FileStreamer.html"," < Object","Streams a file over a given connection. Streaming begins once the object is instantiated. Typically FileStreamer",1],["FileWatch","EventMachine","classes/EventMachine/FileWatch.html"," < Connection","Utility class that is useful for file monitoring. Supported events are * File is modified * File is deleted",1],["Iterator","EventMachine","classes/EventMachine/Iterator.html"," < Object","A simple iterator for concurrent asynchronous work. Unlike ruby's built-in iterators, the end of the",1],["JEM","EventMachine","classes/EventMachine/JEM.html"," < com.rubyeventmachine.EmReactor","This thunk class used to be called EM, but that caused conflicts with the alias \"EM\" for module EventMachine.",1],["LoopbreakReader","EventMachine","classes/EventMachine/LoopbreakReader.html"," < Selectable","@private ",1],["PeriodicTimer","EventMachine","classes/EventMachine/PeriodicTimer.html"," < Object","Creates a periodic timer @example n = 0 timer = EventMachine::PeriodicTimer.new(5) do puts \"the time",1],["Pool","EventMachine","classes/EventMachine/Pool.html"," < Object","= EventMachine::Pool A simple async resource pool based on a resource and work queue. Resources are enqueued",1],["ProcessWatch","EventMachine","classes/EventMachine/ProcessWatch.html"," < Connection","This is subclassed from EventMachine::Connection for use with the process monitoring API. Read the documentation",1],["Protocols","EventMachine","classes/EventMachine/Protocols.html"," < ","This module contains various protocol implementations, including: - HttpClient and HttpClient2 - Stomp",1],["HeaderAndContentProtocol","EventMachine::Protocols","classes/EventMachine/Protocols/HeaderAndContentProtocol.html"," < Connection","=== Usage class RequestHandler < EM::P::HeaderAndContentProtocol def receive_request headers, content",1],["HttpClient","EventMachine::Protocols","classes/EventMachine/Protocols/HttpClient.html"," < Connection","<b>Note:</b> This class is deprecated and will be removed. Please use EM-HTTP-Request instead. @example",1],["HttpClient2","EventMachine::Protocols","classes/EventMachine/Protocols/HttpClient2.html"," < Connection","<b>Note:</b> This class is deprecated and will be removed. Please use EM-HTTP-Request instead. === Usage",1],["Request","EventMachine::Protocols::HttpClient2","classes/EventMachine/Protocols/HttpClient2/Request.html"," < Object","@private ",1],["LineAndTextProtocol","EventMachine::Protocols","classes/EventMachine/Protocols/LineAndTextProtocol.html"," < Connection","A protocol that handles line-oriented data with interspersed binary text. This version is optimized for",1],["LineProtocol","EventMachine::Protocols","classes/EventMachine/Protocols/LineProtocol.html"," < ","LineProtocol will parse out newline terminated strings from a receive_data stream module Server include",1],["LineText2","EventMachine::Protocols","classes/EventMachine/Protocols/LineText2.html"," < ","In the grand, time-honored tradition of re-inventing the wheel, we offer here YET ANOTHER protocol that",1],["Memcache","EventMachine::Protocols","classes/EventMachine/Protocols/Memcache.html"," < ","Implements the Memcache protocol (http://code.sixapart.com/svn/memcached/trunk/server/doc/protocol.txt).",1],["ParserError","EventMachine::Protocols::Memcache","classes/EventMachine/Protocols/Memcache/ParserError.html"," < StandardError","@private ",1],["ObjectProtocol","EventMachine::Protocols","classes/EventMachine/Protocols/ObjectProtocol.html"," < ","ObjectProtocol allows for easy communication using marshaled ruby objects module RubyServer include EM::P::ObjectProtocol",1],["Postgres3","EventMachine::Protocols","classes/EventMachine/Protocols/Postgres3.html"," < EventMachine::Connection","PROVISIONAL IMPLEMENTATION of an evented Postgres client. This implements version 3 of the Postgres wire",1],["SASLauth","EventMachine::Protocols","classes/EventMachine/Protocols/SASLauth.html"," < ","Implements SASL authd. This is a very, very simple protocol that mimics the one used by saslauthd and",1],["SASLauthclient","EventMachine::Protocols","classes/EventMachine/Protocols/SASLauthclient.html"," < ","Implements the SASL authd client protocol. This is a very, very simple protocol that mimics the one used",1],["SmtpClient","EventMachine::Protocols","classes/EventMachine/Protocols/SmtpClient.html"," < Connection","Simple SMTP client @example email = EM::Protocols::SmtpClient.send( :domain=>\"example.com\", :host=>'localhost',",1],["SmtpServer","EventMachine::Protocols","classes/EventMachine/Protocols/SmtpServer.html"," < EventMachine::Connection","This is a protocol handler for the server side of SMTP. It's NOT a complete SMTP server obeying all the",1],["Socks4","EventMachine::Protocols","classes/EventMachine/Protocols/Socks4.html"," < Connection","Basic SOCKS v4 client implementation Use as you would any regular connection: class MyConn < EM::P::Socks4",1],["Stomp","EventMachine::Protocols","classes/EventMachine/Protocols/Stomp.html"," < ","Implements Stomp (http://docs.codehaus.org/display/STOMP/Protocol). == Usage example module StompClient",1],["Message","EventMachine::Protocols::Stomp","classes/EventMachine/Protocols/Stomp/Message.html"," < Object","",1],["TcpConnectTester","EventMachine::Protocols","classes/EventMachine/Protocols/TcpConnectTester.html"," < Connection","@private ",1],["Queue","EventMachine","classes/EventMachine/Queue.html"," < Object","A cross thread, reactor scheduled, linear queue. This class provides a simple queue abstraction on top",1],["Reactor","EventMachine","classes/EventMachine/Reactor.html"," < Object","@private ",1],["Selectable","EventMachine","classes/EventMachine/Selectable.html"," < Object","@private ",1],["SpawnedProcess","EventMachine","classes/EventMachine/SpawnedProcess.html"," < Object","Support for Erlang-style processes. ",1],["StreamObject","EventMachine","classes/EventMachine/StreamObject.html"," < Selectable","@private ",1],["SystemCmd","EventMachine","classes/EventMachine/SystemCmd.html"," < EventMachine::Connection","@private ",1],["ThreadedResource","EventMachine","classes/EventMachine/ThreadedResource.html"," < Object","= EventMachine::ThreadedResource A threaded resource is a \"quick and dirty\" wrapper around the concept",1],["TickLoop","EventMachine","classes/EventMachine/TickLoop.html"," < Object","A TickLoop is useful when one needs to distribute amounts of work throughout ticks in order to maintain",1],["Timer","EventMachine","classes/EventMachine/Timer.html"," < Object","Creates a one-time timer timer = EventMachine::Timer.new(5) do # this will never fire because we cancel",1],["UnknownTimerFired","EventMachine","classes/EventMachine/UnknownTimerFired.html"," < RuntimeError","",1],["Unsupported","EventMachine","classes/EventMachine/Unsupported.html"," < RuntimeError","",1],["UuidGenerator","EventMachine","classes/EventMachine/UuidGenerator.html"," < ","Factored out so we can substitute other implementations here if desired, such as the one in ActiveRBAC.",1],["YieldBlockFromSpawnedProcess","EventMachine","classes/EventMachine/YieldBlockFromSpawnedProcess.html"," < Object","@private ",1],["IO","lib/em/pure_ruby.rb","classes/IO.html"," < Object","@private ",1],["JavaFields","lib/jeventmachine.rb","classes/JavaFields.html"," < ","",1],["StringIO","lib/em/protocols/postgres3.rb","classes/StringIO.html"," < Object","@private ",1],["TestConnection","lib/em/protocols/memcache.rb","classes/TestConnection.html"," < Object","@private ",1],["<<","EventMachine::Channel","classes/EventMachine/Channel.html#M000009","(*items)","Alias for #push",2],["<<","EventMachine::Queue","classes/EventMachine/Queue.html#M000297","(*items)","Alias for #push",2],["Callback","EventMachine","classes/EventMachine.html#M000006","(object = nil, method = nil, &blk)","Utility method for coercing arguments to an object that responds to :call. Accepts an object and a method",2],["_open_file_for_writing","EventMachine","classes/EventMachine.html#M000540","(filename, handler=nil)","@private ",2],["ack","EventMachine::Protocols::Stomp","classes/EventMachine/Protocols/Stomp.html#M000293","(msgid)","ACK command, for acknowledging receipt of messages module StompClient include EM::P::Stomp def connection_completed",2],["add","EventMachine::Pool","classes/EventMachine/Pool.html#M000098","(resource)","",2],["add_oneshot_timer","EventMachine","classes/EventMachine.html#M000455","(interval)","",2],["add_oneshot_timer","EventMachine","classes/EventMachine.html#M000301","(interval)","Changed 04Oct06: intervals from the caller are now in milliseconds, but our native-ruby processor still",2],["add_periodic_timer","EventMachine","classes/EventMachine.html#M000505","(*args, &block)","Adds a periodic timer to the event loop. It takes the same parameters as the one-shot timer method, {EventMachine.add_timer}.",2],["add_selectable","EventMachine::Reactor","classes/EventMachine/Reactor.html#M000354","(io)","",2],["add_shutdown_hook","EventMachine","classes/EventMachine.html#M000503","(&block)","Adds a block to call as the reactor is shutting down. These callbacks are called in the _reverse_ order",2],["add_timer","EventMachine","classes/EventMachine.html#M000504","(*args, &block)","Adds a one-shot timer to the event loop. Call it with one or two parameters. The first parameters is",2],["associate_callback_target","EventMachine::Connection","classes/EventMachine/Connection.html#M000497","(sig)","",2],["attach","EventMachine","classes/EventMachine.html#M000514","(io, handler=nil, *args, &blk)","Attaches an IO object or file descriptor to the eventloop as a regular connection. The file descriptor",2],["attach_fd","EventMachine","classes/EventMachine.html#M000487","(fileno, watch_mode)","@private ",2],["attach_io","EventMachine","classes/EventMachine.html#M000515","(io, watch_mode, handler=nil, *args)","@private ",2],["bind_connect","EventMachine","classes/EventMachine.html#M000512","(bind_addr, bind_port, server, port=nil, handler=nil, *args)","This method is like {EventMachine.connect}, but allows for a local address/port to bind the connection",2],["bind_connect_server","EventMachine","classes/EventMachine.html#M000308","(bind_addr, bind_port, host, port)","@private ",2],["bind_connect_server","EventMachine","classes/EventMachine.html#M000464","(bind_addr, bind_port, server, port)","",2],["callback","EventMachine::Completion","classes/EventMachine/Completion.html#M000018","(*a, &b)","Callbacks are called when you enter (or are in) a :succeeded state. ",2],["callback","EventMachine::Deferrable","classes/EventMachine/Deferrable.html#M000052","(&block)","Specify a block to be executed if and when the Deferrable object receives a status of :succeeded. See",2],["cancel","EventMachine::PeriodicTimer","classes/EventMachine/PeriodicTimer.html#M000447","()","Cancel the periodic timer ",2],["cancel","EventMachine::Timer","classes/EventMachine/Timer.html#M000445","()","Cancel the timer ",2],["cancel_callback","EventMachine::Completion","classes/EventMachine/Completion.html#M000031","(*a, &b)","Remove a callback. N.B. Some callbacks cannot be deleted. Usage is NOT recommended, this is an anti-pattern.",2],["cancel_callback","EventMachine::Deferrable","classes/EventMachine/Deferrable.html#M000053","(block)","Cancels an outstanding callback to &block if any. Undoes the action of #callback. ",2],["cancel_errback","EventMachine::Completion","classes/EventMachine/Completion.html#M000029","(*a, &b)","Remove an errback. N.B. Some errbacks cannot be deleted. Usage is NOT recommended, this is an anti-pattern.",2],["cancel_errback","EventMachine::Deferrable","classes/EventMachine/Deferrable.html#M000056","(block)","Cancels an outstanding errback to &block if any. Undoes the action of #errback. ",2],["cancel_timeout","EventMachine::Completion","classes/EventMachine/Completion.html#M000028","()","Disable the timeout ",2],["cancel_timeout","EventMachine::Deferrable","classes/EventMachine/Deferrable.html#M000066","()","Cancels an outstanding timeout if any. Undoes the action of #timeout. ",2],["cancel_timer","EventMachine","classes/EventMachine.html#M000506","(timer_or_sig)","Cancel a timer (can be a callback or an {EventMachine::Timer} instance). @param [#cancel, #call] timer_or_sig",2],["change_state","EventMachine::Completion","classes/EventMachine/Completion.html#M000021","(state, *args)","Enter a new state, setting the result value if given. If the state is one of :succeeded or :failed, then",2],["clear_dead_callbacks","EventMachine::Completion","classes/EventMachine/Completion.html#M000034","()","If we enter a completion state, clear other completion states after all callback chains are completed.",2],["close_connection","EventMachine","classes/EventMachine.html#M000310","(target, after_writing)","The extension version does NOT raise any kind of an error if an attempt is made to close a non-existent",2],["close_connection","EventMachine","classes/EventMachine.html#M000465","(sig, after_writing)","",2],["close_connection","EventMachine::Connection","classes/EventMachine/Connection.html#M000043","(after_writing = false)","EventMachine::Connection#close_connection is called only by user code, and never by the event loop. You",2],["close_connection_after_writing","EventMachine::Connection","classes/EventMachine/Connection.html#M000047","()","A variant of {#close_connection}. All of the descriptive comments given for close_connection also apply",2],["close_loopbreaker","EventMachine::Reactor","classes/EventMachine/Reactor.html#M000365","()","",2],["close_scheduled?","EventMachine::Selectable","classes/EventMachine/Selectable.html#M000377","()","",2],["comm_inactivity_timeout","EventMachine::Connection","classes/EventMachine/Connection.html#M000064","()","comm_inactivity_timeout returns the current value (float in seconds) of the inactivity-timeout property",2],["comm_inactivity_timeout=","EventMachine::Connection","classes/EventMachine/Connection.html#M000065","(value)","Allows you to set the inactivity-timeout property for a network connection or datagram socket. Specify",2],["completed?","EventMachine::Completion","classes/EventMachine/Completion.html#M000023","()","Indicates that we've reached some kind of completion state, by default this is :succeeded or :failed.",2],["completion","EventMachine::Completion","classes/EventMachine/Completion.html#M000020","(*a, &b)","Completions are called when you enter (or are in) either a :failed or a :succeeded state. They are stored",2],["completion","EventMachine::Pool","classes/EventMachine/Pool.html#M000111","(deferrable, resource)","",2],["completion_states","EventMachine::Completion","classes/EventMachine/Completion.html#M000024","()","Completion states simply returns a list of completion states, by default this is :succeeded and :failed.",2],["concurrency=","EventMachine::Iterator","classes/EventMachine/Iterator.html#M000093","(val)","Change the concurrency of this iterator. Workers will automatically be spawned or destroyed to accomodate",2],["connect","EventMachine","classes/EventMachine.html#M000511","(server, port=nil, handler=nil, *args, &blk)","Initiates a TCP connection to a remote server and sets up event handling for the connection. {EventMachine.connect}",2],["connect","EventMachine::EvmaTCPClient","classes/EventMachine/EvmaTCPClient.html#M000396","(bind_addr, bind_port, host, port)","",2],["connect","EventMachine::EvmaUNIXClient","classes/EventMachine/EvmaUNIXClient.html#M000408","(chain)","",2],["connect","EventMachine::Protocols::HttpClient2","classes/EventMachine/Protocols/HttpClient2.html#M000153","(*args)","Make a connection to a remote HTTP server. Can take either a pair of arguments (which will be interpreted",2],["connect","EventMachine::Protocols::Memcache","classes/EventMachine/Protocols/Memcache.html#M000185","(host = 'localhost', port = 11211)","Connect to a memcached server (must support NOREPLY, memcached >= 1.2.4) ",2],["connect","EventMachine::Protocols::Postgres3","classes/EventMachine/Protocols/Postgres3.html#M000202","(db, user, psw=nil)","",2],["connect","EventMachine::Protocols::Stomp","classes/EventMachine/Protocols/Stomp.html#M000290","(parms={})","CONNECT command, for authentication connect :login => 'guest', :passcode => 'guest' ",2],["connect_server","EventMachine","classes/EventMachine.html#M000463","(server, port)","",2],["connect_server","EventMachine","classes/EventMachine.html#M000307","(host, port)","@private ",2],["connect_unix_domain","EventMachine","classes/EventMachine.html#M000517","(socketname, *args, &blk)","Make a connection to a Unix-domain socket. This method is simply an alias for {.connect}, which can connect",2],["connect_unix_server","EventMachine","classes/EventMachine.html#M000314","(chain)","@private ",2],["connection_completed","EventMachine::Connection","classes/EventMachine/Connection.html#M000050","()","Called by the event loop when a remote TCP connection attempt completes successfully. You can expect",2],["connection_completed","EventMachine::Protocols::HttpClient","classes/EventMachine/Protocols/HttpClient.html#M000136","()","We send the request when we get a connection. AND, we set an instance variable to indicate we passed",2],["connection_completed","EventMachine::Protocols::HttpClient2","classes/EventMachine/Protocols/HttpClient2.html#M000158","()","@private ",2],["connection_completed","EventMachine::Protocols::Memcache","classes/EventMachine/Protocols/Memcache.html#M000190","()","@private ",2],["connection_completed","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000217","()","@private ",2],["connection_completed","EventMachine::Protocols::TcpConnectTester","classes/EventMachine/Protocols/TcpConnectTester.html#M000288","()","",2],["connection_count","EventMachine","classes/EventMachine.html#M000522","()","Returns the total number of connections (file descriptors) currently held by the reactor. Note that a",2],["connection_ended","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000274","()","Sent when the remote peer has ended the connection. ",2],["consume_line","EventMachine::Protocols::Stomp::Message","classes/EventMachine/Protocols/Stomp/Message.html#M000280","(line)","@private ",2],["contents","EventMachine::Pool","classes/EventMachine/Pool.html#M000100","()","Returns a list for introspection purposes only. You should *NEVER* call modification or work oriented",2],["crank_selectables","EventMachine::Reactor","classes/EventMachine/Reactor.html#M000362","()","",2],["create","EventMachine::EvmaUDPSocket","classes/EventMachine/EvmaUDPSocket.html#M000433","(host, port)","",2],["defer","EventMachine","classes/EventMachine.html#M000524","(op = nil, callback = nil, &blk)","EventMachine.defer is used for integrating blocking operations into EventMachine's control flow. The",2],["del","EventMachine::Protocols::Memcache","classes/EventMachine/Protocols/Memcache.html#M000184","(key, expires = 0, &cb)","Alias for #delete",2],["delete","EventMachine::Protocols::Memcache","classes/EventMachine/Protocols/Memcache.html#M000183","(key, expires = 0, &cb)","Delete the value associated with a key cache.del :a cache.del(:b){ puts \"deleted the value!\" } ",2],["detach","EventMachine::Connection","classes/EventMachine/Connection.html#M000044","()","Removes given connection from the event loop. The connection's socket remains open and its file descriptor",2],["detach_fd","EventMachine","classes/EventMachine.html#M000488","(sig)","",2],["disable_proxy","EventMachine","classes/EventMachine.html#M000536","(from)","Takes just one argument, a {Connection} that has proxying enabled via {EventMachine.enable_proxy}. Calling",2],["dispatch","EventMachine::ThreadedResource","classes/EventMachine/ThreadedResource.html#M000421","()","Called on the EM thread, generally in a perform block to return a completion for the work. ",2],["dispatch_conn_message","EventMachine::Protocols::Postgres3","classes/EventMachine/Protocols/Postgres3.html#M000206","(msg)","Cloned and modified from the postgres-pr. ",2],["dispatch_query_message","EventMachine::Protocols::Postgres3","classes/EventMachine/Protocols/Postgres3.html#M000210","(msg)","Cloned and modified from the postgres-pr. ",2],["dispatch_request","EventMachine::Protocols::HeaderAndContentProtocol","classes/EventMachine/Protocols/HeaderAndContentProtocol.html#M000129","()","",2],["dispatch_response","EventMachine::Protocols::HttpClient","classes/EventMachine/Protocols/HttpClient.html#M000148","()","",2],["each","EventMachine::Iterator","classes/EventMachine/Iterator.html#M000094","(foreach=nil, after=nil, &blk)","Iterate over a set of items using the specified block or proc. EM::Iterator.new(1..100).each do |num,",2],["empty?","BufferedTokenizer","classes/BufferedTokenizer.html#M000003","()","@return [Boolean] ",2],["empty?","EventMachine::Queue","classes/EventMachine/Queue.html#M000298","()","@return [Boolean] @note This is a peek, it's not thread safe, and may only tend toward accuracy. ",2],["enable_proxy","EventMachine","classes/EventMachine.html#M000535","(from, to, bufsize=0, length=0)","This method allows for direct writing of incoming data back out to another descriptor, at the C++ level",2],["ensure_mapping_extension_is_present","EventMachine::FileStreamer","classes/EventMachine/FileStreamer.html#M000403","()","We use an outboard extension class to get memory-mapped files. It's outboard to avoid polluting the core",2],["epoll","EventMachine","classes/EventMachine.html#M000322","()","This method is a harmless no-op in the pure-Ruby implementation. This is intended to ensure that user",2],["epoll","EventMachine","classes/EventMachine.html#M000473","()","",2],["epoll=","EventMachine","classes/EventMachine.html#M000474","(val)","",2],["epoll?","EventMachine","classes/EventMachine.html#M000477","()","",2],["errback","EventMachine::Completion","classes/EventMachine/Completion.html#M000019","(*a, &b)","Errbacks are called when you enter (or are in) a :failed state. ",2],["errback","EventMachine::Deferrable","classes/EventMachine/Deferrable.html#M000054","(&block)","Specify a block to be executed if and when the Deferrable object receives a status of :failed. See #set_deferred_status",2],["error?","EventMachine::Connection","classes/EventMachine/Connection.html#M000049","()","Returns true if the connection is in an error state, false otherwise. In general, you can detect the",2],["error_handler","EventMachine","classes/EventMachine.html#M000534","(cb = nil, &blk)","Catch-all for errors raised during event loop callbacks. @example EventMachine.error_handler{ |e| puts",2],["eventCallback","EventMachine::JEM","classes/EventMachine/JEM.html#M000452","(a1, a2, a3, a4)","",2],["event_callback","EventMachine","classes/EventMachine.html#M000539","(conn_binding, opcode, data)","@private ",2],["eventable_read","EventMachine::EvmaTCPServer","classes/EventMachine/EvmaTCPServer.html#M000416","()","",2],["eventable_read","EventMachine::EvmaUDPSocket","classes/EventMachine/EvmaUDPSocket.html#M000435","()","Proper nonblocking I/O was added to Ruby 1.8.4 in May 2006. If we have it, then we can read multiple",2],["eventable_read","EventMachine::EvmaUNIXServer","classes/EventMachine/EvmaUNIXServer.html#M000423","()","",2],["eventable_read","EventMachine::LoopbreakReader","classes/EventMachine/LoopbreakReader.html#M000427","()","",2],["eventable_read","EventMachine::StreamObject","classes/EventMachine/StreamObject.html#M000387","()","Proper nonblocking I/O was added to Ruby 1.8.4 in May 2006. If we have it, then we can read multiple",2],["eventable_write","EventMachine::EvmaTCPClient","classes/EventMachine/EvmaTCPClient.html#M000402","()","",2],["eventable_write","EventMachine::EvmaUDPSocket","classes/EventMachine/EvmaUDPSocket.html#M000434","()","#eventable_write This really belongs in DatagramObject, but there is some UDP-specific stuff. ",2],["eventable_write","EventMachine::EvmaUNIXClient","classes/EventMachine/EvmaUNIXClient.html#M000412","()","",2],["eventable_write","EventMachine::StreamObject","classes/EventMachine/StreamObject.html#M000388","()","Provisional implementation. Will be re-implemented in subclasses. TODO: Complete this implementation.",2],["execute_callbacks","EventMachine::Completion","classes/EventMachine/Completion.html#M000032","()","Execute all callbacks for the current state. If in a completed state, then call any statebacks associated",2],["execute_state_callbacks","EventMachine::Completion","classes/EventMachine/Completion.html#M000033","(state)","Iterate all callbacks for a given state, and remove then call them. ",2],["extract","BufferedTokenizer","classes/BufferedTokenizer.html#M000001","(data)","Extract takes an arbitrary string of input data and returns an array of tokenized entities, provided",2],["fail","EventMachine::Completion","classes/EventMachine/Completion.html#M000015","(*args)","Enter the :failed state, setting the result value if given. ",2],["fail","EventMachine::Deferrable","classes/EventMachine/Deferrable.html#M000071","(*args)","Sugar for set_deferred_status(:failed, ...) ",2],["failure","EventMachine::Pool","classes/EventMachine/Pool.html#M000110","(resource)","",2],["file_deleted","EventMachine::FileWatch","classes/EventMachine/FileWatch.html#M000088","()","Will be called when the file is deleted. Supposed to be redefined by subclasses. When the file is deleted,",2],["file_modified","EventMachine::FileWatch","classes/EventMachine/FileWatch.html#M000087","()","Will be called when the file is modified. Supposed to be redefined by subclasses. @abstract ",2],["file_moved","EventMachine::FileWatch","classes/EventMachine/FileWatch.html#M000089","()","Will be called when the file is moved or renamed. Supposed to be redefined by subclasses. @abstract ",2],["fire","EventMachine::PeriodicTimer","classes/EventMachine/PeriodicTimer.html#M000449","()","@private ",2],["flush","BufferedTokenizer","classes/BufferedTokenizer.html#M000002","()","Flush the contents of the input buffer, i.e. return the input buffer even though a token has not yet",2],["fork_reactor","EventMachine","classes/EventMachine.html#M000502","(&block)","Forks a new process, properly stops the reactor and then calls {EventMachine.run} inside of it again,",2],["future","EventMachine::Deferrable","classes/EventMachine/Deferrable.html#M000091","(arg, cb=nil, eb=nil, &blk)","A future is a sugaring of a typical deferrable usage. ",2],["gen_id","EventMachine::Channel","classes/EventMachine/Channel.html#M000011","()","@private ",2],["generate","EventMachine::UuidGenerator","classes/EventMachine/UuidGenerator.html#M000346","()","",2],["get","EventMachine::Protocols::HttpClient2","classes/EventMachine/Protocols/HttpClient2.html#M000154","(args)","Get a url req = conn.get(:uri => '/') req.callback{|response| puts response.content } ",2],["get","EventMachine::Protocols::Memcache","classes/EventMachine/Protocols/Memcache.html#M000175","(*keys)","Get the value associated with one or multiple keys cache.get(:a){ |v| p v } cache.get(:a,:b,:c,:d){ |a,b,c,d|",2],["get_connection_count","EventMachine","classes/EventMachine.html#M000493","()","",2],["get_field","JavaFields","classes/JavaFields.html#M000451","(key)","",2],["get_hash","EventMachine::Protocols::Memcache","classes/EventMachine/Protocols/Memcache.html#M000182","(*keys)","Gets multiple values as a hash cache.get_hash(:a, :b, :c, :d){ |h| puts h[:a] } ",2],["get_max_timer_count","EventMachine","classes/EventMachine.html#M000484","()","",2],["get_max_timers","EventMachine","classes/EventMachine.html#M000521","()","Gets the current maximum number of allowed timers @return [Integer] Maximum number of timers that may",2],["get_outbound_data_size","EventMachine","classes/EventMachine.html#M000334","(sig)","@private ",2],["get_outbound_data_size","EventMachine::Connection","classes/EventMachine/Connection.html#M000341","()","@private ",2],["get_outbound_data_size","EventMachine::DatagramObject","classes/EventMachine/DatagramObject.html#M000432","()","#get_outbound_data_size ",2],["get_outbound_data_size","EventMachine::StreamObject","classes/EventMachine/StreamObject.html#M000392","()","#get_outbound_data_size ",2],["get_peer_cert","EventMachine::Connection","classes/EventMachine/Connection.html#M000055","()","If [TLS](http://en.wikipedia.org/wiki/Transport_Layer_Security) is active on the connection, returns",2],["get_peername","EventMachine","classes/EventMachine.html#M000486","(sig)","",2],["get_peername","EventMachine","classes/EventMachine.html#M000316","(sig)","@private ",2],["get_peername","EventMachine::Connection","classes/EventMachine/Connection.html#M000059","()","This method is used with stream-connections to obtain the identity of the remotely-connected peer. If",2],["get_peername","EventMachine::Selectable","classes/EventMachine/Selectable.html#M000380","()","",2],["get_peername","EventMachine::StreamObject","classes/EventMachine/StreamObject.html#M000391","()","#get_peername This is defined in the normal way on connected stream objects. Return an object that is",2],["get_pid","EventMachine::Connection","classes/EventMachine/Connection.html#M000061","()","Returns the PID (kernel process identifier) of a subprocess associated with this Connection object. For",2],["get_selectable","EventMachine::Reactor","classes/EventMachine/Reactor.html#M000355","(uuid)","",2],["get_server_domain","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000268","()","The domain name returned in the first line of the response to a successful EHLO or HELO command. ",2],["get_server_greeting","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000267","()","The greeting returned in the initial connection message to the client. ",2],["get_sock_opt","EventMachine","classes/EventMachine.html#M000326","(signature, level, optname)","@private ",2],["get_sock_opt","EventMachine::Connection","classes/EventMachine/Connection.html#M000045","(level, option)","",2],["get_sockname","EventMachine::Connection","classes/EventMachine/Connection.html#M000060","()","Used with stream-connections to obtain the identity of the local side of the connection. If a local name",2],["get_status","EventMachine::Connection","classes/EventMachine/Connection.html#M000063","()","Returns a subprocess exit status. Only useful for {EventMachine.popen}. Call it in your {#unbind} handler.",2],["headers_2_hash","EventMachine::Protocols::HeaderAndContentProtocol","classes/EventMachine/Protocols/HeaderAndContentProtocol.html#M000131","(hdrs)","Basically a convenience method. We might create a subclass that does this automatically. But it's such",2],["headers_2_hash","EventMachine::Protocols::HeaderAndContentProtocol","classes/EventMachine/Protocols/HeaderAndContentProtocol.html#M000132","(hdrs)","",2],["heartbeat","EventMachine::Selectable","classes/EventMachine/Selectable.html#M000382","()","",2],["heartbeat","EventMachine::StreamObject","classes/EventMachine/StreamObject.html#M000393","()","",2],["heartbeat_interval","EventMachine","classes/EventMachine.html#M000537","()","Retrieve the heartbeat interval. This is how often EventMachine will check for dead connections that",2],["heartbeat_interval=","EventMachine","classes/EventMachine.html#M000538","(time)","Set the heartbeat interval. This is how often EventMachine will check for dead connections that have",2],["hosts","EventMachine::DNS::Resolver","classes/EventMachine/DNS/Resolver.html#M000332","()","",2],["id","EventMachine::DNS::Request","classes/EventMachine/DNS/Request.html#M000359","()","",2],["init_for_request","EventMachine::Protocols::HeaderAndContentProtocol","classes/EventMachine/Protocols/HeaderAndContentProtocol.html#M000130","()","",2],["init_message_reader","EventMachine::Protocols::Stomp","classes/EventMachine/Protocols/Stomp.html#M000285","()","@private ",2],["init_protocol_state","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000241","()","",2],["initialize_event_machine","EventMachine","classes/EventMachine.html#M000453","()","class Connection < com.rubyeventmachine.Connection def associate_callback_target sig # No-op for the",2],["initialize_event_machine","EventMachine","classes/EventMachine.html#M000300","()","@private ",2],["initialize_for_run","EventMachine::Reactor","classes/EventMachine/Reactor.html#M000351","()","Called before run, this is a good place to clear out arrays with cruft that may be left over from a previous",2],["inject","EventMachine::Iterator","classes/EventMachine/Iterator.html#M000102","(obj, foreach, after)","Inject the results of an asynchronous iteration onto a given object. EM::Iterator.new(%w[ pwd uptime",2],["install_oneshot_timer","EventMachine::Reactor","classes/EventMachine/Reactor.html#M000350","(interval)","",2],["invoke_auth","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000232","()","Perform an authentication. If the caller didn't request one, then fall through to the mail-from state.",2],["invoke_data","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000244","()","",2],["invoke_error","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000220","()","We encountered an error from the server and will close the connection. Use the error and message the",2],["invoke_internal_error","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000224","(msg = \"???\")","We encountered an error on our side of the protocol and will close the connection. Use an extra-protocol",2],["invoke_mail_from","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000237","()","",2],["invoke_popen","EventMachine","classes/EventMachine.html#M000481","(cmd)","",2],["invoke_rcpt_to","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000239","()","",2],["invoke_starttls","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000230","()","",2],["is_notify_readable","EventMachine","classes/EventMachine.html#M000491","(sig)","",2],["is_notify_writable","EventMachine","classes/EventMachine.html#M000492","(sig)","",2],["klass_from_handler","EventMachine","classes/EventMachine.html#M000541","(klass = Connection, handler = nil, *args)","@private ",2],["kqueue","EventMachine","classes/EventMachine.html#M000475","()","",2],["kqueue=","EventMachine","classes/EventMachine.html#M000476","(val)","",2],["kqueue?","EventMachine","classes/EventMachine.html#M000478","()","",2],["lbp_init_line_state","EventMachine::Protocols::LineAndTextProtocol","classes/EventMachine/Protocols/LineAndTextProtocol.html#M000168","()","",2],["library_type","EventMachine","classes/EventMachine.html#M000299","()","This is mostly useful for automated tests. Return a distinctive symbol so the caller knows whether he's",2],["library_type","EventMachine","classes/EventMachine.html#M000485","()","",2],["map","EventMachine::Iterator","classes/EventMachine/Iterator.html#M000095","(foreach, after)","Collect the results of an asynchronous iteration into an array. EM::Iterator.new(%w[ pwd uptime uname",2],["nameserver","EventMachine::DNS::Resolver","classes/EventMachine/DNS/Resolver.html#M000331","()","",2],["nameserver","EventMachine::DNS::Socket","classes/EventMachine/DNS/Socket.html#M000345","()","",2],["nameserver=","EventMachine::DNS::Socket","classes/EventMachine/DNS/Socket.html#M000344","(ns)","",2],["nameservers","EventMachine::DNS::Resolver","classes/EventMachine/DNS/Resolver.html#M000328","()","",2],["nameservers=","EventMachine::DNS::Resolver","classes/EventMachine/DNS/Resolver.html#M000327","(ns)","",2],["new","BufferedTokenizer","classes/BufferedTokenizer.html#M000000","(delimiter = \"\\n\", size_limit = nil)","@param [String] delimiter @param [Integer] size_limit ",2],["new","EventMachine::Channel","classes/EventMachine/Channel.html#M000004","()","",2],["new","EventMachine::Completion","classes/EventMachine/Completion.html#M000012","()","",2],["new","EventMachine::Connection","classes/EventMachine/Connection.html#M000026","(*args)","Stubbed initialize so legacy superclasses can safely call super @private ",2],["new","EventMachine::Connection","classes/EventMachine/Connection.html#M000025","(sig, *args)","Override .new so subclasses don't have to call super and can ignore connection-specific arguments @private",2],["new","EventMachine::DNS::Request","classes/EventMachine/DNS/Request.html#M000348","(socket, hostname)","",2],["new","EventMachine::DNS::Socket","classes/EventMachine/DNS/Socket.html#M000335","()","",2],["new","EventMachine::DatagramObject","classes/EventMachine/DatagramObject.html#M000428","(io)","",2],["new","EventMachine::DeferrableChildProcess","classes/EventMachine/DeferrableChildProcess.html#M000118","()","@private ",2],["new","EventMachine::EvmaKeyboard","classes/EventMachine/EvmaKeyboard.html#M000405","(io)","",2],["new","EventMachine::EvmaTCPClient","classes/EventMachine/EvmaTCPClient.html#M000399","(io)","",2],["new","EventMachine::EvmaTCPServer","classes/EventMachine/EvmaTCPServer.html#M000414","(io)","",2],["new","EventMachine::EvmaUNIXClient","classes/EventMachine/EvmaUNIXClient.html#M000409","(io)","",2],["new","EventMachine::EvmaUNIXServer","classes/EventMachine/EvmaUNIXServer.html#M000419","(io)","",2],["new","EventMachine::FileStreamer","classes/EventMachine/FileStreamer.html#M000394","(connection, filename, args = {})","@param [EventMachine::Connection] connection @param [String] filename File path @option args [Boolean]",2],["new","EventMachine::Iterator","classes/EventMachine/Iterator.html#M000092","(list, concurrency = 1)","Create a new parallel async iterator with specified concurrency. i = EM::Iterator.new(1..100, 10) will",2],["new","EventMachine::PeriodicTimer","classes/EventMachine/PeriodicTimer.html#M000446","(interval, callback=nil, &block)","Create a new periodic timer that executes every interval seconds ",2],["new","EventMachine::Pool","classes/EventMachine/Pool.html#M000097","()","",2],["new","EventMachine::Protocols::HeaderAndContentProtocol","classes/EventMachine/Protocols/HeaderAndContentProtocol.html#M000126","(*args)","",2],["new","EventMachine::Protocols::HttpClient","classes/EventMachine/Protocols/HttpClient.html#M000133","()","",2],["new","EventMachine::Protocols::HttpClient2","classes/EventMachine/Protocols/HttpClient2.html#M000139","()","",2],["new","EventMachine::Protocols::HttpClient2::Request","classes/EventMachine/Protocols/HttpClient2/Request.html#M000140","(conn, args)","",2],["new","EventMachine::Protocols::LineAndTextProtocol","classes/EventMachine/Protocols/LineAndTextProtocol.html#M000163","(*args)","",2],["new","EventMachine::Protocols::Memcache","classes/EventMachine/Protocols/Memcache.html#M000189","(host, port = 11211)","@private ",2],["new","EventMachine::Protocols::Postgres3","classes/EventMachine/Protocols/Postgres3.html#M000201","()","",2],["new","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000214","()","",2],["new","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000222","(*args)","",2],["new","EventMachine::Protocols::Socks4","classes/EventMachine/Protocols/Socks4.html#M000258","(host, port)","",2],["new","EventMachine::Protocols::Stomp::Message","classes/EventMachine/Protocols/Stomp/Message.html#M000279","()","@private ",2],["new","EventMachine::Queue","classes/EventMachine/Queue.html#M000294","()","",2],["new","EventMachine::Reactor","classes/EventMachine/Reactor.html#M000349","()","",2],["new","EventMachine::Selectable","classes/EventMachine/Selectable.html#M000369","(io)","",2],["new","EventMachine::StreamObject","classes/EventMachine/StreamObject.html#M000383","(io)","",2],["new","EventMachine::SystemCmd","classes/EventMachine/SystemCmd.html#M000122","(cb)","",2],["new","EventMachine::ThreadedResource","classes/EventMachine/ThreadedResource.html#M000420","()","The block should return the resource that will be yielded in a dispatch. ",2],["new","EventMachine::TickLoop","classes/EventMachine/TickLoop.html#M000438","(*a, &b)","Arguments: A callback (EM::Callback) to call each tick. If the call returns +:stop+ then the loop will",2],["new","EventMachine::Timer","classes/EventMachine/Timer.html#M000444","(interval, callback=nil, &block)","Create a new timer that fires after a given number of seconds ",2],["new","EventMachine::YieldBlockFromSpawnedProcess","classes/EventMachine/YieldBlockFromSpawnedProcess.html#M000373","(block, notify)","",2],["new","TestConnection","classes/TestConnection.html#M000198","()","",2],["next_tick","EventMachine","classes/EventMachine.html#M000526","(pr=nil, &block)","Schedules a proc for execution immediately after the next \"turn\" through the reactor core. An advanced",2],["notify","EventMachine::SpawnedProcess","classes/EventMachine/SpawnedProcess.html#M000368","(*x)","Send a message to the spawned process ",2],["notify_readable=","EventMachine::Connection","classes/EventMachine/Connection.html#M000078","(mode)","Watches connection for readability. Only possible if the connection was created using {EventMachine.attach}",2],["notify_readable?","EventMachine::Connection","classes/EventMachine/Connection.html#M000079","()","@return [Boolean] true if the connection is being watched for readability. ",2],["notify_writable=","EventMachine::Connection","classes/EventMachine/Connection.html#M000080","(mode)","Watches connection for writeability. Only possible if the connection was created using {EventMachine.attach}",2],["notify_writable?","EventMachine::Connection","classes/EventMachine/Connection.html#M000081","()","Returns true if the connection is being watched for writability. ",2],["num_waiting","EventMachine::Pool","classes/EventMachine/Pool.html#M000107","()","A peek at the number of enqueued jobs waiting for resources ",2],["num_waiting","EventMachine::Queue","classes/EventMachine/Queue.html#M000306","()","@return [Integer] Waiting size @note This is a peek at the number of jobs that are currently waiting",2],["on_error","EventMachine::Pool","classes/EventMachine/Pool.html#M000101","(*a, &b)","Define a default catch-all for when the deferrables returned by work blocks enter a failed state. By",2],["on_stop","EventMachine::TickLoop","classes/EventMachine/TickLoop.html#M000439","(*a, &b)","Arguments: A callback (EM::Callback) to call once on the next stop (or immediately if already stopped).",2],["open","EventMachine::DNS::Socket","classes/EventMachine/DNS/Socket.html#M000333","()","",2],["open","EventMachine::DeferrableChildProcess","classes/EventMachine/DeferrableChildProcess.html#M000119","(cmd)","Sugars a common use-case involving forked child processes. #open takes a String argument containing an",2],["open","EventMachine::EvmaKeyboard","classes/EventMachine/EvmaKeyboard.html#M000404","()","",2],["open_datagram_socket","EventMachine","classes/EventMachine.html#M000518","(address, port, handler=nil, *args)","Used for UDP-based protocols. Its usage is similar to that of {EventMachine.start_server}. This method",2],["open_keyboard","EventMachine","classes/EventMachine.html#M000531","(handler=nil, *args)","(Experimental) @private ",2],["open_loopbreaker","EventMachine::Reactor","classes/EventMachine/Reactor.html#M000364","()","",2],["open_udp_socket","EventMachine","classes/EventMachine.html#M000480","(server, port)","",2],["open_udp_socket","EventMachine","classes/EventMachine.html#M000317","(host, port)","@private ",2],["packet","EventMachine::DNS::Request","classes/EventMachine/DNS/Request.html#M000360","()","",2],["parms=","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000223","(parms={})","",2],["parms=","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000221","(parms={})","",2],["parse_response_line","EventMachine::Protocols::HttpClient","classes/EventMachine/Protocols/HttpClient.html#M000145","()","We get called here when we have received an HTTP response line. It's an opportunity to throw an exception",2],["path","EventMachine::FileWatch","classes/EventMachine/FileWatch.html#M000086","()","Returns the path that is being monitored. @note Current implementation does not pick up on the new filename",2],["pause","EventMachine::Connection","classes/EventMachine/Connection.html#M000082","()","Pause a connection so that {#send_data} and {#receive_data} events are not fired until {#resume} is called.",2],["paused?","EventMachine::Connection","classes/EventMachine/Connection.html#M000084","()","@return [Boolean] true if the connect was paused using {EventMachine::Connection#pause}. @see #pause",2],["pending_connect_timeout","EventMachine::Connection","classes/EventMachine/Connection.html#M000070","()","The duration after which a TCP connection in the connecting state will fail. It is important to distinguish",2],["pending_connect_timeout=","EventMachine::Connection","classes/EventMachine/Connection.html#M000073","(value)","Sets the duration after which a TCP connection in a connecting state will fail. @param [Float, #to_f]",2],["perform","EventMachine::Pool","classes/EventMachine/Pool.html#M000103","(*a, &b)","Perform a given #call-able object or block. The callable object will be called with a resource from the",2],["pid","EventMachine::ProcessWatch","classes/EventMachine/ProcessWatch.html#M000114","()","Returns the pid that EventMachine::watch_process was originally called with. ",2],["pop","EventMachine::Channel","classes/EventMachine/Channel.html#M000010","(*a, &b)","Fetches one message from the channel. ",2],["pop","EventMachine::Queue","classes/EventMachine/Queue.html#M000295","(*a, &b)","Pop items off the queue, running the block on the reactor thread. The pop will not happen immediately,",2],["pop_request","EventMachine::Protocols::HttpClient2","classes/EventMachine/Protocols/HttpClient2.html#M000165","()","",2],["popen","EventMachine","classes/EventMachine.html#M000529","(cmd, handler=nil, *args)","Runs an external process. @example module RubyCounter def post_init # count up to 5 send_data \"5\\n\" end",2],["post","EventMachine::Protocols::HttpClient2","classes/EventMachine/Protocols/HttpClient2.html#M000155","(args)","Post to a url req = conn.post('/data') req.callback{|response| puts response.content } ",2],["post_init","EventMachine::Connection","classes/EventMachine/Connection.html#M000030","()","Called by the event loop immediately after the network connection has been established, and before resumption",2],["post_init","EventMachine::DNS::Socket","classes/EventMachine/DNS/Socket.html#M000336","()","",2],["post_init","EventMachine::Protocols::HttpClient","classes/EventMachine/Protocols/HttpClient.html#M000135","()","",2],["post_init","EventMachine::Protocols::HttpClient2","classes/EventMachine/Protocols/HttpClient2.html#M000157","()","@private ",2],["post_init","EventMachine::Protocols::SASLauth","classes/EventMachine/Protocols/SASLauth.html#M000207","()","",2],["post_init","EventMachine::Protocols::SASLauthclient","classes/EventMachine/Protocols/SASLauthclient.html#M000212","()","",2],["post_init","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000216","()","@private ",2],["post_init","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000225","()","In SMTP, the server talks first. But by a (perhaps flawed) axiom in EM, #post_init will execute BEFORE",2],["post_init","EventMachine::Protocols::Socks4","classes/EventMachine/Protocols/Socks4.html#M000260","()","",2],["post_init","EventMachine::Protocols::TcpConnectTester","classes/EventMachine/Protocols/TcpConnectTester.html#M000287","()","",2],["process","EventMachine::Pool","classes/EventMachine/Pool.html#M000112","(work, resource)","",2],["process_auth","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000251","(str)","",2],["process_auth_line","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000252","(line)","",2],["process_cmd","EventMachine::Protocols::Memcache","classes/EventMachine/Protocols/Memcache.html#M000194","(line)","",2],["process_data","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000253","()","",2],["process_data_line","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000266","(ln)","Send the incoming data to the application one chunk at a time, rather than one line at a time. That lets",2],["process_ehlo","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000243","(domain)","",2],["process_exited","EventMachine::ProcessWatch","classes/EventMachine/ProcessWatch.html#M000116","()","Should be redefined with the user's custom callback that will be fired when the process exits. stop_watching",2],["process_expn","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000235","()","TODO - implement this properly, the implementation is a stub! ",2],["process_forked","EventMachine::ProcessWatch","classes/EventMachine/ProcessWatch.html#M000115","()","Should be redefined with the user's custom callback that will be fired when the prcess is forked. There",2],["process_header","EventMachine::Protocols::HttpClient2::Request","classes/EventMachine/Protocols/HttpClient2/Request.html#M000150","()","",2],["process_helo","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000246","(domain)","",2],["process_help","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000234","()","TODO - implement this properly, the implementation is a stub! ",2],["process_mail_from","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000257","(sender)","",2],["process_noop","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000249","()","",2],["process_quit","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000247","()","",2],["process_rcpt_to","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000261","(rcpt)","",2],["process_rset","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000254","()","",2],["process_starttls","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000256","()","",2],["process_unknown","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000250","()","",2],["process_vrfy","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000233","()","TODO - implement this properly, the implementation is a stub! ",2],["proxy_completed","EventMachine::Connection","classes/EventMachine/Connection.html#M000040","()","called when the reactor finished proxying all of the requested bytes. ",2],["proxy_incoming_to","EventMachine::Connection","classes/EventMachine/Connection.html#M000041","(conn,bufsize=0)","EventMachine::Connection#proxy_incoming_to is called only by user code. It sets up a low-level proxy",2],["proxy_target_unbound","EventMachine::Connection","classes/EventMachine/Connection.html#M000039","()","Called by the reactor after attempting to relay incoming data to a descriptor (set as a proxy target",2],["pull_out_yield_block","EventMachine::YieldBlockFromSpawnedProcess","classes/EventMachine/YieldBlockFromSpawnedProcess.html#M000374","()","",2],["push","EventMachine::Channel","classes/EventMachine/Channel.html#M000008","(*items)","Add items to the channel, which are pushed out to all subscribers. ",2],["push","EventMachine::Queue","classes/EventMachine/Queue.html#M000296","(*items)","Push items onto the queue in the reactor thread. The items will not appear in the queue immediately,",2],["query","EventMachine::Protocols::Postgres3","classes/EventMachine/Protocols/Postgres3.html#M000203","(sql)","",2],["reactor_running?","EventMachine","classes/EventMachine.html#M000530","()","Tells you whether the EventMachine reactor loop is currently running. Useful when writing libraries that",2],["reactor_thread?","EventMachine","classes/EventMachine.html#M000500","()","@return [Boolean] true if the calling thread is the same thread as the reactor. ",2],["read_exactly_n_bytes","StringIO","classes/StringIO.html#M000200","(n)","Alias for #readbytes",2],["read_keyboard","EventMachine","classes/EventMachine.html#M000339","()","@private ",2],["read_keyboard","EventMachine","classes/EventMachine.html#M000482","()","",2],["readbytes","StringIO","classes/StringIO.html#M000199","(n)","Reads exactly +n+ bytes. If the data read is nil an EOFError is raised. If the data read is too short",2],["receive_answer","EventMachine::DNS::Request","classes/EventMachine/DNS/Request.html#M000353","(msg)","",2],["receive_auth_response","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000236","()","",2],["receive_binary_data","EventMachine::Protocols::HeaderAndContentProtocol","classes/EventMachine/Protocols/HeaderAndContentProtocol.html#M000128","(text)","",2],["receive_binary_data","EventMachine::Protocols::HttpClient2","classes/EventMachine/Protocols/HttpClient2.html#M000162","(text)","@private ",2],["receive_binary_data","EventMachine::Protocols::LineText2","classes/EventMachine/Protocols/LineText2.html#M000179","(data)","Stub. Should be subclassed by user code. ",2],["receive_binary_data","EventMachine::Protocols::Stomp","classes/EventMachine/Protocols/Stomp.html#M000284","(data)","@private ",2],["receive_chunk_header","EventMachine::Protocols::HttpClient2::Request","classes/EventMachine/Protocols/HttpClient2/Request.html#M000146","(ln)","",2],["receive_chunk_trailer","EventMachine::Protocols::HttpClient2::Request","classes/EventMachine/Protocols/HttpClient2/Request.html#M000143","(ln)","",2],["receive_chunked_text","EventMachine::Protocols::HttpClient2::Request","classes/EventMachine/Protocols/HttpClient2/Request.html#M000147","(text)","",2],["receive_data","EventMachine::Connection","classes/EventMachine/Connection.html#M000035","(data)","Called by the event loop whenever data has been received by the network connection. It is never called",2],["receive_data","EventMachine::DNS::Socket","classes/EventMachine/DNS/Socket.html#M000347","(data)","Decodes the packet, looks for the request and passes the response over to the requester ",2],["receive_data","EventMachine::DeferrableChildProcess","classes/EventMachine/DeferrableChildProcess.html#M000120","(data)","@private ",2],["receive_data","EventMachine::FileWatch","classes/EventMachine/FileWatch.html#M000085","(data)","@private ",2],["receive_data","EventMachine::ProcessWatch","classes/EventMachine/ProcessWatch.html#M000113","(data)","@private ",2],["receive_data","EventMachine::Protocols::HttpClient","classes/EventMachine/Protocols/HttpClient.html#M000138","(data)","",2],["receive_data","EventMachine::Protocols::LineAndTextProtocol","classes/EventMachine/Protocols/LineAndTextProtocol.html#M000164","(data)","",2],["receive_data","EventMachine::Protocols::LineProtocol","classes/EventMachine/Protocols/LineProtocol.html#M000169","(data)","@private ",2],["receive_data","EventMachine::Protocols::LineText2","classes/EventMachine/Protocols/LineText2.html#M000171","(data)","",2],["receive_data","EventMachine::Protocols::Memcache","classes/EventMachine/Protocols/Memcache.html#M000191","(data)","",2],["receive_data","EventMachine::Protocols::ObjectProtocol","classes/EventMachine/Protocols/ObjectProtocol.html#M000188","(data)","@private ",2],["receive_data","EventMachine::Protocols::Postgres3","classes/EventMachine/Protocols/Postgres3.html#M000204","(data)","",2],["receive_data","EventMachine::Protocols::SASLauth","classes/EventMachine/Protocols/SASLauth.html#M000208","(data)","",2],["receive_data","EventMachine::Protocols::SASLauthclient","classes/EventMachine/Protocols/SASLauthclient.html#M000213","(data)","",2],["receive_data","EventMachine::Protocols::Socks4","classes/EventMachine/Protocols/Socks4.html#M000262","(*a)","",2],["receive_data","EventMachine::SystemCmd","classes/EventMachine/SystemCmd.html#M000123","(data)","",2],["receive_data_chunk","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000276","(data)","Sent when data from the remote peer is available. The size can be controlled by setting the :chunksize",2],["receive_data_command","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000275","()","Called when the remote peer sends the DATA command. Returning false will cause us to send a 550 error",2],["receive_data_response","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000245","()","",2],["receive_ehlo_domain","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000269","(domain)","A false response from this user-overridable method will cause a 550 error to be returned to the remote",2],["receive_ehlo_response","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000229","()","",2],["receive_end_of_binary_data","EventMachine::Protocols::LineText2","classes/EventMachine/Protocols/LineText2.html#M000180","()","Stub. Should be subclassed by user code. This is called when transitioning internally from text mode",2],["receive_header_line","EventMachine::Protocols::HttpClient2::Request","classes/EventMachine/Protocols/HttpClient2/Request.html#M000144","(ln)","",2],["receive_line","EventMachine::Protocols::HeaderAndContentProtocol","classes/EventMachine/Protocols/HeaderAndContentProtocol.html#M000127","(line)","",2],["receive_line","EventMachine::Protocols::HttpClient2","classes/EventMachine/Protocols/HttpClient2.html#M000161","(ln)","@private ",2],["receive_line","EventMachine::Protocols::HttpClient2::Request","classes/EventMachine/Protocols/HttpClient2/Request.html#M000142","(ln)","",2],["receive_line","EventMachine::Protocols::LineProtocol","classes/EventMachine/Protocols/LineProtocol.html#M000170","(line)","Invoked with lines received over the network ",2],["receive_line","EventMachine::Protocols::LineText2","classes/EventMachine/Protocols/LineText2.html#M000178","(ln)","Stub. Should be subclassed by user code. ",2],["receive_line","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000219","(ln)","@private ",2],["receive_line","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000227","(ln)","",2],["receive_line","EventMachine::Protocols::Stomp","classes/EventMachine/Protocols/Stomp.html#M000282","(line)","@private ",2],["receive_mail_from_response","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000238","()","",2],["receive_message","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000277","()","Sent after a message has been completely received. User code must return true or false to indicate whether",2],["receive_message_response","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000248","()","",2],["receive_msg","EventMachine::Protocols::Stomp","classes/EventMachine/Protocols/Stomp.html#M000286","(msg)","Invoked with an incoming Stomp::Message received from the STOMP server ",2],["receive_object","EventMachine::Protocols::ObjectProtocol","classes/EventMachine/Protocols/ObjectProtocol.html#M000192","(obj)","Invoked with ruby objects received over the network ",2],["receive_plain_auth","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000270","(user, password)","Return true or false to indicate that the authentication is acceptable. ",2],["receive_rcpt_to_response","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000242","()","",2],["receive_recipient","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000272","(rcpt)","Receives the argument of a RCPT TO command. Can be given multiple times per transaction. Return false",2],["receive_reset","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000273","()","Sent when the remote peer issues the RSET command. Since RSET is not allowed to fail (according to the",2],["receive_sender","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000271","(sender)","Receives the argument of the MAIL FROM command. Return false to indicate to the remote client that the",2],["receive_signon","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000228","()","",2],["receive_sized_text","EventMachine::Protocols::HttpClient2::Request","classes/EventMachine/Protocols/HttpClient2/Request.html#M000152","(text)","",2],["receive_starttls_response","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000231","()","",2],["receive_text","EventMachine::Protocols::HttpClient2::Request","classes/EventMachine/Protocols/HttpClient2/Request.html#M000151","(text)","",2],["receive_transaction","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000278","()","This is called when the protocol state is reset. It happens when the remote client calls EHLO/HELO or",2],["reconnect","EventMachine","classes/EventMachine.html#M000516","(server, port, handler)","Connect to a given host/port and re-use the provided {EventMachine::Connection} instance. Consider also",2],["reconnect","EventMachine::Connection","classes/EventMachine/Connection.html#M000075","(server, port)","Reconnect to a given host/port with the current instance @param [String] server Hostname or IP address",2],["register_request","EventMachine::DNS::Socket","classes/EventMachine/DNS/Socket.html#M000342","(id, req)","",2],["release_machine","EventMachine","classes/EventMachine.html#M000454","()","",2],["release_machine","EventMachine","classes/EventMachine.html#M000303","()","@private ",2],["remove","EventMachine::Pool","classes/EventMachine/Pool.html#M000099","(resource)","",2],["removed?","EventMachine::Pool","classes/EventMachine/Pool.html#M000108","(resource)","Removed will show resources in a partial pruned state. Resources in the removed list may not appear in",2],["request","EventMachine::Protocols::HttpClient","classes/EventMachine/Protocols/HttpClient.html#M000134","( args = {} )","@param args [Hash] The request arguments @option args [String] :host The host IP/DNS name @option args",2],["request","EventMachine::Protocols::HttpClient2","classes/EventMachine/Protocols/HttpClient2.html#M000160","(args)","@private ",2],["requeue","EventMachine::Pool","classes/EventMachine/Pool.html#M000109","(resource)","",2],["reschedule","EventMachine::Pool","classes/EventMachine/Pool.html#M000106","(*a, &b)","Alias for #perform",2],["reset_protocol_state","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000240","()","",2],["resolve","EventMachine::DNS::Resolver","classes/EventMachine/DNS/Resolver.html#M000320","(hostname)","",2],["restore_methods","EventMachine::Protocols::Socks4","classes/EventMachine/Protocols/Socks4.html#M000263","()","",2],["resume","EventMachine::Connection","classes/EventMachine/Connection.html#M000083","()","Resume a connection's {#send_data} and {#receive_data} events. @see #pause ",2],["resume","EventMachine::SpawnedProcess","classes/EventMachine/SpawnedProcess.html#M000370","(*x)","Alias for #notify",2],["run","EventMachine","classes/EventMachine.html#M000498","(blk=nil, tail=nil, &block)","Initializes and runs an event loop. This method only returns if code inside the block passed to this",2],["run","EventMachine::Reactor","classes/EventMachine/Reactor.html#M000356","()","",2],["run","EventMachine::SpawnedProcess","classes/EventMachine/SpawnedProcess.html#M000371","(*x)","Alias for #notify",2],["run_block","EventMachine","classes/EventMachine.html#M000499","(&block)","Sugars a common use case. Will pass the given block to #run, but will terminate the reactor loop and",2],["run_deferred_callbacks","EventMachine","classes/EventMachine.html#M000523","()","The is the responder for the loopback-signalled event. It can be fired either by code running on a separate",2],["run_heartbeats","EventMachine::Reactor","classes/EventMachine/Reactor.html#M000361","()","",2],["run_machine","EventMachine","classes/EventMachine.html#M000302","()","@private ",2],["run_machine","EventMachine","classes/EventMachine.html#M000456","()","",2],["run_timers","EventMachine::Reactor","classes/EventMachine/Reactor.html#M000358","()","",2],["schedule","EventMachine","classes/EventMachine.html#M000501","(*a, &b)","Runs the given callback on the reactor thread, or immediately if called from the reactor thread. Accepts",2],["schedule","EventMachine::PeriodicTimer","classes/EventMachine/PeriodicTimer.html#M000448","()","@private ",2],["schedule","EventMachine::TickLoop","classes/EventMachine/TickLoop.html#M000443","()","",2],["schedule_close","EventMachine::EvmaTCPServer","classes/EventMachine/EvmaTCPServer.html#M000417","()","",2],["schedule_close","EventMachine::EvmaUNIXServer","classes/EventMachine/EvmaUNIXServer.html#M000425","()","",2],["schedule_close","EventMachine::StreamObject","classes/EventMachine/StreamObject.html#M000390","(after_writing)","#schedule_close The application wants to close the connection. ",2],["select_for_reading?","EventMachine::DatagramObject","classes/EventMachine/DatagramObject.html#M000431","()","#select_for_reading? ",2],["select_for_reading?","EventMachine::EvmaKeyboard","classes/EventMachine/EvmaKeyboard.html#M000407","()","",2],["select_for_reading?","EventMachine::EvmaTCPClient","classes/EventMachine/EvmaTCPClient.html#M000401","()","",2],["select_for_reading?","EventMachine::EvmaTCPServer","classes/EventMachine/EvmaTCPServer.html#M000415","()","",2],["select_for_reading?","EventMachine::EvmaUNIXClient","classes/EventMachine/EvmaUNIXClient.html#M000411","()","",2],["select_for_reading?","EventMachine::EvmaUNIXServer","classes/EventMachine/EvmaUNIXServer.html#M000422","()","",2],["select_for_reading?","EventMachine::LoopbreakReader","classes/EventMachine/LoopbreakReader.html#M000426","()","",2],["select_for_reading?","EventMachine::Selectable","classes/EventMachine/Selectable.html#M000378","()","",2],["select_for_reading?","EventMachine::StreamObject","classes/EventMachine/StreamObject.html#M000385","()","If we have to close, or a close-after-writing has been requested, then don't read any more data. ",2],["select_for_writing?","EventMachine::DatagramObject","classes/EventMachine/DatagramObject.html#M000430","()","#select_for_writing? ",2],["select_for_writing?","EventMachine::EvmaKeyboard","classes/EventMachine/EvmaKeyboard.html#M000406","()","",2],["select_for_writing?","EventMachine::EvmaTCPClient","classes/EventMachine/EvmaTCPClient.html#M000400","()","",2],["select_for_writing?","EventMachine::EvmaUNIXClient","classes/EventMachine/EvmaUNIXClient.html#M000410","()","",2],["select_for_writing?","EventMachine::Selectable","classes/EventMachine/Selectable.html#M000379","()","",2],["select_for_writing?","EventMachine::StreamObject","classes/EventMachine/StreamObject.html#M000386","()","If we have to close, don't select for writing. Otherwise, see if the protocol is ready to close. If not,",2],["send","EventMachine::DNS::Request","classes/EventMachine/DNS/Request.html#M000357","()","",2],["send","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000215","(args={})",":host => required String a string containing the IP address or host name of the SMTP server to connect",2],["send","EventMachine::Protocols::Stomp","classes/EventMachine/Protocols/Stomp.html#M000291","(destination, body, parms={})","SEND command, for publishing messages to a topic send '/topic/name', 'some message here' ",2],["send_cmd","EventMachine::Protocols::Memcache","classes/EventMachine/Protocols/Memcache.html#M000186","(cmd, key, flags = 0, exptime = 0, bytes = 0, noreply = false)","",2],["send_data","EventMachine","classes/EventMachine.html#M000461","(sig, data, length)","",2],["send_data","EventMachine","classes/EventMachine.html#M000309","(target, data, datalength)","@private ",2],["send_data","EventMachine::Connection","classes/EventMachine/Connection.html#M000048","(data)","Call this method to send data to the remote end of the network connection. It takes a single String argument,",2],["send_data","EventMachine::EvmaUDPSocket","classes/EventMachine/EvmaUDPSocket.html#M000437","(data)","",2],["send_data","EventMachine::StreamObject","classes/EventMachine/StreamObject.html#M000389","(data)","#send_data ",2],["send_data","TestConnection","classes/TestConnection.html#M000196","(data)","",2],["send_datagram","EventMachine","classes/EventMachine.html#M000462","(sig, data, length, address, port)","",2],["send_datagram","EventMachine","classes/EventMachine.html#M000318","(target, data, datalength, host, port)","This is currently only for UDP! We need to make it work with unix-domain sockets as well. @private ",2],["send_datagram","EventMachine::Connection","classes/EventMachine/Connection.html#M000057","(data, recipient_address, recipient_port)","Sends UDP messages. This method may be called from any Connection object that refers to an open datagram",2],["send_datagram","EventMachine::DatagramObject","classes/EventMachine/DatagramObject.html#M000429","(data, target)","#send_datagram ",2],["send_file_data","EventMachine","classes/EventMachine.html#M000496","(sig, filename)","",2],["send_file_data","EventMachine","classes/EventMachine.html#M000330","(sig, filename)","@private ",2],["send_file_data","EventMachine::Connection","classes/EventMachine/Connection.html#M000076","(filename)","Like {EventMachine::Connection#send_data}, this sends data to the remote end of the network connection.",2],["send_frame","EventMachine::Protocols::Stomp","classes/EventMachine/Protocols/Stomp.html#M000281","(verb, headers={})","@private ",2],["send_object","EventMachine::Protocols::ObjectProtocol","classes/EventMachine/Protocols/ObjectProtocol.html#M000193","(obj)","Sends a ruby object over the network ",2],["send_packet","EventMachine::DNS::Socket","classes/EventMachine/DNS/Socket.html#M000343","(pkt)","",2],["send_request","EventMachine::Protocols::HttpClient","classes/EventMachine/Protocols/HttpClient.html#M000137","(args)","",2],["send_request","EventMachine::Protocols::HttpClient2::Request","classes/EventMachine/Protocols/HttpClient2/Request.html#M000141","()","",2],["send_server_greeting","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000226","()","",2],["sent_data","TestConnection","classes/TestConnection.html#M000197","()","",2],["serializer","EventMachine::Protocols::ObjectProtocol","classes/EventMachine/Protocols/ObjectProtocol.html#M000187","()","By default returns Marshal, override to return JSON or YAML, or any other serializer/deserializer responding",2],["set","EventMachine::Protocols::Memcache","classes/EventMachine/Protocols/Memcache.html#M000181","(key, val, exptime = 0, &cb)","Set the value for a given key cache.set :a, 'hello' cache.set(:missing, 'abc'){ puts \"stored the value!\"",2],["set_binary_mode","EventMachine::Protocols::LineAndTextProtocol","classes/EventMachine/Protocols/LineAndTextProtocol.html#M000167","(size = nil)","Set up to read the supplied number of binary bytes. This recycles all the data currently waiting in the",2],["set_binary_mode","EventMachine::Protocols::LineText2","classes/EventMachine/Protocols/LineText2.html#M000176","(size=nil)","Alias for #set_text_mode, added for back-compatibility with LineAndTextProtocol. ",2],["set_comm_inactivity_timeout","EventMachine","classes/EventMachine.html#M000466","(sig, interval)","",2],["set_comm_inactivity_timeout","EventMachine","classes/EventMachine.html#M000340","(sig, tm)","@private ",2],["set_comm_inactivity_timeout","EventMachine::Connection","classes/EventMachine/Connection.html#M000069","(value)","Alias for #comm_inactivity_timeout=",2],["set_default_host_header","EventMachine::Protocols::HttpClient2","classes/EventMachine/Protocols/HttpClient2.html#M000156","(host, port, ssl)","",2],["set_deferred_failure","EventMachine::Completion","classes/EventMachine/Completion.html#M000016","(*args)","Alias for #fail",2],["set_deferred_failure","EventMachine::Deferrable","classes/EventMachine/Deferrable.html#M000072","(*args)","Alias for #fail",2],["set_deferred_status","EventMachine::Completion","classes/EventMachine/Completion.html#M000022","(state, *args)","Alias for #change_state",2],["set_deferred_status","EventMachine::Deferrable","classes/EventMachine/Deferrable.html#M000058","(status, *args)","Sets the \"disposition\" (status) of the Deferrable object. See also the large set of sugarings for this",2],["set_deferred_success","EventMachine::Completion","classes/EventMachine/Completion.html#M000014","(*args)","Alias for #succeed",2],["set_deferred_success","EventMachine::Deferrable","classes/EventMachine/Deferrable.html#M000068","(*args)","Alias for #succeed",2],["set_delimiter","EventMachine::Protocols::LineText2","classes/EventMachine/Protocols/LineText2.html#M000172","(delim)","",2],["set_descriptor_table_size","EventMachine","classes/EventMachine.html#M000528","(n_descriptors=nil)","Sets the maximum number of file or socket descriptors that your process may open. If you call this method",2],["set_effective_user","EventMachine","classes/EventMachine.html#M000527","(username)","A wrapper over the setuid system call. Particularly useful when opening a network server on a privileged",2],["set_field","JavaFields","classes/JavaFields.html#M000450","(key, value)","",2],["set_heartbeat_interval","EventMachine","classes/EventMachine.html#M000468","(val)","",2],["set_inactivity_timeout","EventMachine::Selectable","classes/EventMachine/Selectable.html#M000381","(tm)","",2],["set_line_mode","EventMachine::Protocols::LineText2","classes/EventMachine/Protocols/LineText2.html#M000173","(data=\"\")","Called internally but also exposed to user code, for the case in which processing of binary data creates",2],["set_max_timer_count","EventMachine","classes/EventMachine.html#M000483","(num)","",2],["set_max_timer_count","EventMachine","classes/EventMachine.html#M000325","(n)","This method is a harmless no-op in pure Ruby, which doesn't have a built-in limit on the number of available",2],["set_max_timers","EventMachine","classes/EventMachine.html#M000520","(ct)","Sets the maximum number of timers and periodic timers that may be outstanding at any given time. You",2],["set_notify_readable","EventMachine","classes/EventMachine.html#M000489","(sig, mode)","",2],["set_notify_writable","EventMachine","classes/EventMachine.html#M000490","(sig, mode)","",2],["set_pending_connect_timeout","EventMachine","classes/EventMachine.html#M000467","(sig, val)","",2],["set_pending_connect_timeout","EventMachine::Connection","classes/EventMachine/Connection.html#M000074","(value)","Alias for #pending_connect_timeout=",2],["set_quantum","EventMachine","classes/EventMachine.html#M000519","(mills)","For advanced users. This function sets the default timer granularity, which by default is slightly smaller",2],["set_receiver","EventMachine::SpawnedProcess","classes/EventMachine/SpawnedProcess.html#M000372","(blk)","",2],["set_rlimit_nofile","EventMachine","classes/EventMachine.html#M000324","(n)","This method is a no-op in the pure-Ruby implementation. We simply return Ruby's built-in per-process",2],["set_rlimit_nofile","EventMachine","classes/EventMachine.html#M000479","(n_descriptors)","",2],["set_sock_opt","EventMachine","classes/EventMachine.html#M000329","(signature, level, optname, optval)","@private ",2],["set_sock_opt","EventMachine::Connection","classes/EventMachine/Connection.html#M000046","(level, optname, optval)","",2],["set_text_mode","EventMachine::Protocols::LineText2","classes/EventMachine/Protocols/LineText2.html#M000174","(size=nil)","",2],["set_timer_quantum","EventMachine","classes/EventMachine.html#M000472","(q)","",2],["set_timer_quantum","EventMachine","classes/EventMachine.html#M000319","(interval)","Sets reactor quantum in milliseconds. The underlying Reactor function wants a (possibly fractional) number",2],["set_timer_quantum","EventMachine::Reactor","classes/EventMachine/Reactor.html#M000367","(interval_in_seconds)","",2],["set_tls_parms","EventMachine","classes/EventMachine.html#M000494","(sig, params)","",2],["setup_methods","EventMachine::Protocols::Socks4","classes/EventMachine/Protocols/Socks4.html#M000259","()","",2],["shutdown","EventMachine::ThreadedResource","classes/EventMachine/ThreadedResource.html#M000424","()","Kill the internal thread. should only be used to cleanup - generally only required for tests. ",2],["signal_loopbreak","EventMachine","classes/EventMachine.html#M000315","()","@private ",2],["signal_loopbreak","EventMachine","classes/EventMachine.html#M000471","()","",2],["signal_loopbreak","EventMachine::Reactor","classes/EventMachine/Reactor.html#M000366","()","",2],["size","EventMachine::Queue","classes/EventMachine/Queue.html#M000305","()","@return [Integer] Queue size @note This is a peek, it's not thread safe, and may only tend toward accuracy.",2],["socket","EventMachine::DNS::Resolver","classes/EventMachine/DNS/Resolver.html#M000321","()","",2],["socks_post_init","EventMachine::Protocols::Socks4","classes/EventMachine/Protocols/Socks4.html#M000264","()","",2],["socks_receive_data","EventMachine::Protocols::Socks4","classes/EventMachine/Protocols/Socks4.html#M000265","(data)","",2],["spawn","EventMachine","classes/EventMachine.html#M000375","(&block)","Spawn an erlang-style process ",2],["spawn_threadpool","EventMachine","classes/EventMachine.html#M000525","()","@private ",2],["spawn_workers","EventMachine::Iterator","classes/EventMachine/Iterator.html#M000105","()","Spawn workers to consume items from the iterator's enumerator based on the current concurrency level.",2],["ssl?","EventMachine","classes/EventMachine.html#M000470","()","",2],["ssl?","EventMachine","classes/EventMachine.html#M000323","()","This method is not implemented for pure-Ruby implementation @private ",2],["ssl_handshake_completed","EventMachine::Connection","classes/EventMachine/Connection.html#M000036","()","Called by EventMachine when the SSL/TLS handshake has been completed, as a result of calling #start_tls",2],["ssl_verify_peer","EventMachine::Connection","classes/EventMachine/Connection.html#M000037","(cert)","Called by EventMachine when :verify_peer => true has been passed to {#start_tls}. It will be called with",2],["start","EventMachine::TickLoop","classes/EventMachine/TickLoop.html#M000442","()","Start the tick loop, will raise argument error if the loop is already running. ",2],["start_server","EventMachine","classes/EventMachine.html#M000508","(server, port=nil, handler=nil, *args, &block)","Initiates a TCP server (socket acceptor) on the specified IP address and port. The IP address must be",2],["start_server","EventMachine::EvmaTCPServer","classes/EventMachine/EvmaTCPServer.html#M000413","(host, port)","Versions of ruby 1.8.4 later than May 26 2006 will work properly with an object of type TCPServer. Prior",2],["start_server","EventMachine::EvmaUNIXServer","classes/EventMachine/EvmaUNIXServer.html#M000418","(chain)","Versions of ruby 1.8.4 later than May 26 2006 will work properly with an object of type TCPServer. Prior",2],["start_tcp_server","EventMachine","classes/EventMachine.html#M000311","(host, port)","@private ",2],["start_tcp_server","EventMachine","classes/EventMachine.html#M000458","(server, port)","",2],["start_tls","EventMachine","classes/EventMachine.html#M000495","(sig)","",2],["start_tls","EventMachine","classes/EventMachine.html#M000469","(sig)","",2],["start_tls","EventMachine::Connection","classes/EventMachine/Connection.html#M000051","(args={})","Call {#start_tls} at any point to initiate TLS encryption on connected streams. The method is smart enough",2],["start_unix_domain_server","EventMachine","classes/EventMachine.html#M000510","(filename, *args, &block)","Start a Unix-domain server. Note that this is an alias for {EventMachine.start_server}, which can be",2],["start_unix_server","EventMachine","classes/EventMachine.html#M000460","(filename)","",2],["start_unix_server","EventMachine","classes/EventMachine.html#M000313","(chain)","@private ",2],["stateback","EventMachine::Completion","classes/EventMachine/Completion.html#M000017","(state, *a, &b)","Statebacks are called when you enter (or are in) the named state. ",2],["stop","EventMachine","classes/EventMachine.html#M000457","()","",2],["stop","EventMachine","classes/EventMachine.html#M000304","()","@private ",2],["stop","EventMachine::Reactor","classes/EventMachine/Reactor.html#M000363","()","#stop ",2],["stop","EventMachine::TickLoop","classes/EventMachine/TickLoop.html#M000440","()","Stop the tick loop immediately, and call it's on_stop callbacks. ",2],["stop_event_loop","EventMachine","classes/EventMachine.html#M000507","()","Causes the processing loop to stop executing, which will cause all open connections and accepting servers",2],["stop_proxying","EventMachine::Connection","classes/EventMachine/Connection.html#M000042","()","A helper method for {EventMachine.disable_proxy} ",2],["stop_server","EventMachine","classes/EventMachine.html#M000509","(signature)","Stop a TCP server socket that was started with {EventMachine.start_server}. @see EventMachine.start_server",2],["stop_tcp_server","EventMachine","classes/EventMachine.html#M000312","(sig)","@private ",2],["stop_tcp_server","EventMachine","classes/EventMachine.html#M000459","(sig)","",2],["stop_watching","EventMachine::FileWatch","classes/EventMachine/FileWatch.html#M000090","()","Discontinue monitoring of the file. This involves cleaning up the underlying monitoring details with",2],["stop_watching","EventMachine::ProcessWatch","classes/EventMachine/ProcessWatch.html#M000117","()","Discontinue monitoring of the process. This will be called automatically when a process dies. User code",2],["stopped?","EventMachine::TickLoop","classes/EventMachine/TickLoop.html#M000441","()","Query if the loop is stopped. ",2],["stream_file_data","EventMachine::Connection","classes/EventMachine/Connection.html#M000077","(filename, args={})","Open a file on the filesystem and send it to the remote peer. This returns an object of type {EventMachine::Deferrable}.",2],["stream_one_chunk","EventMachine::FileStreamer","classes/EventMachine/FileStreamer.html#M000398","()","Used internally to stream one chunk at a time over multiple reactor ticks @private ",2],["stream_with_mapping","EventMachine::FileStreamer","classes/EventMachine/FileStreamer.html#M000397","(filename)","@private ",2],["stream_without_mapping","EventMachine::FileStreamer","classes/EventMachine/FileStreamer.html#M000395","(filename)","@private ",2],["subscribe","EventMachine::Channel","classes/EventMachine/Channel.html#M000005","(*a, &b)","Takes any arguments suitable for EM::Callback() and returns a subscriber id for use when unsubscribing.",2],["subscribe","EventMachine::Protocols::Stomp","classes/EventMachine/Protocols/Stomp.html#M000292","(dest, ack=false)","SUBSCRIBE command, for subscribing to topics subscribe '/topic/name', false ",2],["succeed","EventMachine::Completion","classes/EventMachine/Completion.html#M000013","(*args)","Enter the :succeeded state, setting the result value if given. ",2],["succeed","EventMachine::Deferrable","classes/EventMachine/Deferrable.html#M000067","(*args)","Sugar for set_deferred_status(:succeeded, ...) ",2],["system","EventMachine","classes/EventMachine.html#M000125","(cmd, *args, &cb)","EM::system is a simple wrapper for EM::popen. It is similar to Kernel::system, but requires a single",2],["test","EventMachine::Protocols::TcpConnectTester","classes/EventMachine/Protocols/TcpConnectTester.html#M000283","( host, port )","",2],["tick","EventMachine::DNS::Request","classes/EventMachine/DNS/Request.html#M000352","()","",2],["tick","EventMachine::DNS::Socket","classes/EventMachine/DNS/Socket.html#M000338","()","",2],["tick_loop","EventMachine","classes/EventMachine.html#M000436","(*a, &b)","Creates and immediately starts an EventMachine::TickLoop ",2],["timeout","EventMachine::Completion","classes/EventMachine/Completion.html#M000027","(time, *args)","Schedule a time which if passes before we enter a completion state, this deferrable will be failed with",2],["timeout","EventMachine::Deferrable","classes/EventMachine/Deferrable.html#M000062","(seconds, *args)","Setting a timeout on a Deferrable causes it to go into the failed state after the Timeout expires (passing",2],["unbind","EventMachine::Connection","classes/EventMachine/Connection.html#M000038","()","called by the framework whenever a connection (either a server or client connection) is closed. The close",2],["unbind","EventMachine::DNS::Socket","classes/EventMachine/DNS/Socket.html#M000337","()","",2],["unbind","EventMachine::DeferrableChildProcess","classes/EventMachine/DeferrableChildProcess.html#M000121","()","@private ",2],["unbind","EventMachine::Protocols::HttpClient","classes/EventMachine/Protocols/HttpClient.html#M000149","()","",2],["unbind","EventMachine::Protocols::HttpClient2","classes/EventMachine/Protocols/HttpClient2.html#M000159","()","",2],["unbind","EventMachine::Protocols::LineAndTextProtocol","classes/EventMachine/Protocols/LineAndTextProtocol.html#M000166","()","",2],["unbind","EventMachine::Protocols::LineText2","classes/EventMachine/Protocols/LineText2.html#M000177","()","In case of a dropped connection, we'll send a partial buffer to user code when in sized text mode. User",2],["unbind","EventMachine::Protocols::Memcache","classes/EventMachine/Protocols/Memcache.html#M000195","()","@private ",2],["unbind","EventMachine::Protocols::Postgres3","classes/EventMachine/Protocols/Postgres3.html#M000205","()","",2],["unbind","EventMachine::Protocols::SmtpClient","classes/EventMachine/Protocols/SmtpClient.html#M000218","()","We can get here in a variety of ways, all of them being failures unless the @succeeded flag is set. If",2],["unbind","EventMachine::Protocols::SmtpServer","classes/EventMachine/Protocols/SmtpServer.html#M000255","()","",2],["unbind","EventMachine::Protocols::TcpConnectTester","classes/EventMachine/Protocols/TcpConnectTester.html#M000289","()","",2],["unbind","EventMachine::SystemCmd","classes/EventMachine/SystemCmd.html#M000124","()","",2],["unsubscribe","EventMachine::Channel","classes/EventMachine/Channel.html#M000007","(name)","Removes subscriber from the list. @param [Integer] Subscriber identifier @see #subscribe ",2],["validate","EventMachine::Protocols::SASLauth","classes/EventMachine/Protocols/SASLauth.html#M000209","(username, psw, sysname, realm)","",2],["validate?","EventMachine::Protocols::SASLauthclient","classes/EventMachine/Protocols/SASLauthclient.html#M000211","(username, psw, sysname=nil, realm=nil)","",2],["watch","EventMachine","classes/EventMachine.html#M000513","(io, handler=nil, *args, &blk)","{EventMachine.watch} registers a given file descriptor or IO object with the eventloop. The file descriptor",2],["watch_file","EventMachine","classes/EventMachine.html#M000532","(filename, handler=nil, *args)","EventMachine's file monitoring API. Currently supported are the following events on individual files,",2],["watch_process","EventMachine","classes/EventMachine.html#M000533","(pid, handler=nil, *args)","EventMachine's process monitoring API. On Mac OS X and *BSD this method is implemented using kqueue.",2],["yield","EventMachine","classes/EventMachine.html#M000376","(&block)","@private ",2],["yield_and_notify","EventMachine","classes/EventMachine.html#M000384","(&block)","@private ",2],["LICENSE","files/LICENSE.html","files/LICENSE.html","","EventMachine is copyrighted free software owned by Francis Cianfrocca (blackhedd ... gmail.com). The",3],["README.md","files/README_md.html","files/README_md.html","","# About EventMachine #   ## What is EventMachine ##  EventMachine is an event-driven I/O and lightweight",3],["DocumentationGuidesIndex.md","files/docs/DocumentationGuidesIndex_md.html","files/docs/DocumentationGuidesIndex_md.html","","# EventMachine documentation guides #  Welcome to the documentation guides for [EventMachine](http://github.com/eventmachine/eventmachine),",3],["GettingStarted.md","files/docs/GettingStarted_md.html","files/docs/GettingStarted_md.html","","# @title Getting Started with Ruby EventMachine # @markup markdown # @author Michael S. Klishin, Dan",3],["ChangeLog","files/docs/old/ChangeLog.html","files/docs/old/ChangeLog.html","","01Oct06: Replaced EventMachine#open_datagram_server with a version that can   take a Class or a Module,",3],["DEFERRABLES","files/docs/old/DEFERRABLES.html","files/docs/old/DEFERRABLES.html","","EventMachine (EM) adds two different formalisms for lightweight concurrency to the Ruby programmer's",3],["EPOLL","files/docs/old/EPOLL.html","files/docs/old/EPOLL.html","","EventMachine now supports epoll, bringing large increases in performance and scalability to Ruby programs.",3],["INSTALL","files/docs/old/INSTALL.html","files/docs/old/INSTALL.html","","If you have obtained an EventMachine source-tarball (.tar.gz): unzip and untar the tarball, and enter",3],["KEYBOARD","files/docs/old/KEYBOARD.html","files/docs/old/KEYBOARD.html","","EventMachine (EM) can respond to keyboard events. This gives your event-driven programs the ability to",3],["LEGAL","files/docs/old/LEGAL.html","files/docs/old/LEGAL.html","","LEGAL NOTICE INFORMATION ------------------------  EventMachine is Copyright (C) 2006-07 by Francis Cianfrocca.",3],["LIGHTWEIGHT_CONCURRENCY","files/docs/old/LIGHTWEIGHT_CONCURRENCY.html","files/docs/old/LIGHTWEIGHT_CONCURRENCY.html","","EventMachine (EM) adds two different formalisms for lightweight concurrency to the Ruby programmer's",3],["PURE_RUBY","files/docs/old/PURE_RUBY.html","files/docs/old/PURE_RUBY.html","","EventMachine is supplied in three alternative versions.  1) A version that includes a Ruby extension",3],["RELEASE_NOTES","files/docs/old/RELEASE_NOTES.html","files/docs/old/RELEASE_NOTES.html","","RUBY/EventMachine RELEASE NOTES  -------------------------------------------------- Version: 0.9.0, released",3],["SMTP","files/docs/old/SMTP.html","files/docs/old/SMTP.html","","This note details the usage of EventMachine's built-in support for SMTP. EM supports both client and",3],["SPAWNED_PROCESSES","files/docs/old/SPAWNED_PROCESSES.html","files/docs/old/SPAWNED_PROCESSES.html","","EventMachine (EM) adds two different formalisms for lightweight concurrency to the Ruby programmer's",3],["TODO","files/docs/old/TODO.html","files/docs/old/TODO.html","","TODO List:  12Aug06: Noticed by Don Stocks. A TCP connect-request that results in a failed DNS resolution",3],["buftok.rb","files/lib/em/buftok_rb.html","files/lib/em/buftok_rb.html","","BufferedTokenizer takes a delimiter upon instantiation, or acts line-based by default.  It allows input",3],["callback.rb","files/lib/em/callback_rb.html","files/lib/em/callback_rb.html","","",3],["channel.rb","files/lib/em/channel_rb.html","files/lib/em/channel_rb.html","","",3],["completion.rb","files/lib/em/completion_rb.html","files/lib/em/completion_rb.html","","= EM::Completion A completion is a callback container for various states of completion. In it's most",3],["connection.rb","files/lib/em/connection_rb.html","files/lib/em/connection_rb.html","","",3],["deferrable.rb","files/lib/em/deferrable_rb.html","files/lib/em/deferrable_rb.html","","",3],["pool.rb","files/lib/em/deferrable/pool_rb.html","files/lib/em/deferrable/pool_rb.html","","",3],["file_watch.rb","files/lib/em/file_watch_rb.html","files/lib/em/file_watch_rb.html","","",3],["future.rb","files/lib/em/future_rb.html","files/lib/em/future_rb.html","","",3],["iterator.rb","files/lib/em/iterator_rb.html","files/lib/em/iterator_rb.html","","",3],["messages.rb","files/lib/em/messages_rb.html","files/lib/em/messages_rb.html","","",3],["pool.rb","files/lib/em/pool_rb.html","files/lib/em/pool_rb.html","","",3],["process_watch.rb","files/lib/em/process_watch_rb.html","files/lib/em/process_watch_rb.html","","",3],["processes.rb","files/lib/em/processes_rb.html","files/lib/em/processes_rb.html","","",3],["protocols.rb","files/lib/em/protocols_rb.html","files/lib/em/protocols_rb.html","","",3],["header_and_content.rb","files/lib/em/protocols/header_and_content_rb.html","files/lib/em/protocols/header_and_content_rb.html","","",3],["httpclient.rb","files/lib/em/protocols/httpclient_rb.html","files/lib/em/protocols/httpclient_rb.html","","",3],["httpclient2.rb","files/lib/em/protocols/httpclient2_rb.html","files/lib/em/protocols/httpclient2_rb.html","","",3],["line_and_text.rb","files/lib/em/protocols/line_and_text_rb.html","files/lib/em/protocols/line_and_text_rb.html","","",3],["line_protocol.rb","files/lib/em/protocols/line_protocol_rb.html","files/lib/em/protocols/line_protocol_rb.html","","",3],["linetext2.rb","files/lib/em/protocols/linetext2_rb.html","files/lib/em/protocols/linetext2_rb.html","","",3],["memcache.rb","files/lib/em/protocols/memcache_rb.html","files/lib/em/protocols/memcache_rb.html","","",3],["object_protocol.rb","files/lib/em/protocols/object_protocol_rb.html","files/lib/em/protocols/object_protocol_rb.html","","",3],["postgres3.rb","files/lib/em/protocols/postgres3_rb.html","files/lib/em/protocols/postgres3_rb.html","","",3],["saslauth.rb","files/lib/em/protocols/saslauth_rb.html","files/lib/em/protocols/saslauth_rb.html","","",3],["smtpclient.rb","files/lib/em/protocols/smtpclient_rb.html","files/lib/em/protocols/smtpclient_rb.html","","",3],["smtpserver.rb","files/lib/em/protocols/smtpserver_rb.html","files/lib/em/protocols/smtpserver_rb.html","","",3],["socks4.rb","files/lib/em/protocols/socks4_rb.html","files/lib/em/protocols/socks4_rb.html","","",3],["stomp.rb","files/lib/em/protocols/stomp_rb.html","files/lib/em/protocols/stomp_rb.html","","",3],["tcptest.rb","files/lib/em/protocols/tcptest_rb.html","files/lib/em/protocols/tcptest_rb.html","","",3],["pure_ruby.rb","files/lib/em/pure_ruby_rb.html","files/lib/em/pure_ruby_rb.html","","",3],["queue.rb","files/lib/em/queue_rb.html","files/lib/em/queue_rb.html","","",3],["resolver.rb","files/lib/em/resolver_rb.html","files/lib/em/resolver_rb.html","","",3],["spawnable.rb","files/lib/em/spawnable_rb.html","files/lib/em/spawnable_rb.html","","",3],["streamer.rb","files/lib/em/streamer_rb.html","files/lib/em/streamer_rb.html","","",3],["threaded_resource.rb","files/lib/em/threaded_resource_rb.html","files/lib/em/threaded_resource_rb.html","","",3],["tick_loop.rb","files/lib/em/tick_loop_rb.html","files/lib/em/tick_loop_rb.html","","",3],["timers.rb","files/lib/em/timers_rb.html","files/lib/em/timers_rb.html","","",3],["version.rb","files/lib/em/version_rb.html","files/lib/em/version_rb.html","","",3],["eventmachine.rb","files/lib/eventmachine_rb.html","files/lib/eventmachine_rb.html","","",3],["jeventmachine.rb","files/lib/jeventmachine_rb.html","files/lib/jeventmachine_rb.html","","",3]],"searchIndex":["bufferedtokenizer","eventmachine","channel","completion","connection","connectionerror","connectionnotbound","dns","request","requestidalreadyused","resolver","socket","datagramobject","defaultdeferrable","deferrable","deferrablechildprocess","error","evmakeyboard","evmatcpclient","evmatcpserver","evmaudpsocket","evmaunixclient","evmaunixserver","filenotfoundexception","filestreamer","filewatch","iterator","jem","loopbreakreader","periodictimer","pool","processwatch","protocols","headerandcontentprotocol","httpclient","httpclient2","request","lineandtextprotocol","lineprotocol","linetext2","memcache","parsererror","objectprotocol","postgres3","saslauth","saslauthclient","smtpclient","smtpserver","socks4","stomp","message","tcpconnecttester","queue","reactor","selectable","spawnedprocess","streamobject","systemcmd","threadedresource","tickloop","timer","unknowntimerfired","unsupported","uuidgenerator","yieldblockfromspawnedprocess","io","javafields","stringio","testconnection","<<()","<<()","callback()","_open_file_for_writing()","ack()","add()","add_oneshot_timer()","add_oneshot_timer()","add_periodic_timer()","add_selectable()","add_shutdown_hook()","add_timer()","associate_callback_target()","attach()","attach_fd()","attach_io()","bind_connect()","bind_connect_server()","bind_connect_server()","callback()","callback()","cancel()","cancel()","cancel_callback()","cancel_callback()","cancel_errback()","cancel_errback()","cancel_timeout()","cancel_timeout()","cancel_timer()","change_state()","clear_dead_callbacks()","close_connection()","close_connection()","close_connection()","close_connection_after_writing()","close_loopbreaker()","close_scheduled?()","comm_inactivity_timeout()","comm_inactivity_timeout=()","completed?()","completion()","completion()","completion_states()","concurrency=()","connect()","connect()","connect()","connect()","connect()","connect()","connect()","connect_server()","connect_server()","connect_unix_domain()","connect_unix_server()","connection_completed()","connection_completed()","connection_completed()","connection_completed()","connection_completed()","connection_completed()","connection_count()","connection_ended()","consume_line()","contents()","crank_selectables()","create()","defer()","del()","delete()","detach()","detach_fd()","disable_proxy()","dispatch()","dispatch_conn_message()","dispatch_query_message()","dispatch_request()","dispatch_response()","each()","empty?()","empty?()","enable_proxy()","ensure_mapping_extension_is_present()","epoll()","epoll()","epoll=()","epoll?()","errback()","errback()","error?()","error_handler()","eventcallback()","event_callback()","eventable_read()","eventable_read()","eventable_read()","eventable_read()","eventable_read()","eventable_write()","eventable_write()","eventable_write()","eventable_write()","execute_callbacks()","execute_state_callbacks()","extract()","fail()","fail()","failure()","file_deleted()","file_modified()","file_moved()","fire()","flush()","fork_reactor()","future()","gen_id()","generate()","get()","get()","get_connection_count()","get_field()","get_hash()","get_max_timer_count()","get_max_timers()","get_outbound_data_size()","get_outbound_data_size()","get_outbound_data_size()","get_outbound_data_size()","get_peer_cert()","get_peername()","get_peername()","get_peername()","get_peername()","get_peername()","get_pid()","get_selectable()","get_server_domain()","get_server_greeting()","get_sock_opt()","get_sock_opt()","get_sockname()","get_status()","headers_2_hash()","headers_2_hash()","heartbeat()","heartbeat()","heartbeat_interval()","heartbeat_interval=()","hosts()","id()","init_for_request()","init_message_reader()","init_protocol_state()","initialize_event_machine()","initialize_event_machine()","initialize_for_run()","inject()","install_oneshot_timer()","invoke_auth()","invoke_data()","invoke_error()","invoke_internal_error()","invoke_mail_from()","invoke_popen()","invoke_rcpt_to()","invoke_starttls()","is_notify_readable()","is_notify_writable()","klass_from_handler()","kqueue()","kqueue=()","kqueue?()","lbp_init_line_state()","library_type()","library_type()","map()","nameserver()","nameserver()","nameserver=()","nameservers()","nameservers=()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","next_tick()","notify()","notify_readable=()","notify_readable?()","notify_writable=()","notify_writable?()","num_waiting()","num_waiting()","on_error()","on_stop()","open()","open()","open()","open_datagram_socket()","open_keyboard()","open_loopbreaker()","open_udp_socket()","open_udp_socket()","packet()","parms=()","parms=()","parse_response_line()","path()","pause()","paused?()","pending_connect_timeout()","pending_connect_timeout=()","perform()","pid()","pop()","pop()","pop_request()","popen()","post()","post_init()","post_init()","post_init()","post_init()","post_init()","post_init()","post_init()","post_init()","post_init()","post_init()","process()","process_auth()","process_auth_line()","process_cmd()","process_data()","process_data_line()","process_ehlo()","process_exited()","process_expn()","process_forked()","process_header()","process_helo()","process_help()","process_mail_from()","process_noop()","process_quit()","process_rcpt_to()","process_rset()","process_starttls()","process_unknown()","process_vrfy()","proxy_completed()","proxy_incoming_to()","proxy_target_unbound()","pull_out_yield_block()","push()","push()","query()","reactor_running?()","reactor_thread?()","read_exactly_n_bytes()","read_keyboard()","read_keyboard()","readbytes()","receive_answer()","receive_auth_response()","receive_binary_data()","receive_binary_data()","receive_binary_data()","receive_binary_data()","receive_chunk_header()","receive_chunk_trailer()","receive_chunked_text()","receive_data()","receive_data()","receive_data()","receive_data()","receive_data()","receive_data()","receive_data()","receive_data()","receive_data()","receive_data()","receive_data()","receive_data()","receive_data()","receive_data()","receive_data()","receive_data()","receive_data_chunk()","receive_data_command()","receive_data_response()","receive_ehlo_domain()","receive_ehlo_response()","receive_end_of_binary_data()","receive_header_line()","receive_line()","receive_line()","receive_line()","receive_line()","receive_line()","receive_line()","receive_line()","receive_line()","receive_mail_from_response()","receive_message()","receive_message_response()","receive_msg()","receive_object()","receive_plain_auth()","receive_rcpt_to_response()","receive_recipient()","receive_reset()","receive_sender()","receive_signon()","receive_sized_text()","receive_starttls_response()","receive_text()","receive_transaction()","reconnect()","reconnect()","register_request()","release_machine()","release_machine()","remove()","removed?()","request()","request()","requeue()","reschedule()","reset_protocol_state()","resolve()","restore_methods()","resume()","resume()","run()","run()","run()","run_block()","run_deferred_callbacks()","run_heartbeats()","run_machine()","run_machine()","run_timers()","schedule()","schedule()","schedule()","schedule_close()","schedule_close()","schedule_close()","select_for_reading?()","select_for_reading?()","select_for_reading?()","select_for_reading?()","select_for_reading?()","select_for_reading?()","select_for_reading?()","select_for_reading?()","select_for_reading?()","select_for_writing?()","select_for_writing?()","select_for_writing?()","select_for_writing?()","select_for_writing?()","select_for_writing?()","send()","send()","send()","send_cmd()","send_data()","send_data()","send_data()","send_data()","send_data()","send_data()","send_datagram()","send_datagram()","send_datagram()","send_datagram()","send_file_data()","send_file_data()","send_file_data()","send_frame()","send_object()","send_packet()","send_request()","send_request()","send_server_greeting()","sent_data()","serializer()","set()","set_binary_mode()","set_binary_mode()","set_comm_inactivity_timeout()","set_comm_inactivity_timeout()","set_comm_inactivity_timeout()","set_default_host_header()","set_deferred_failure()","set_deferred_failure()","set_deferred_status()","set_deferred_status()","set_deferred_success()","set_deferred_success()","set_delimiter()","set_descriptor_table_size()","set_effective_user()","set_field()","set_heartbeat_interval()","set_inactivity_timeout()","set_line_mode()","set_max_timer_count()","set_max_timer_count()","set_max_timers()","set_notify_readable()","set_notify_writable()","set_pending_connect_timeout()","set_pending_connect_timeout()","set_quantum()","set_receiver()","set_rlimit_nofile()","set_rlimit_nofile()","set_sock_opt()","set_sock_opt()","set_text_mode()","set_timer_quantum()","set_timer_quantum()","set_timer_quantum()","set_tls_parms()","setup_methods()","shutdown()","signal_loopbreak()","signal_loopbreak()","signal_loopbreak()","size()","socket()","socks_post_init()","socks_receive_data()","spawn()","spawn_threadpool()","spawn_workers()","ssl?()","ssl?()","ssl_handshake_completed()","ssl_verify_peer()","start()","start_server()","start_server()","start_server()","start_tcp_server()","start_tcp_server()","start_tls()","start_tls()","start_tls()","start_unix_domain_server()","start_unix_server()","start_unix_server()","stateback()","stop()","stop()","stop()","stop()","stop_event_loop()","stop_proxying()","stop_server()","stop_tcp_server()","stop_tcp_server()","stop_watching()","stop_watching()","stopped?()","stream_file_data()","stream_one_chunk()","stream_with_mapping()","stream_without_mapping()","subscribe()","subscribe()","succeed()","succeed()","system()","test()","tick()","tick()","tick_loop()","timeout()","timeout()","unbind()","unbind()","unbind()","unbind()","unbind()","unbind()","unbind()","unbind()","unbind()","unbind()","unbind()","unbind()","unbind()","unsubscribe()","validate()","validate?()","watch()","watch_file()","watch_process()","yield()","yield_and_notify()","license","readme.md","documentationguidesindex.md","gettingstarted.md","changelog","deferrables","epoll","install","keyboard","legal","lightweight_concurrency","pure_ruby","release_notes","smtp","spawned_processes","todo","buftok.rb","callback.rb","channel.rb","completion.rb","connection.rb","deferrable.rb","pool.rb","file_watch.rb","future.rb","iterator.rb","messages.rb","pool.rb","process_watch.rb","processes.rb","protocols.rb","header_and_content.rb","httpclient.rb","httpclient2.rb","line_and_text.rb","line_protocol.rb","linetext2.rb","memcache.rb","object_protocol.rb","postgres3.rb","saslauth.rb","smtpclient.rb","smtpserver.rb","socks4.rb","stomp.rb","tcptest.rb","pure_ruby.rb","queue.rb","resolver.rb","spawnable.rb","streamer.rb","threaded_resource.rb","tick_loop.rb","timers.rb","version.rb","eventmachine.rb","jeventmachine.rb"],"longSearchIndex":["lib/em/buftok.rb","lib/eventmachine.rb","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine::dns","eventmachine::dns","eventmachine::dns","eventmachine::dns","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine::protocols","eventmachine::protocols","eventmachine::protocols","eventmachine::protocols::httpclient2","eventmachine::protocols","eventmachine::protocols","eventmachine::protocols","eventmachine::protocols","eventmachine::protocols::memcache","eventmachine::protocols","eventmachine::protocols","eventmachine::protocols","eventmachine::protocols","eventmachine::protocols","eventmachine::protocols","eventmachine::protocols","eventmachine::protocols","eventmachine::protocols::stomp","eventmachine::protocols","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","lib/em/pure_ruby.rb","lib/jeventmachine.rb","lib/em/protocols/postgres3.rb","lib/em/protocols/memcache.rb","eventmachine::channel","eventmachine::queue","eventmachine","eventmachine","eventmachine::protocols::stomp","eventmachine::pool","eventmachine","eventmachine","eventmachine","eventmachine::reactor","eventmachine","eventmachine","eventmachine::connection","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine::completion","eventmachine::deferrable","eventmachine::periodictimer","eventmachine::timer","eventmachine::completion","eventmachine::deferrable","eventmachine::completion","eventmachine::deferrable","eventmachine::completion","eventmachine::deferrable","eventmachine","eventmachine::completion","eventmachine::completion","eventmachine","eventmachine","eventmachine::connection","eventmachine::connection","eventmachine::reactor","eventmachine::selectable","eventmachine::connection","eventmachine::connection","eventmachine::completion","eventmachine::completion","eventmachine::pool","eventmachine::completion","eventmachine::iterator","eventmachine","eventmachine::evmatcpclient","eventmachine::evmaunixclient","eventmachine::protocols::httpclient2","eventmachine::protocols::memcache","eventmachine::protocols::postgres3","eventmachine::protocols::stomp","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine::connection","eventmachine::protocols::httpclient","eventmachine::protocols::httpclient2","eventmachine::protocols::memcache","eventmachine::protocols::smtpclient","eventmachine::protocols::tcpconnecttester","eventmachine","eventmachine::protocols::smtpserver","eventmachine::protocols::stomp::message","eventmachine::pool","eventmachine::reactor","eventmachine::evmaudpsocket","eventmachine","eventmachine::protocols::memcache","eventmachine::protocols::memcache","eventmachine::connection","eventmachine","eventmachine","eventmachine::threadedresource","eventmachine::protocols::postgres3","eventmachine::protocols::postgres3","eventmachine::protocols::headerandcontentprotocol","eventmachine::protocols::httpclient","eventmachine::iterator","bufferedtokenizer","eventmachine::queue","eventmachine","eventmachine::filestreamer","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine::completion","eventmachine::deferrable","eventmachine::connection","eventmachine","eventmachine::jem","eventmachine","eventmachine::evmatcpserver","eventmachine::evmaudpsocket","eventmachine::evmaunixserver","eventmachine::loopbreakreader","eventmachine::streamobject","eventmachine::evmatcpclient","eventmachine::evmaudpsocket","eventmachine::evmaunixclient","eventmachine::streamobject","eventmachine::completion","eventmachine::completion","bufferedtokenizer","eventmachine::completion","eventmachine::deferrable","eventmachine::pool","eventmachine::filewatch","eventmachine::filewatch","eventmachine::filewatch","eventmachine::periodictimer","bufferedtokenizer","eventmachine","eventmachine::deferrable","eventmachine::channel","eventmachine::uuidgenerator","eventmachine::protocols::httpclient2","eventmachine::protocols::memcache","eventmachine","javafields","eventmachine::protocols::memcache","eventmachine","eventmachine","eventmachine","eventmachine::connection","eventmachine::datagramobject","eventmachine::streamobject","eventmachine::connection","eventmachine","eventmachine","eventmachine::connection","eventmachine::selectable","eventmachine::streamobject","eventmachine::connection","eventmachine::reactor","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine","eventmachine::connection","eventmachine::connection","eventmachine::connection","eventmachine::protocols::headerandcontentprotocol","eventmachine::protocols::headerandcontentprotocol","eventmachine::selectable","eventmachine::streamobject","eventmachine","eventmachine","eventmachine::dns::resolver","eventmachine::dns::request","eventmachine::protocols::headerandcontentprotocol","eventmachine::protocols::stomp","eventmachine::protocols::smtpserver","eventmachine","eventmachine","eventmachine::reactor","eventmachine::iterator","eventmachine::reactor","eventmachine::protocols::smtpclient","eventmachine::protocols::smtpclient","eventmachine::protocols::smtpclient","eventmachine::protocols::smtpclient","eventmachine::protocols::smtpclient","eventmachine","eventmachine::protocols::smtpclient","eventmachine::protocols::smtpclient","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine::protocols::lineandtextprotocol","eventmachine","eventmachine","eventmachine::iterator","eventmachine::dns::resolver","eventmachine::dns::socket","eventmachine::dns::socket","eventmachine::dns::resolver","eventmachine::dns::resolver","bufferedtokenizer","eventmachine::channel","eventmachine::completion","eventmachine::connection","eventmachine::connection","eventmachine::dns::request","eventmachine::dns::socket","eventmachine::datagramobject","eventmachine::deferrablechildprocess","eventmachine::evmakeyboard","eventmachine::evmatcpclient","eventmachine::evmatcpserver","eventmachine::evmaunixclient","eventmachine::evmaunixserver","eventmachine::filestreamer","eventmachine::iterator","eventmachine::periodictimer","eventmachine::pool","eventmachine::protocols::headerandcontentprotocol","eventmachine::protocols::httpclient","eventmachine::protocols::httpclient2","eventmachine::protocols::httpclient2::request","eventmachine::protocols::lineandtextprotocol","eventmachine::protocols::memcache","eventmachine::protocols::postgres3","eventmachine::protocols::smtpclient","eventmachine::protocols::smtpserver","eventmachine::protocols::socks4","eventmachine::protocols::stomp::message","eventmachine::queue","eventmachine::reactor","eventmachine::selectable","eventmachine::streamobject","eventmachine::systemcmd","eventmachine::threadedresource","eventmachine::tickloop","eventmachine::timer","eventmachine::yieldblockfromspawnedprocess","testconnection","eventmachine","eventmachine::spawnedprocess","eventmachine::connection","eventmachine::connection","eventmachine::connection","eventmachine::connection","eventmachine::pool","eventmachine::queue","eventmachine::pool","eventmachine::tickloop","eventmachine::dns::socket","eventmachine::deferrablechildprocess","eventmachine::evmakeyboard","eventmachine","eventmachine","eventmachine::reactor","eventmachine","eventmachine","eventmachine::dns::request","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine::protocols::httpclient","eventmachine::filewatch","eventmachine::connection","eventmachine::connection","eventmachine::connection","eventmachine::connection","eventmachine::pool","eventmachine::processwatch","eventmachine::channel","eventmachine::queue","eventmachine::protocols::httpclient2","eventmachine","eventmachine::protocols::httpclient2","eventmachine::connection","eventmachine::dns::socket","eventmachine::protocols::httpclient","eventmachine::protocols::httpclient2","eventmachine::protocols::saslauth","eventmachine::protocols::saslauthclient","eventmachine::protocols::smtpclient","eventmachine::protocols::smtpserver","eventmachine::protocols::socks4","eventmachine::protocols::tcpconnecttester","eventmachine::pool","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine::protocols::memcache","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine::processwatch","eventmachine::protocols::smtpserver","eventmachine::processwatch","eventmachine::protocols::httpclient2::request","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine::connection","eventmachine::connection","eventmachine::connection","eventmachine::yieldblockfromspawnedprocess","eventmachine::channel","eventmachine::queue","eventmachine::protocols::postgres3","eventmachine","eventmachine","stringio","eventmachine","eventmachine","stringio","eventmachine::dns::request","eventmachine::protocols::smtpclient","eventmachine::protocols::headerandcontentprotocol","eventmachine::protocols::httpclient2","eventmachine::protocols::linetext2","eventmachine::protocols::stomp","eventmachine::protocols::httpclient2::request","eventmachine::protocols::httpclient2::request","eventmachine::protocols::httpclient2::request","eventmachine::connection","eventmachine::dns::socket","eventmachine::deferrablechildprocess","eventmachine::filewatch","eventmachine::processwatch","eventmachine::protocols::httpclient","eventmachine::protocols::lineandtextprotocol","eventmachine::protocols::lineprotocol","eventmachine::protocols::linetext2","eventmachine::protocols::memcache","eventmachine::protocols::objectprotocol","eventmachine::protocols::postgres3","eventmachine::protocols::saslauth","eventmachine::protocols::saslauthclient","eventmachine::protocols::socks4","eventmachine::systemcmd","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpclient","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpclient","eventmachine::protocols::linetext2","eventmachine::protocols::httpclient2::request","eventmachine::protocols::headerandcontentprotocol","eventmachine::protocols::httpclient2","eventmachine::protocols::httpclient2::request","eventmachine::protocols::lineprotocol","eventmachine::protocols::linetext2","eventmachine::protocols::smtpclient","eventmachine::protocols::smtpserver","eventmachine::protocols::stomp","eventmachine::protocols::smtpclient","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpclient","eventmachine::protocols::stomp","eventmachine::protocols::objectprotocol","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpclient","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpserver","eventmachine::protocols::smtpclient","eventmachine::protocols::httpclient2::request","eventmachine::protocols::smtpclient","eventmachine::protocols::httpclient2::request","eventmachine::protocols::smtpserver","eventmachine","eventmachine::connection","eventmachine::dns::socket","eventmachine","eventmachine","eventmachine::pool","eventmachine::pool","eventmachine::protocols::httpclient","eventmachine::protocols::httpclient2","eventmachine::pool","eventmachine::pool","eventmachine::protocols::smtpserver","eventmachine::dns::resolver","eventmachine::protocols::socks4","eventmachine::connection","eventmachine::spawnedprocess","eventmachine","eventmachine::reactor","eventmachine::spawnedprocess","eventmachine","eventmachine","eventmachine::reactor","eventmachine","eventmachine","eventmachine::reactor","eventmachine","eventmachine::periodictimer","eventmachine::tickloop","eventmachine::evmatcpserver","eventmachine::evmaunixserver","eventmachine::streamobject","eventmachine::datagramobject","eventmachine::evmakeyboard","eventmachine::evmatcpclient","eventmachine::evmatcpserver","eventmachine::evmaunixclient","eventmachine::evmaunixserver","eventmachine::loopbreakreader","eventmachine::selectable","eventmachine::streamobject","eventmachine::datagramobject","eventmachine::evmakeyboard","eventmachine::evmatcpclient","eventmachine::evmaunixclient","eventmachine::selectable","eventmachine::streamobject","eventmachine::dns::request","eventmachine::protocols::smtpclient","eventmachine::protocols::stomp","eventmachine::protocols::memcache","eventmachine","eventmachine","eventmachine::connection","eventmachine::evmaudpsocket","eventmachine::streamobject","testconnection","eventmachine","eventmachine","eventmachine::connection","eventmachine::datagramobject","eventmachine","eventmachine","eventmachine::connection","eventmachine::protocols::stomp","eventmachine::protocols::objectprotocol","eventmachine::dns::socket","eventmachine::protocols::httpclient","eventmachine::protocols::httpclient2::request","eventmachine::protocols::smtpserver","testconnection","eventmachine::protocols::objectprotocol","eventmachine::protocols::memcache","eventmachine::protocols::lineandtextprotocol","eventmachine::protocols::linetext2","eventmachine","eventmachine","eventmachine::connection","eventmachine::protocols::httpclient2","eventmachine::completion","eventmachine::deferrable","eventmachine::completion","eventmachine::deferrable","eventmachine::completion","eventmachine::deferrable","eventmachine::protocols::linetext2","eventmachine","eventmachine","javafields","eventmachine","eventmachine::selectable","eventmachine::protocols::linetext2","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine::connection","eventmachine","eventmachine::spawnedprocess","eventmachine","eventmachine","eventmachine","eventmachine::connection","eventmachine::protocols::linetext2","eventmachine","eventmachine","eventmachine::reactor","eventmachine","eventmachine::protocols::socks4","eventmachine::threadedresource","eventmachine","eventmachine","eventmachine::reactor","eventmachine::queue","eventmachine::dns::resolver","eventmachine::protocols::socks4","eventmachine::protocols::socks4","eventmachine","eventmachine","eventmachine::iterator","eventmachine","eventmachine","eventmachine::connection","eventmachine::connection","eventmachine::tickloop","eventmachine","eventmachine::evmatcpserver","eventmachine::evmaunixserver","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine::connection","eventmachine","eventmachine","eventmachine","eventmachine::completion","eventmachine","eventmachine","eventmachine::reactor","eventmachine::tickloop","eventmachine","eventmachine::connection","eventmachine","eventmachine","eventmachine","eventmachine::filewatch","eventmachine::processwatch","eventmachine::tickloop","eventmachine::connection","eventmachine::filestreamer","eventmachine::filestreamer","eventmachine::filestreamer","eventmachine::channel","eventmachine::protocols::stomp","eventmachine::completion","eventmachine::deferrable","eventmachine","eventmachine::protocols::tcpconnecttester","eventmachine::dns::request","eventmachine::dns::socket","eventmachine","eventmachine::completion","eventmachine::deferrable","eventmachine::connection","eventmachine::dns::socket","eventmachine::deferrablechildprocess","eventmachine::protocols::httpclient","eventmachine::protocols::httpclient2","eventmachine::protocols::lineandtextprotocol","eventmachine::protocols::linetext2","eventmachine::protocols::memcache","eventmachine::protocols::postgres3","eventmachine::protocols::smtpclient","eventmachine::protocols::smtpserver","eventmachine::protocols::tcpconnecttester","eventmachine::systemcmd","eventmachine::channel","eventmachine::protocols::saslauth","eventmachine::protocols::saslauthclient","eventmachine","eventmachine","eventmachine","eventmachine","eventmachine","files/license.html","files/readme_md.html","files/docs/documentationguidesindex_md.html","files/docs/gettingstarted_md.html","files/docs/old/changelog.html","files/docs/old/deferrables.html","files/docs/old/epoll.html","files/docs/old/install.html","files/docs/old/keyboard.html","files/docs/old/legal.html","files/docs/old/lightweight_concurrency.html","files/docs/old/pure_ruby.html","files/docs/old/release_notes.html","files/docs/old/smtp.html","files/docs/old/spawned_processes.html","files/docs/old/todo.html","files/lib/em/buftok_rb.html","files/lib/em/callback_rb.html","files/lib/em/channel_rb.html","files/lib/em/completion_rb.html","files/lib/em/connection_rb.html","files/lib/em/deferrable_rb.html","files/lib/em/deferrable/pool_rb.html","files/lib/em/file_watch_rb.html","files/lib/em/future_rb.html","files/lib/em/iterator_rb.html","files/lib/em/messages_rb.html","files/lib/em/pool_rb.html","files/lib/em/process_watch_rb.html","files/lib/em/processes_rb.html","files/lib/em/protocols_rb.html","files/lib/em/protocols/header_and_content_rb.html","files/lib/em/protocols/httpclient_rb.html","files/lib/em/protocols/httpclient2_rb.html","files/lib/em/protocols/line_and_text_rb.html","files/lib/em/protocols/line_protocol_rb.html","files/lib/em/protocols/linetext2_rb.html","files/lib/em/protocols/memcache_rb.html","files/lib/em/protocols/object_protocol_rb.html","files/lib/em/protocols/postgres3_rb.html","files/lib/em/protocols/saslauth_rb.html","files/lib/em/protocols/smtpclient_rb.html","files/lib/em/protocols/smtpserver_rb.html","files/lib/em/protocols/socks4_rb.html","files/lib/em/protocols/stomp_rb.html","files/lib/em/protocols/tcptest_rb.html","files/lib/em/pure_ruby_rb.html","files/lib/em/queue_rb.html","files/lib/em/resolver_rb.html","files/lib/em/spawnable_rb.html","files/lib/em/streamer_rb.html","files/lib/em/threaded_resource_rb.html","files/lib/em/tick_loop_rb.html","files/lib/em/timers_rb.html","files/lib/em/version_rb.html","files/lib/eventmachine_rb.html","files/lib/jeventmachine_rb.html"]}}