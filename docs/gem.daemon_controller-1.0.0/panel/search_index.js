var search_data = {"index":{"longSearchIndex":["lib/daemon_controller.rb","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller::lockfile","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller::lockfile","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller::lockfile","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller::lockfile","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller","daemoncontroller::lockfile","daemoncontroller::lockfile","daemoncontroller","daemoncontroller","daemoncontroller","files/license_txt.html","files/readme_markdown.html","files/lib/daemon_controller_rb.html","files/lib/daemon_controller/lock_file_rb.html","files/lib/daemon_controller/spawn_rb.html","files/lib/daemon_controller/version_rb.html"],"info":[["DaemonController","lib/daemon_controller/lock_file.rb","classes/DaemonController.html"," < Object","Main daemon controller object. See the README for an introduction and tutorial. ",1],["AlreadyStarted","DaemonController","classes/DaemonController/AlreadyStarted.html"," < Error","",1],["ConnectError","DaemonController","classes/DaemonController/ConnectError.html"," < Error","",1],["DaemonizationTimeout","DaemonController","classes/DaemonController/DaemonizationTimeout.html"," < TimeoutError","",1],["Error","DaemonController","classes/DaemonController/Error.html"," < StandardError","",1],["LockFile","DaemonController","classes/DaemonController/LockFile.html"," < Object","A lock file is a synchronization mechanism, like a Mutex, but it also allows inter-process synchronization",1],["AlreadyLocked","DaemonController::LockFile","classes/DaemonController/LockFile/AlreadyLocked.html"," < StandardError","",1],["StartError","DaemonController","classes/DaemonController/StartError.html"," < Error","",1],["StartTimeout","DaemonController","classes/DaemonController/StartTimeout.html"," < TimeoutError","",1],["StopError","DaemonController","classes/DaemonController/StopError.html"," < Error","",1],["StopTimeout","DaemonController","classes/DaemonController/StopTimeout.html"," < TimeoutError","",1],["TimeoutError","DaemonController","classes/DaemonController/TimeoutError.html"," < Error","",1],["before_start","DaemonController","classes/DaemonController.html#M000012","()","",2],["check_pid","DaemonController","classes/DaemonController.html#M000019","(pid)","",2],["connect","DaemonController","classes/DaemonController.html#M000007","()","Connect to the daemon by running the given block, which contains the connection logic. If the daemon",2],["daemon_is_running?","DaemonController","classes/DaemonController.html#M000016","()","",2],["daemonization_timed_out","DaemonController","classes/DaemonController.html#M000027","()","This method does nothing and only serves as a hook for the unit test. ",2],["delete_pid_file","DaemonController","classes/DaemonController.html#M000018","()","",2],["determine_lock_file","DaemonController","classes/DaemonController.html#M000031","(options, identifier, pid_file)","",2],["differences_in_log_file","DaemonController","classes/DaemonController.html#M000030","()","",2],["exclusive_lock","DaemonController::LockFile","classes/DaemonController/LockFile.html#M000001","()","Obtain an exclusive lock on the lock file, yield the given block, then unlock the lockfile. If the lock",2],["fork_supported?","DaemonController","classes/DaemonController.html#M000032","()","",2],["interruptable_waitpid","DaemonController","classes/DaemonController.html#M000036","(pid)","",2],["interruptable_waitpid","DaemonController","classes/DaemonController.html#M000037","(pid)","On Ruby 1.9, Thread#kill (which is called by timeout.rb) may not be able to interrupt Process.waitpid.",2],["kill_daemon","DaemonController","classes/DaemonController.html#M000014","()","",2],["kill_daemon_with_signal","DaemonController","classes/DaemonController.html#M000015","(force = false)","",2],["log_file_has_changed?","DaemonController","classes/DaemonController.html#M000029","()","",2],["new","DaemonController","classes/DaemonController.html#M000005","(options)","Create a new DaemonController object. === Mandatory options [:identifier] A human-readable, unique name",2],["new","DaemonController::LockFile","classes/DaemonController/LockFile.html#M000000","(filename)","Create a LockFile object. The lock file is initially not locked. +filename+ may point to a nonexistant",2],["no_activity?","DaemonController","classes/DaemonController.html#M000024","(seconds)","Check whether there has been no recorded activity in the past +seconds+ seconds. ",2],["pid","DaemonController","classes/DaemonController.html#M000009","()","Returns the daemon's PID, as reported by its PID file. Returns the PID as an integer, or nil there is",2],["pid_file_available?","DaemonController","classes/DaemonController.html#M000025","()","",2],["read_pid_file","DaemonController","classes/DaemonController.html#M000017","()","",2],["record_activity","DaemonController","classes/DaemonController.html#M000023","()","",2],["run_command","DaemonController","classes/DaemonController.html#M000033","(command)","",2],["run_ping_command","DaemonController","classes/DaemonController.html#M000034","()","",2],["running?","DaemonController","classes/DaemonController.html#M000010","()","Checks whether the daemon is still running. This is done by reading the PID file and then checking whether",2],["safe_fork","DaemonController","classes/DaemonController.html#M000035","(double_fork)","",2],["save_log_file_information","DaemonController","classes/DaemonController.html#M000028","()","",2],["shared_lock","DaemonController::LockFile","classes/DaemonController/LockFile.html#M000002","()","Obtain an exclusive lock on the lock file, yield the given block, then unlock the lockfile. If the lock",2],["spawn_daemon","DaemonController","classes/DaemonController.html#M000013","()","",2],["start","DaemonController","classes/DaemonController.html#M000006","()","Start the daemon and wait until it can be pinged. Raises: - AlreadyStarted - the daemon is already running.",2],["start_timed_out","DaemonController","classes/DaemonController.html#M000026","()","This method does nothing and only serves as a hook for the unit test. ",2],["start_without_locking","DaemonController","classes/DaemonController.html#M000011","()","",2],["stop","DaemonController","classes/DaemonController.html#M000008","()","Stop the daemon and wait until it has exited. Raises: - StopError - the stop command failed. - StopTimeout",2],["try_exclusive_lock","DaemonController::LockFile","classes/DaemonController/LockFile.html#M000004","()","Try to obtain an exclusive lock on the lock file, similar to #exclusive_lock. But unlike #exclusive_lock,",2],["try_shared_lock","DaemonController::LockFile","classes/DaemonController/LockFile.html#M000003","()","Try to obtain a shared lock on the lock file, similar to #shared_lock. But unlike #shared_lock, this",2],["wait_until","DaemonController","classes/DaemonController.html#M000020","(sleep_interval = 0.1)","",2],["wait_until_daemon_responds_to_ping_or_has_exited_or_log_file_has_changed","DaemonController","classes/DaemonController.html#M000022","()","",2],["wait_until_pid_file_is_available_or_log_file_has_changed","DaemonController","classes/DaemonController.html#M000021","()","",2],["LICENSE.txt","files/LICENSE_txt.html","files/LICENSE_txt.html","","Copyright (c) 2008, 2009, 2010, 2011, 2012 Phusion  Permission is hereby granted, free of charge, to",3],["README.markdown","files/README_markdown.html","files/README_markdown.html","","Introduction ============  *daemon_controller* is a library for starting and stopping specific daemons",3],["daemon_controller.rb","files/lib/daemon_controller_rb.html","files/lib/daemon_controller_rb.html","","daemon_controller, library for robust daemon management Copyright (c) 2010, 2011, 2012 Phusion Permission",3],["lock_file.rb","files/lib/daemon_controller/lock_file_rb.html","files/lib/daemon_controller/lock_file_rb.html","","daemon_controller, library for robust daemon management Copyright (c) 2010 Phusion Permission is hereby",3],["spawn.rb","files/lib/daemon_controller/spawn_rb.html","files/lib/daemon_controller/spawn_rb.html","","daemon_controller, library for robust daemon management Copyright (c) 2010 Phusion Permission is hereby",3],["version.rb","files/lib/daemon_controller/version_rb.html","files/lib/daemon_controller/version_rb.html","","daemon_controller, library for robust daemon management Copyright (c) 2010, 2011, 2012 Phusion Permission",3]],"searchIndex":["daemoncontroller","alreadystarted","connecterror","daemonizationtimeout","error","lockfile","alreadylocked","starterror","starttimeout","stoperror","stoptimeout","timeouterror","before_start()","check_pid()","connect()","daemon_is_running?()","daemonization_timed_out()","delete_pid_file()","determine_lock_file()","differences_in_log_file()","exclusive_lock()","fork_supported?()","interruptable_waitpid()","interruptable_waitpid()","kill_daemon()","kill_daemon_with_signal()","log_file_has_changed?()","new()","new()","no_activity?()","pid()","pid_file_available?()","read_pid_file()","record_activity()","run_command()","run_ping_command()","running?()","safe_fork()","save_log_file_information()","shared_lock()","spawn_daemon()","start()","start_timed_out()","start_without_locking()","stop()","try_exclusive_lock()","try_shared_lock()","wait_until()","wait_until_daemon_responds_to_ping_or_has_exited_or_log_file_has_changed()","wait_until_pid_file_is_available_or_log_file_has_changed()","license.txt","readme.markdown","daemon_controller.rb","lock_file.rb","spawn.rb","version.rb"]}}