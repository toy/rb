var search_data = {"index":{"info":[["Cache","lib/memcache_util.rb","classes/Cache.html"," < ","A utility wrapper around the MemCache client to simplify cache access.  All methods silently ignore MemCache",1],["Continuum","lib/continuum_native.rb","classes/Continuum.html"," < ","",1],["Entry","Continuum","classes/Continuum/Entry.html"," < Object","",1],["EM","lib/memcache/event_machine.rb","classes/EM.html"," < ","",1],["SocketConnection","EM","classes/EM/SocketConnection.html"," < ","",1],["MemCache","lib/memcache/event_machine.rb","classes/MemCache.html"," < Object","A Ruby client library for memcached. ",1],["EventedServer","MemCache","classes/MemCache/EventedServer.html"," < ","Since we are working in a single Thread, multiple Fiber environment, disable the multithread Mutex as",1],["MemCacheError","MemCache","classes/MemCache/MemCacheError.html"," < RuntimeError","Base MemCache exception class. ",1],["Server","MemCache","classes/MemCache/Server.html"," < Object","This class represents a memcached server instance. ",1],["[]","MemCache","classes/MemCache.html#M000041","(key, raw = false)","Alias for #get",2],["[]=","MemCache","classes/MemCache.html#M000042","(key, value)","Shortcut to save a value in the cache.  This method does not set an expiration on the entry.  Use set",2],["active?","MemCache","classes/MemCache.html#M000023","()","Returns whether there is at least one active server for the object. ",2],["add","Cache","classes/Cache.html#M000018","(key, value, expiry = 0)","Sets +value+ in the cache at +key+, with an optional +expiry+ time in seconds.  If +key+ already exists",2],["add","MemCache","classes/MemCache.html#M000033","(key, value, expiry = 0, raw = false)","Add +key+ to the cache with value +value+ that expires in +expiry+ seconds, but only if +key+ does not",2],["alive?","MemCache::Server","classes/MemCache/Server.html#M000063","()","Check whether the server connection is alive.  This will cause the socket to attempt to connect if it",2],["append","MemCache","classes/MemCache.html#M000035","(key, value)","Append - 'add this data to an existing key after existing data' Please note the value is always passed",2],["binary_search","Continuum","classes/Continuum.html#M000068","(ary, value, &block)","Find the closest index in Continuum with value <= the given value ",2],["cache_decr","MemCache","classes/MemCache.html#M000047","(server, cache_key, amount)","Performs a raw decr for +cache_key+ from +server+.  Returns nil if not found. ",2],["cache_get","MemCache","classes/MemCache.html#M000048","(server, cache_key)","Fetches the raw data for +cache_key+ from +server+.  Returns nil on cache miss. ",2],["cache_get_multi","MemCache","classes/MemCache.html#M000050","(server, cache_keys)","Fetches +cache_keys+ from +server+ using a multi-get. ",2],["cache_incr","MemCache","classes/MemCache.html#M000051","(server, cache_key, amount)","Performs a raw incr for +cache_key+ from +server+.  Returns nil if not found. ",2],["can_read?","EM::SocketConnection","classes/EM/SocketConnection.html#M000010","(size)","",2],["cas","MemCache","classes/MemCache.html#M000032","(key, expiry=0, raw=false)","\"cas\" is a check and set operation which means \"store this data but only if no one else has updated since",2],["check_multithread_status!","MemCache","classes/MemCache.html#M000060","()","",2],["close","EM::SocketConnection","classes/EM/SocketConnection.html#M000006","()","",2],["close","MemCache::EventedServer","classes/MemCache/EventedServer.html#M000002","()","",2],["close","MemCache::Server","classes/MemCache/Server.html#M000066","()","Close the connection to the memcached server targeted by this object.  The server is not considered dead.",2],["closed?","EM::SocketConnection","classes/EM/SocketConnection.html#M000005","()","",2],["connect","EM::SocketConnection","classes/EM/SocketConnection.html#M000003","(host, port, timeout)","",2],["connect_to","MemCache::Server","classes/MemCache/Server.html#M000065","(host, port, timeout=nil)","",2],["create_continuum_for","MemCache","classes/MemCache.html#M000058","(servers)","",2],["decr","MemCache","classes/MemCache.html#M000026","(key, amount = 1)","Decrements the value for +key+ by +amount+ and returns the new value. +key+ must already exist.  If +key+",2],["delete","Cache","classes/Cache.html#M000019","(key, delay = nil)","Deletes +key+ from the cache in +delay+ seconds. ",2],["delete","MemCache","classes/MemCache.html#M000037","(key, expiry = 0)","Removes +key+ from the cache. +expiry+ is ignored as it has been removed from the latest memcached version.",2],["entry_count_for","MemCache","classes/MemCache.html#M000059","(server, total_servers, total_weight)","",2],["fetch","MemCache","classes/MemCache.html#M000028","(key, expiry = 0, raw = false)","Performs a +get+ with the given +key+.  If the value does not exist and a block was given, the block",2],["fiber_key","MemCache::EventedServer","classes/MemCache/EventedServer.html#M000000","()","",2],["flush_all","MemCache","classes/MemCache.html#M000038","(delay=0)","Flush the cache from all memcache servers. A non-zero value for +delay+ will ensure that the flush is",2],["get","Cache","classes/Cache.html#M000016","(key, expiry = 0)","Returns the object at +key+ from the cache if successful, or nil if either the object is not in the cache",2],["get","MemCache","classes/MemCache.html#M000027","(key, raw = false)","Retrieves +key+ from memcache.  If +raw+ is false, the value will be unmarshalled. ",2],["get_multi","MemCache","classes/MemCache.html#M000029","(*keys)","Retrieves multiple values from memcached in parallel, if possible. The memcached protocol supports the",2],["get_server_for_key","MemCache","classes/MemCache.html#M000046","(key, options = {})","Pick a server to handle the request based on a hash of the key. ",2],["gets","EM::SocketConnection","classes/EM/SocketConnection.html#M000009","()","",2],["gets","MemCache","classes/MemCache.html#M000049","(key, raw = false)","",2],["handle_error","MemCache","classes/MemCache.html#M000054","(server, error)","Handles +error+ from +server+. ",2],["hash_for","MemCache","classes/MemCache.html#M000045","(key)","Returns an interoperable hash value for +key+.  (I think, docs are sketchy for down servers). ",2],["incr","MemCache","classes/MemCache.html#M000030","(key, amount = 1)","Increments the value for +key+ by +amount+ and returns the new value. +key+ must already exist.  If +key+",2],["inspect","Continuum::Entry","classes/Continuum/Entry.html#M000070","()","",2],["inspect","MemCache","classes/MemCache.html#M000022","()","Returns a string representation of the cache object. ",2],["inspect","MemCache::Server","classes/MemCache/Server.html#M000062","()","Return a string representation of the server object. ",2],["key_length","MemCache","classes/MemCache.html#M000044","(key)","Calculate length of the key, including the namespace and namespace-separator. ",2],["logger","Cache","classes/Cache.html#M000015","()","Try to return a logger object that does not rely on ActiveRecord for logging. ",2],["make_cache_key","MemCache","classes/MemCache.html#M000043","(key)","Create a key for the cache, incorporating the namespace qualifier if requested. ",2],["mark_dead","MemCache::Server","classes/MemCache/Server.html#M000067","(error)","Mark the server as dead and close its socket. ",2],["new","Continuum::Entry","classes/Continuum/Entry.html#M000069","(val, srv)","",2],["new","EM::SocketConnection","classes/EM/SocketConnection.html#M000004","()","",2],["new","MemCache","classes/MemCache.html#M000021","(*args)","Accepts a list of +servers+ and a list of +opts+.  +servers+ may be omitted.  See +servers=+ for acceptable",2],["new","MemCache::Server","classes/MemCache/Server.html#M000061","(memcache, host, port = DEFAULT_PORT, weight = DEFAULT_WEIGHT)","Create a new MemCache::Server object for the memcached instance listening on the given host and port,",2],["noreply","MemCache","classes/MemCache.html#M000055","()","",2],["post_init","EM::SocketConnection","classes/EM/SocketConnection.html#M000012","()","",2],["prepend","MemCache","classes/MemCache.html#M000036","(key, value)","Prepend - 'add this data to an existing key before existing data' Please note the value is always passed",2],["put","Cache","classes/Cache.html#M000017","(key, value, expiry = 0)","Sets +value+ in the cache at +key+, with an optional +expiry+ time in seconds. ",2],["raise_on_error_response!","MemCache","classes/MemCache.html#M000057","(response)","",2],["read","EM::SocketConnection","classes/EM/SocketConnection.html#M000008","(size)","",2],["readonly?","MemCache","classes/MemCache.html#M000024","()","Returns whether or not the cache object was created read only. ",2],["receive_data","EM::SocketConnection","classes/EM/SocketConnection.html#M000011","(data)","EM callbacks ",2],["replace","MemCache","classes/MemCache.html#M000034","(key, value, expiry = 0, raw = false)","Add +key+ to the cache with value +value+ that expires in +expiry+ seconds, but only if +key+ already",2],["request_setup","MemCache","classes/MemCache.html#M000056","(key)","Performs setup for making a request with +key+ from memcached.  Returns the server to fetch the key from",2],["reset","Cache","classes/Cache.html#M000020","()","Resets all connections to MemCache servers. ",2],["reset","MemCache","classes/MemCache.html#M000039","()","Reset the connection to all memcache servers.  This should be called if there is a problem with a cache",2],["servers=","MemCache","classes/MemCache.html#M000025","(servers)","Set the servers that the requests will be distributed between.  Entries can be either strings of the",2],["set","MemCache","classes/MemCache.html#M000031","(key, value, expiry = 0, raw = false)","",2],["socket","MemCache::EventedServer","classes/MemCache/EventedServer.html#M000001","()","",2],["socket","MemCache::Server","classes/MemCache/Server.html#M000064","()","Try to connect to the memcached server targeted by this object. Returns the connected socket object on",2],["stats","MemCache","classes/MemCache.html#M000040","()","Returns statistics for each memcached server.  An explanation of the statistics can be found in the memcached",2],["unbind","EM::SocketConnection","classes/EM/SocketConnection.html#M000013","()","",2],["with_server","MemCache","classes/MemCache.html#M000053","(key)","",2],["with_socket_management","MemCache","classes/MemCache.html#M000052","(server, &block)","Gets or creates a socket connected to the given server, and yields it to the block, wrapped in a mutex",2],["write","EM::SocketConnection","classes/EM/SocketConnection.html#M000007","(buf)","",2],["yank","EM::SocketConnection","classes/EM/SocketConnection.html#M000014","(len)","",2],["FAQ.rdoc","files/FAQ_rdoc.html","files/FAQ_rdoc.html","","= Memcache-client FAQ  == Does memcache-client work with Ruby 1.9?  Yes, Ruby 1.9 is supported.  The",3],["History.rdoc","files/History_rdoc.html","files/History_rdoc.html","","= 1.8.5 (2010-07-05)   * Fix bad release  = 1.8.4 (2010-07-02)   * Fix unfibered usage of memcache-client",3],["LICENSE.txt","files/LICENSE_txt.html","files/LICENSE_txt.html","","Copyright 2005-2009 Bob Cottrell, Eric Hodel, Mike Perham. All rights reserved.  Redistribution and use",3],["README.rdoc","files/README_rdoc.html","files/README_rdoc.html","","= memcache-client  A ruby library for accessing memcached.  Source:  http://github.com/mperham/memcache-client",3],["continuum_native.rb","files/lib/continuum_native_rb.html","files/lib/continuum_native_rb.html","","",3],["memcache.rb","files/lib/memcache_rb.html","files/lib/memcache_rb.html","","encoding: utf-8 ",3],["event_machine.rb","files/lib/memcache/event_machine_rb.html","files/lib/memcache/event_machine_rb.html","","Extensions for using memcache-client with EventMachine ",3],["version.rb","files/lib/memcache/version_rb.html","files/lib/memcache/version_rb.html","","",3],["memcache_util.rb","files/lib/memcache_util_rb.html","files/lib/memcache_util_rb.html","","A utility wrapper around the MemCache client to simplify cache access.  All methods silently ignore MemCache",3]],"searchIndex":["cache","continuum","entry","em","socketconnection","memcache","eventedserver","memcacheerror","server","[]()","[]=()","active?()","add()","add()","alive?()","append()","binary_search()","cache_decr()","cache_get()","cache_get_multi()","cache_incr()","can_read?()","cas()","check_multithread_status!()","close()","close()","close()","closed?()","connect()","connect_to()","create_continuum_for()","decr()","delete()","delete()","entry_count_for()","fetch()","fiber_key()","flush_all()","get()","get()","get_multi()","get_server_for_key()","gets()","gets()","handle_error()","hash_for()","incr()","inspect()","inspect()","inspect()","key_length()","logger()","make_cache_key()","mark_dead()","new()","new()","new()","new()","noreply()","post_init()","prepend()","put()","raise_on_error_response!()","read()","readonly?()","receive_data()","replace()","request_setup()","reset()","reset()","servers=()","set()","socket()","socket()","stats()","unbind()","with_server()","with_socket_management()","write()","yank()","faq.rdoc","history.rdoc","license.txt","readme.rdoc","continuum_native.rb","memcache.rb","event_machine.rb","version.rb","memcache_util.rb"],"longSearchIndex":["lib/memcache_util.rb","lib/memcache.rb","continuum","lib/memcache/event_machine.rb","em","lib/memcache.rb","memcache","memcache","memcache","memcache","memcache","memcache","cache","memcache","memcache::server","memcache","continuum","memcache","memcache","memcache","memcache","em::socketconnection","memcache","memcache","em::socketconnection","memcache::eventedserver","memcache::server","em::socketconnection","em::socketconnection","memcache::server","memcache","memcache","cache","memcache","memcache","memcache","memcache::eventedserver","memcache","cache","memcache","memcache","memcache","em::socketconnection","memcache","memcache","memcache","memcache","continuum::entry","memcache","memcache::server","memcache","cache","memcache","memcache::server","continuum::entry","em::socketconnection","memcache","memcache::server","memcache","em::socketconnection","memcache","cache","memcache","em::socketconnection","memcache","em::socketconnection","memcache","memcache","cache","memcache","memcache","memcache","memcache::eventedserver","memcache::server","memcache","em::socketconnection","memcache","memcache","em::socketconnection","em::socketconnection","files/faq_rdoc.html","files/history_rdoc.html","files/license_txt.html","files/readme_rdoc.html","files/lib/continuum_native_rb.html","files/lib/memcache_rb.html","files/lib/memcache/event_machine_rb.html","files/lib/memcache/version_rb.html","files/lib/memcache_util_rb.html"]}}