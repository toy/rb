var search_data = {"index":{"longSearchIndex":["lib/composite_sexp_processor.rb","lib/pt_testcase.rb","lib/sexp_processor.rb","lib/sexp_processor.rb","lib/pt_testcase.rb","lib/sexp.rb","lib/sexp.rb","lib/sexp.rb","lib/sexp.rb","lib/sexp_processor.rb","sexpprocessor","lib/sexp_processor.rb","lib/sexp_processor.rb","lib/unique.rb","lib/sexp_processor.rb","lib/sexp_processor.rb","compositesexpprocessor","sexpany","sexp","sexpany","sexp","sexpmatchspecials","sexpprocessor::environment","sexpprocessor::environment","examples","parsetreetestcase","parsetreetestcase","parsetreetestcase","parsetreetestcase","parsetreetestcase","sexpprocessor::environment","examples","sexp","sexpprocessor","sexpprocessor","parsetreetestcase","parsetreetestcase","parsetreetestcase","object","sexpprocessor::environment","sexp","sexp","sexp","sexp","sexp","parsetreetestcase","parsetreetestcase","sexp","sexpprocessor","parsetreetestcase","sexpany","parsetreetestcase","sexp","sexp","sexp","sexp","sexpprocessor","sexpprocessor::environment","unique","compositesexpprocessor","sexpprocessor","parsetreetestcase","compositesexpprocessor","sexpprocessor","sexpprocessor","unique","sexpprocessor","object","sexpprocessor","sexpprocessor::environment","parsetreetestcase","sexp","sexp","sexp","sexp","sexp","parsetreetestcase","parsetreetestcase","parsetreetestcase","files/history_txt.html","files/manifest_txt.html","files/readme_txt.html","files/lib/composite_sexp_processor_rb.html","files/lib/pt_testcase_rb.html","files/lib/sexp_rb.html","files/lib/sexp_processor_rb.html","files/lib/unique_rb.html"],"info":[["CompositeSexpProcessor","lib/composite_sexp_processor.rb","classes/CompositeSexpProcessor.html"," < SexpProcessor","Implements the Composite pattern on SexpProcessor. Need we say more? Yeah... probably. Implements a SexpProcessor",1],["Examples","lib/pt_testcase.rb","classes/Examples.html"," < Object","TODO: <ko1_> 1.8.7 support {|&b|} syntax ",1],["NotEmptyError","lib/sexp_processor.rb","classes/NotEmptyError.html"," < SexpProcessorError","Raised by SexpProcessor if a processor did not process every node in a sexp and @require_empty is true.",1],["Object","lib/sexp_processor.rb","classes/Object.html"," < Object","",1],["ParseTreeTestCase","lib/pt_testcase.rb","classes/ParseTreeTestCase.html"," < MiniTest::Unit::TestCase","",1],["Sexp","lib/sexp.rb","classes/Sexp.html"," < Array","Sexps are the basic storage mechanism of SexpProcessor.  Sexps have a +type+ (to be renamed +node_type+)",1],["SexpAny","lib/sexp.rb","classes/SexpAny.html"," < SexpMatchSpecial","",1],["SexpMatchSpecial","lib/sexp.rb","classes/SexpMatchSpecial.html"," < Sexp","",1],["SexpMatchSpecials","lib/sexp.rb","classes/SexpMatchSpecials.html"," < ","",1],["SexpProcessor","lib/sexp_processor.rb","classes/SexpProcessor.html"," < Object","SexpProcessor provides a uniform interface to process Sexps. In order to create your own SexpProcessor",1],["Environment","SexpProcessor","classes/SexpProcessor/Environment.html"," < Object","I really hate this here, but I hate subdirs in my lib dir more... I guess it is kinda like shaving...",1],["SexpProcessorError","lib/sexp_processor.rb","classes/SexpProcessorError.html"," < StandardError","SexpProcessor base exception class. ",1],["SexpTypeError","lib/sexp_processor.rb","classes/SexpTypeError.html"," < SexpProcessorError","Raised if assert_type encounters an unexpected sexp type. ",1],["Unique","lib/unique.rb","classes/Unique.html"," < Object","Unique creates unique variable names. ",1],["UnknownNodeError","lib/sexp_processor.rb","classes/UnknownNodeError.html"," < SexpProcessorError","Raised by SexpProcessor if it is in strict mode and sees a node for which there is no processor available.",1],["UnsupportedNodeError","lib/sexp_processor.rb","classes/UnsupportedNodeError.html"," < SexpProcessorError","Raised by SexpProcessor if it sees a node type listed in its unsupported list. ",1],["<<","CompositeSexpProcessor","classes/CompositeSexpProcessor.html#M000001","(processor)","Add a +processor+ to the list of processors to run. ",2],["==","SexpAny","classes/SexpAny.html#M000028","(o)","",2],["===","Sexp","classes/Sexp.html#M000007","(sexp)","Returns true if this Sexp's pattern matches +sexp+. ",2],["===","SexpAny","classes/SexpAny.html#M000029","(o)","",2],["=~","Sexp","classes/Sexp.html#M000008","(pattern)","Returns true if this Sexp matches +pattern+.  (Opposite of #===.) ",2],["ANY","SexpMatchSpecials","classes/SexpMatchSpecials.html#M000031","()","",2],["[]","SexpProcessor::Environment","classes/SexpProcessor/Environment.html#M000046","(name)","TODO: depth_of ",2],["[]=","SexpProcessor::Environment","classes/SexpProcessor/Environment.html#M000047","(name, val)","",2],["a_method","Examples","classes/Examples.html#M000052","(x)","",2],["add_18tests","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000059","(name, hash)","",2],["add_19tests","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000060","(name, hash)","",2],["add_test","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000057","(name, data, klass = self.name[4..-1])","",2],["add_tests","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000058","(name, hash)","",2],["after_process_hook","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000055","(klass, node, data, input_name, output_name)","",2],["all","SexpProcessor::Environment","classes/SexpProcessor/Environment.html#M000044","()","",2],["an_alias","Examples","classes/Examples.html#M000053","(x)","Alias for #a_method",2],["array_type?","Sexp","classes/Sexp.html#M000009","()","Returns true if the node_type is +array+ or +args+. REFACTOR: to TypedSexp - we only care when we have",2],["assert_empty","SexpProcessor","classes/SexpProcessor.html#M000034","(meth, exp, exp_orig)","",2],["assert_type","SexpProcessor","classes/SexpProcessor.html#M000037","(list, typ)","Raises unless the Sexp type for +list+ matches +typ+ ",2],["before_process_hook","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000056","(klass, node, data, input_name, output_name)","",2],["clone_same","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000061","()","",2],["copy_test_case","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000062","(nonverbose, klass)","",2],["deep_clone","Object","classes/Object.html#M000049","()","deep_clone is the usual Marshalling hack to make a deep copy. It is rather slow, so use it sparingly.",2],["depth","SexpProcessor::Environment","classes/SexpProcessor/Environment.html#M000045","()","",2],["each_of_type","Sexp","classes/Sexp.html#M000011","(t, &b)","Enumeratates the sexp yielding to +b+ when the node_type == +t+. ",2],["find_and_replace_all","Sexp","classes/Sexp.html#M000012","(from, to)","Replaces all elements whose node_type is +from+ with +to+. Used only for the most trivial of rewrites.",2],["find_node","Sexp","classes/Sexp.html#M000015","(name, delete = false)","",2],["find_nodes","Sexp","classes/Sexp.html#M000016","(name)","Find every node with type +name+. ",2],["from_array","Sexp","classes/Sexp.html#M000005","(a)","Creates a new Sexp from Array +a+. ",2],["generate_test","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000063","(klass, node, data, input_name, output_name)","",2],["generate_tests","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000064","(klass)","",2],["gsub","Sexp","classes/Sexp.html#M000013","(pattern, repl)","Replaces all Sexps matching +pattern+ with Sexp +repl+. ",2],["in_context","SexpProcessor","classes/SexpProcessor.html#M000042","(type)","",2],["inherited","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000065","(klass)","",2],["inspect","SexpAny","classes/SexpAny.html#M000030","()","",2],["install_missing_reporter","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000066","()","",2],["line","Sexp","classes/Sexp.html#M000017","(n=nil)","If passed a line number, sets the line and returns self. Otherwise returns the line number. This allows",2],["mass","Sexp","classes/Sexp.html#M000018","()","Returns the size of the sexp, flattened. ",2],["method_missing","Sexp","classes/Sexp.html#M000019","(meth, delete = false)","Returns the node named +node+, deleting it if +delete+ is true. ",2],["new","Sexp","classes/Sexp.html#M000004","(*args)","Create a new Sexp containing +args+. ",2],["new","SexpProcessor","classes/SexpProcessor.html#M000033","()","Creates a new SexpProcessor.  Use super to invoke this initializer from SexpProcessor subclasses, then",2],["new","SexpProcessor::Environment","classes/SexpProcessor/Environment.html#M000043","()","",2],["next","Unique","classes/Unique.html#M000051","()","",2],["on_error_in","CompositeSexpProcessor","classes/CompositeSexpProcessor.html#M000003","(node_type, &block)","",2],["on_error_in","SexpProcessor","classes/SexpProcessor.html#M000039","(node_type, &block)","Registers an error handler for +node+ ",2],["previous","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000067","(key, extra=0)","",2],["process","CompositeSexpProcessor","classes/CompositeSexpProcessor.html#M000002","(exp)","Run +exp+ through all of the processors, returning the final result. ",2],["process","SexpProcessor","classes/SexpProcessor.html#M000036","(exp)","Default Sexp processor.  Invokes process_<type> methods matching the Sexp type given.  Performs additional",2],["process_dummy","SexpProcessor","classes/SexpProcessor.html#M000040","(exp)","A fairly generic processor for a dummy node. Dummy nodes are used when your processor is doing a complicated",2],["reset","Unique","classes/Unique.html#M000050","()","",2],["rewrite","SexpProcessor","classes/SexpProcessor.html#M000035","(exp)","",2],["s","Object","classes/Object.html#M000032","(*args)","This is just a stupid shortcut to make indentation much cleaner. ",2],["scope","SexpProcessor","classes/SexpProcessor.html#M000041","(&block)","Add a scope level to the current env. Eg: def process_defn exp name = exp.shift args = process(exp.shift)",2],["scope","SexpProcessor::Environment","classes/SexpProcessor/Environment.html#M000048","()","",2],["setup","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000054","()","",2],["sexp_body","Sexp","classes/Sexp.html#M000022","()","Returns the Sexp body, ie the values without the node type. ",2],["sexp_type","Sexp","classes/Sexp.html#M000021","()","Returns the node type of the Sexp. ",2],["shift","Sexp","classes/Sexp.html#M000023","()","If run with debug, Sexp will raise if you shift on an empty Sexp. Helps with debugging. ",2],["structure","Sexp","classes/Sexp.html#M000024","()","Returns the bare bones structure of the sexp. s(:a, :b, s(:c, :d), :e) => s(:a, s(:c)) ",2],["sub","Sexp","classes/Sexp.html#M000025","(pattern, repl)","Replaces the Sexp matching +pattern+ with +repl+. ",2],["testcase_order","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000068","()","",2],["testcases","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000069","()","",2],["unsupported_tests","ParseTreeTestCase","classes/ParseTreeTestCase.html#M000070","(*tests)","",2],["History.txt","files/History_txt.html","files/History_txt.html","","=== 3.0.10 / 2012-01-04  * 1 minor enhancement:    * Add test for bare hash at end of array in 1.9. (presidentbeef)",3],["Manifest.txt","files/Manifest_txt.html","files/Manifest_txt.html","","History.txt Manifest.txt README.txt Rakefile lib/composite_sexp_processor.rb lib/pt_testcase.rb lib/sexp.rb",3],["README.txt","files/README_txt.html","files/README_txt.html","","= SexpProcessor  home :: https://github.com/seattlerb/sexp_processor rdoc :: http://parsetree.rubyforge.org/sexp_processor",3],["composite_sexp_processor.rb","files/lib/composite_sexp_processor_rb.html","files/lib/composite_sexp_processor_rb.html","","",3],["pt_testcase.rb","files/lib/pt_testcase_rb.html","files/lib/pt_testcase_rb.html","","",3],["sexp.rb","files/lib/sexp_rb.html","files/lib/sexp_rb.html","","",3],["sexp_processor.rb","files/lib/sexp_processor_rb.html","files/lib/sexp_processor_rb.html","","",3],["unique.rb","files/lib/unique_rb.html","files/lib/unique_rb.html","","Unique creates unique variable names. ",3]],"searchIndex":["compositesexpprocessor","examples","notemptyerror","object","parsetreetestcase","sexp","sexpany","sexpmatchspecial","sexpmatchspecials","sexpprocessor","environment","sexpprocessorerror","sexptypeerror","unique","unknownnodeerror","unsupportednodeerror","<<()","==()","===()","===()","=~()","any()","[]()","[]=()","a_method()","add_18tests()","add_19tests()","add_test()","add_tests()","after_process_hook()","all()","an_alias()","array_type?()","assert_empty()","assert_type()","before_process_hook()","clone_same()","copy_test_case()","deep_clone()","depth()","each_of_type()","find_and_replace_all()","find_node()","find_nodes()","from_array()","generate_test()","generate_tests()","gsub()","in_context()","inherited()","inspect()","install_missing_reporter()","line()","mass()","method_missing()","new()","new()","new()","next()","on_error_in()","on_error_in()","previous()","process()","process()","process_dummy()","reset()","rewrite()","s()","scope()","scope()","setup()","sexp_body()","sexp_type()","shift()","structure()","sub()","testcase_order()","testcases()","unsupported_tests()","history.txt","manifest.txt","readme.txt","composite_sexp_processor.rb","pt_testcase.rb","sexp.rb","sexp_processor.rb","unique.rb"]}}