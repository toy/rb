var search_data = {"index":{"info":[["HMAC","lib/hmac/hmac.rb","classes/HMAC.html"," < ","This module provides common interface to HMAC engines. HMAC standard is documented in RFC 2104: H. Krawczyk",1],["Base","HMAC","classes/HMAC/Base.html"," < Object","",1],["SHA1","HMAC","classes/HMAC/SHA1.html"," < Base","",1],["SHA256","HMAC","classes/HMAC/SHA256.html"," < Base","",1],["SHA384","HMAC","classes/HMAC/SHA384.html"," < Base","",1],["SHA512","HMAC","classes/HMAC/SHA512.html"," < Base","",1],["HTMLComment","lib/openid/yadis/htmltokenizer.rb","classes/HTMLComment.html"," < HTMLToken","Class representing an HTML comment ",1],["HTMLTag","lib/openid/yadis/htmltokenizer.rb","classes/HTMLTag.html"," < HTMLToken","Class representing an HTML tag ",1],["HTMLText","lib/openid/yadis/htmltokenizer.rb","classes/HTMLText.html"," < HTMLToken","Class representing text that isn't inside a tag ",1],["HTMLToken","lib/openid/yadis/htmltokenizer.rb","classes/HTMLToken.html"," < Object","The parent class for all three types of HTML tokens ",1],["HTMLTokenizer","lib/openid/yadis/htmltokenizer.rb","classes/HTMLTokenizer.html"," < Object","A class to tokenize HTML. Example: page = \"<HTML> <HEAD> <TITLE>This is the title</TITLE> </HEAD> <!--",1],["HTMLTokenizerError","lib/openid/yadis/htmltokenizer.rb","classes/HTMLTokenizerError.html"," < Exception","",1],["Net","lib/openid/fetchers.rb","classes/Net.html"," < ","",1],["HTTP","Net","classes/Net/HTTP.html"," < Object","",1],["OpenID","lib/openid/association.rb","classes/OpenID.html"," < ","See OpenID::Consumer or OpenID::Server modules, as well as the store classes --- --- Copyright 2006-2007",1],["AX","OpenID","classes/OpenID/AX.html"," < ","",1],["AXMessage","OpenID::AX","classes/OpenID/AX/AXMessage.html"," < Extension","Abstract class containing common code for attribute exchange messages ",1],["AttrInfo","OpenID::AX","classes/OpenID/AX/AttrInfo.html"," < Object","Represents a single attribute in an attribute exchange request. This should be added to an Request object",1],["Error","OpenID::AX","classes/OpenID/AX/Error.html"," < ArgumentError","Raised when data does not comply with AX 1.0 specification ",1],["FetchRequest","OpenID::AX","classes/OpenID/AX/FetchRequest.html"," < AXMessage","An attribute exchange 'fetch_request' message. This message is sent by a relying party when it wishes",1],["FetchResponse","OpenID::AX","classes/OpenID/AX/FetchResponse.html"," < KeyValueMessage","A fetch_response attribute exchange message ",1],["KeyValueMessage","OpenID::AX","classes/OpenID/AX/KeyValueMessage.html"," < AXMessage","Abstract class that implements a message that has attribute keys and values. It contains the common code",1],["StoreRequest","OpenID::AX","classes/OpenID/AX/StoreRequest.html"," < KeyValueMessage","A store request attribute exchange message representation ",1],["StoreResponse","OpenID::AX","classes/OpenID/AX/StoreResponse.html"," < AXMessage","An indication that the store request was processed along with this OpenID transaction. ",1],["AssertionError","OpenID","classes/OpenID/AssertionError.html"," < Exception","",1],["Association","OpenID","classes/OpenID/Association.html"," < Object","An Association holds the shared secret between a relying party and an OpenID provider. ",1],["AssociationNegotiator","OpenID","classes/OpenID/AssociationNegotiator.html"," < Object","",1],["Consumer","OpenID","classes/OpenID/Consumer.html"," < Object","OpenID support for Relying Parties (aka Consumers). This module documents the main interface with the",1],["AssociationManager","OpenID::Consumer","classes/OpenID/Consumer/AssociationManager.html"," < Object","An object that manages creating and storing associations for an OpenID provider endpoint ",1],["CancelResponse","OpenID::Consumer","classes/OpenID/Consumer/CancelResponse.html"," < Object","",1],["CheckIDRequest","OpenID::Consumer","classes/OpenID/Consumer/CheckIDRequest.html"," < Object","An object that holds the state necessary for generating an OpenID authentication request. This object",1],["DiffieHellmanSHA1Session","OpenID::Consumer","classes/OpenID/Consumer/DiffieHellmanSHA1Session.html"," < DiffieHellmanSession","A Diffie-Hellman association session that uses SHA1 as its hash function ",1],["DiffieHellmanSHA256Session","OpenID::Consumer","classes/OpenID/Consumer/DiffieHellmanSHA256Session.html"," < DiffieHellmanSession","A Diffie-Hellman association session that uses SHA256 as its hash function ",1],["DiffieHellmanSession","OpenID::Consumer","classes/OpenID/Consumer/DiffieHellmanSession.html"," < Object","A superclass for implementing Diffie-Hellman association sessions. ",1],["DiscoveredServices","OpenID::Consumer","classes/OpenID/Consumer/DiscoveredServices.html"," < Object","A set of discovered services, for tracking which providers have been attempted for an OpenID identifier",1],["DiscoveryManager","OpenID::Consumer","classes/OpenID/Consumer/DiscoveryManager.html"," < Object","Manages calling discovery and tracking which endpoints have already been attempted. ",1],["FailureResponse","OpenID::Consumer","classes/OpenID/Consumer/FailureResponse.html"," < Object","",1],["IdResHandler","OpenID::Consumer","classes/OpenID/Consumer/IdResHandler.html"," < Object","Handles an openid.mode=id_res response. This object is instantiated and used by the Consumer. ",1],["NoEncryptionSession","OpenID::Consumer","classes/OpenID/Consumer/NoEncryptionSession.html"," < Object","An association session that does not use encryption ",1],["Response","OpenID::Consumer","classes/OpenID/Consumer/Response.html"," < ","",1],["SetupNeededResponse","OpenID::Consumer","classes/OpenID/Consumer/SetupNeededResponse.html"," < Object","",1],["SuccessResponse","OpenID::Consumer","classes/OpenID/Consumer/SuccessResponse.html"," < Object","A successful acknowledgement from the OpenID server that the supplied URL is, indeed controlled by the",1],["CryptUtil","OpenID","classes/OpenID/CryptUtil.html"," < ","This module contains everything needed to perform low-level cryptograph and data manipulation tasks.",1],["DiffieHellman","OpenID","classes/OpenID/DiffieHellman.html"," < Object","Encapsulates a Diffie-Hellman key exchange.  This class is used internally by both the consumer and server",1],["DiscoveryFailure","OpenID","classes/OpenID/DiscoveryFailure.html"," < OpenIDError","Raised when a error occurs in the discovery process ",1],["Extension","OpenID","classes/OpenID/Extension.html"," < Object","An interface for OpenID extensions. ",1],["FetchingError","OpenID","classes/OpenID/FetchingError.html"," < OpenIDError","",1],["HTTPRedirectLimitReached","OpenID","classes/OpenID/HTTPRedirectLimitReached.html"," < FetchingError","",1],["HTTPResponse","OpenID","classes/OpenID/HTTPResponse.html"," < Object","Our HTTPResponse class extends Net::HTTPResponse with an additional method, final_url. ",1],["HTTPStatusError","OpenID","classes/OpenID/HTTPStatusError.html"," < OpenIDError","",1],["InvalidOpenIDNamespace","OpenID","classes/OpenID/InvalidOpenIDNamespace.html"," < Exception","Raised if openid.ns is not a recognized value. See Message class variable @@allowed_openid_namespaces",1],["KVFormError","OpenID","classes/OpenID/KVFormError.html"," < Exception","",1],["KVPostNetworkError","OpenID","classes/OpenID/KVPostNetworkError.html"," < OpenIDError","",1],["Message","OpenID","classes/OpenID/Message.html"," < Object","",1],["KeyNotFound","OpenID::Message","classes/OpenID/Message/KeyNotFound.html"," < IndexError","Raised when key lookup fails ",1],["NamespaceAliasRegistrationError","OpenID","classes/OpenID/NamespaceAliasRegistrationError.html"," < Exception","Raised when an alias or namespace URI has already been registered. ",1],["NamespaceMap","OpenID","classes/OpenID/NamespaceMap.html"," < Object","Maintains a bidirectional map between namespace URIs and aliases. ",1],["Nonce","OpenID","classes/OpenID/Nonce.html"," < ","",1],["OAuth","OpenID","classes/OpenID/OAuth.html"," < ","",1],["Request","OpenID::OAuth","classes/OpenID/OAuth/Request.html"," < Extension","An OAuth token request, sent from a relying party to a provider ",1],["Response","OpenID::OAuth","classes/OpenID/OAuth/Response.html"," < Extension","A OAuth request token response, sent from a provider to a relying party ",1],["OpenIDError","OpenID","classes/OpenID/OpenIDError.html"," < StandardError","Exceptions that are raised by the library are subclasses of this exception type, so if you want to catch",1],["OpenIDServiceEndpoint","OpenID","classes/OpenID/OpenIDServiceEndpoint.html"," < Object","Object representing an OpenID service endpoint. ",1],["PAPE","OpenID","classes/OpenID/PAPE.html"," < ","",1],["Request","OpenID::PAPE","classes/OpenID/PAPE/Request.html"," < Extension","A Provider Authentication Policy request, sent from a relying party to a provider ",1],["Response","OpenID::PAPE","classes/OpenID/PAPE/Response.html"," < Extension","A Provider Authentication Policy response, sent from a provider to a relying party ",1],["ProtocolError","OpenID","classes/OpenID/ProtocolError.html"," < OpenIDError","An error in the OpenID protocol ",1],["RealmVerificationRedirected","OpenID","classes/OpenID/RealmVerificationRedirected.html"," < Exception","",1],["SReg","OpenID","classes/OpenID/SReg.html"," < ","",1],["NamespaceError","OpenID::SReg","classes/OpenID/SReg/NamespaceError.html"," < ArgumentError","The simple registration namespace was not found and could not be created using the expected name (there's",1],["Request","OpenID::SReg","classes/OpenID/SReg/Request.html"," < Extension","An object to hold the state of a simple registration request. ",1],["Response","OpenID::SReg","classes/OpenID/SReg/Response.html"," < Extension","Represents the data returned in a simple registration response inside of an OpenID id_res response. This",1],["SSLFetchingError","OpenID","classes/OpenID/SSLFetchingError.html"," < FetchingError","",1],["Server","OpenID","classes/OpenID/Server.html"," < ","",1],["AlreadySigned","OpenID::Server","classes/OpenID/Server/AlreadySigned.html"," < EncodingError","This response is already signed. ",1],["AssociateRequest","OpenID::Server","classes/OpenID/Server/AssociateRequest.html"," < OpenIDRequest","A request to establish an association. See OpenID Specs, Section 8: Establishing Associations <http://openid.net/specs/openid-authentication-2_0-12.html#associations>",1],["BaseServerSession","OpenID::Server","classes/OpenID/Server/BaseServerSession.html"," < Object","",1],["CheckAuthRequest","OpenID::Server","classes/OpenID/Server/CheckAuthRequest.html"," < OpenIDRequest","A request to verify the validity of a previous response. See OpenID Specs, Verifying Directly with the",1],["CheckIDRequest","OpenID::Server","classes/OpenID/Server/CheckIDRequest.html"," < OpenIDRequest","A request to confirm the identity of a user. This class handles requests for openid modes +checkid_immediate+",1],["Decoder","OpenID::Server","classes/OpenID/Server/Decoder.html"," < Object","I decode an incoming web request in to a OpenIDRequest. ",1],["DiffieHellmanSHA1ServerSession","OpenID::Server","classes/OpenID/Server/DiffieHellmanSHA1ServerSession.html"," < BaseServerSession","An object that knows how to handle association requests with the Diffie-Hellman session type. See OpenID",1],["DiffieHellmanSHA256ServerSession","OpenID::Server","classes/OpenID/Server/DiffieHellmanSHA256ServerSession.html"," < DiffieHellmanSHA1ServerSession","",1],["Encoder","OpenID::Server","classes/OpenID/Server/Encoder.html"," < Object","I encode responses in to WebResponses. If you don't like WebResponses, you can do your own handling of",1],["EncodingError","OpenID::Server","classes/OpenID/Server/EncodingError.html"," < Exception","Could not encode this as a protocol message. You should probably render it and show it to the user. ",1],["MalformedReturnURL","OpenID::Server","classes/OpenID/Server/MalformedReturnURL.html"," < ProtocolError","The return_to URL doesn't look like a valid URL. ",1],["MalformedTrustRoot","OpenID::Server","classes/OpenID/Server/MalformedTrustRoot.html"," < ProtocolError","The trust root is not well-formed. ",1],["NoReturnToError","OpenID::Server","classes/OpenID/Server/NoReturnToError.html"," < Exception","Raised when a response to a request cannot be generated because the request contains no return_to URL.",1],["OpenIDRequest","OpenID::Server","classes/OpenID/Server/OpenIDRequest.html"," < Object","",1],["OpenIDResponse","OpenID::Server","classes/OpenID/Server/OpenIDResponse.html"," < Object","I am a response to an OpenID request. Attributes: signed:: A list of the names of the fields which should",1],["PlainTextServerSession","OpenID::Server","classes/OpenID/Server/PlainTextServerSession.html"," < BaseServerSession","An object that knows how to handle association requests with no session type. See OpenID Specs, Section",1],["ProtocolError","OpenID::Server","classes/OpenID/Server/ProtocolError.html"," < Exception","A message did not conform to the OpenID protocol. ",1],["Server","OpenID::Server","classes/OpenID/Server/Server.html"," < Object","I handle requests for an OpenID server. Some types of requests (those which are not checkid requests)",1],["Signatory","OpenID::Server","classes/OpenID/Server/Signatory.html"," < Object","I sign things. I also check signatures. All my state is encapsulated in a store, which means I'm not",1],["SigningEncoder","OpenID::Server","classes/OpenID/Server/SigningEncoder.html"," < Encoder","I encode responses in to WebResponses, signing them when required. ",1],["UntrustedReturnURL","OpenID::Server","classes/OpenID/Server/UntrustedReturnURL.html"," < ProtocolError","A return_to is outside the trust_root. ",1],["VersionError","OpenID::Server","classes/OpenID/Server/VersionError.html"," < Exception","Raised when an operation was attempted that is not compatible with the protocol version being used. ",1],["WebResponse","OpenID::Server","classes/OpenID/Server/WebResponse.html"," < Object","I am a response to an OpenID request in terms a web server understands. I generally come from an #Encoder,",1],["ServerError","OpenID","classes/OpenID/ServerError.html"," < OpenIDError","Exception that is raised when the server returns a 400 response code to a direct request. ",1],["StandardFetcher","OpenID","classes/OpenID/StandardFetcher.html"," < Object","",1],["Store","OpenID","classes/OpenID/Store.html"," < ","Stores for Associations and nonces. Used by both the Consumer and the Server. If you have a database",1],["Filesystem","OpenID::Store","classes/OpenID/Store/Filesystem.html"," < Interface","",1],["Interface","OpenID::Store","classes/OpenID/Store/Interface.html"," < Object","Abstract Store Changes in 2.0: * removed store_nonce, get_auth_key, is_dumb * changed use_nonce to support",1],["Memcache","OpenID::Store","classes/OpenID/Store/Memcache.html"," < Interface","",1],["Memory","OpenID::Store","classes/OpenID/Store/Memory.html"," < Interface","An in-memory implementation of Store.  This class is mainly used for testing, though it may be useful",1],["TrustRoot","OpenID","classes/OpenID/TrustRoot.html"," < ","",1],["TrustRoot","OpenID::TrustRoot","classes/OpenID/TrustRoot/TrustRoot.html"," < Object","",1],["TypeURIMismatch","OpenID","classes/OpenID/TypeURIMismatch.html"," < ProtocolError","",1],["URINorm","OpenID","classes/OpenID/URINorm.html"," < ","",1],["UndefinedOpenIDNamespace","OpenID","classes/OpenID/UndefinedOpenIDNamespace.html"," < Exception","Raised if the generic OpenID namespace is accessed when there is no OpenID namespace set for this message.",1],["Util","OpenID","classes/OpenID/Util.html"," < ","",1],["Yadis","OpenID","classes/OpenID/Yadis.html"," < ","",1],["BasicServiceEndpoint","OpenID::Yadis","classes/OpenID/Yadis/BasicServiceEndpoint.html"," < Object","",1],["CompoundFilter","OpenID::Yadis","classes/OpenID/Yadis/CompoundFilter.html"," < Object","",1],["DiscoveryResult","OpenID::Yadis","classes/OpenID/Yadis/DiscoveryResult.html"," < Object","Contains the result of performing Yadis discovery on a URI ",1],["TransformFilterMaker","OpenID::Yadis","classes/OpenID/Yadis/TransformFilterMaker.html"," < Object","Take a list of basic filters and makes a filter that transforms the basic filter into a top-level filter.",1],["XRDSError","OpenID::Yadis","classes/OpenID/Yadis/XRDSError.html"," < StandardError","",1],["XRDSFraud","OpenID::Yadis","classes/OpenID/Yadis/XRDSFraud.html"," < XRDSError","Raised when there's an assertion in the XRDS that it does not have the authority to make. ",1],["XRI","OpenID::Yadis","classes/OpenID/Yadis/XRI.html"," < ","",1],["ProxyResolver","OpenID::Yadis::XRI","classes/OpenID/Yadis/XRI/ProxyResolver.html"," < Object","",1],["XRIHTTPError","OpenID::Yadis::XRI","classes/OpenID/Yadis/XRI/XRIHTTPError.html"," < StandardError","",1],["String","lib/openid/extras.rb","classes/String.html"," < Object","",1],["<<","HMAC::Base","classes/HMAC/Base.html#M000005","(text)","Alias for #update",2],["==","HTMLToken","classes/HTMLToken.html#M000509","(other)","Compare to another based on the raw source ",2],["==","OpenID::Association","classes/OpenID/Association.html#M000025","(other)","",2],["==","OpenID::Message","classes/OpenID/Message.html#M000314","(other)","",2],["[]","OpenID::AX::KeyValueMessage","classes/OpenID/AX/KeyValueMessage.html#M000231","(type_uri)","retrieve the list of values for this attribute ",2],["[]","OpenID::SReg::Response","classes/OpenID/SReg/Response.html#M000267","(field_name)","Read-only hashlike interface. Raises an exception if the field name is bad ",2],["_build_path","OpenID::TrustRoot::TrustRoot","classes/OpenID/TrustRoot/TrustRoot.html#M000453","(path, query=nil, frag=nil)","",2],["_dumb_key","OpenID::Server::Signatory","classes/OpenID/Server/Signatory.html#M000402","()","",2],["_extract_return_url","OpenID::TrustRoot","classes/OpenID/TrustRoot.html#M000446","(endpoint)","If the endpoint is a relying party OpenID return_to endpoint, return the endpoint URL. Otherwise, return",2],["_fix_ns","OpenID::Message","classes/OpenID/Message.html#M000306","(namespace)","Convert an input value into the internally used values of this obejct. ",2],["_from_net_response","OpenID::HTTPResponse","classes/OpenID/HTTPResponse.html#M000262","(response, final_url, headers=nil)","",2],["_from_openid_args","OpenID::Message","classes/OpenID/Message.html#M000292","(openid_args)","Raises InvalidNamespaceError if you try to instantiate a Message with a namespace not in the above allowed",2],["_get_association","OpenID::Store::Filesystem","classes/OpenID/Store/Filesystem.html#M000348","(filename)","",2],["_get_default_namespace","OpenID::Message","classes/OpenID/Message.html#M000293","(mystery_alias)","",2],["_get_extension_kv_args","OpenID::AX::KeyValueMessage","classes/OpenID/AX/KeyValueMessage.html#M000218","(aliases = nil)","Get the extension arguments for the key/value pairs contained in this message. ",2],["_normal_key","OpenID::Server::Signatory","classes/OpenID/Server/Signatory.html#M000401","()","",2],["_parse_url","OpenID::TrustRoot::TrustRoot","classes/OpenID/TrustRoot/TrustRoot.html#M000454","(url)","",2],["add","OpenID::AX::FetchRequest","classes/OpenID/AX/FetchRequest.html#M000206","(attribute)","Add an attribute to this attribute exchange request. attribute: AttrInfo, the attribute being requested",2],["add","OpenID::NamespaceMap","classes/OpenID/NamespaceMap.html#M000324","(namespace_uri)","Add this namespace URI to the mapping, without caring what alias it ends up with. ",2],["add_alias","OpenID::NamespaceMap","classes/OpenID/NamespaceMap.html#M000322","(namespace_uri, desired_alias, implicit=false)","Add an alias from this namespace URI to the alias. ",2],["add_allowed_type","OpenID::AssociationNegotiator","classes/OpenID/AssociationNegotiator.html#M000035","(assoc_type, session_type=nil)","",2],["add_extension","OpenID::Consumer::CheckIDRequest","classes/OpenID/Consumer/CheckIDRequest.html#M000050","(extension_request)","Add an object that implements the extension interface for adding arguments to an OpenID message to this",2],["add_extension","OpenID::Server::OpenIDResponse","classes/OpenID/Server/OpenIDResponse.html#M000389","(extension_response)","",2],["add_extension_arg","OpenID::Consumer::CheckIDRequest","classes/OpenID/Consumer/CheckIDRequest.html#M000051","(namespace, key, value)","Add an extension argument to this OpenID authentication request. You probably want to use add_extension",2],["add_policy_uri","OpenID::PAPE::Request","classes/OpenID/PAPE/Request.html#M000219","(policy_uri)","Add an acceptable authentication policy URI to this request This method is intended to be used by the",2],["add_policy_uri","OpenID::PAPE::Response","classes/OpenID/PAPE/Response.html#M000228","(policy_uri)","Add a policy URI to the response see http://openid.net/specs/openid-provider-authentication-policy-extension-1_0-01.html#auth_policies",2],["add_value","OpenID::AX::KeyValueMessage","classes/OpenID/AX/KeyValueMessage.html#M000216","(type_uri, value)","Add a single value for the given attribute type to the message. If there are already values specified",2],["aliases","OpenID::NamespaceMap","classes/OpenID/NamespaceMap.html#M000331","()","",2],["all_requested_fields","OpenID::SReg::Request","classes/OpenID/SReg/Request.html#M000253","()","A list of all of the simple registration fields that were requested, whether they were required or optional.",2],["allowed?","OpenID::AssociationNegotiator","classes/OpenID/AssociationNegotiator.html#M000036","(assoc_type, session_type)","",2],["allowed_assoc_type?","OpenID::Server::BaseServerSession","classes/OpenID/Server/BaseServerSession.html#M000333","(typ)","",2],["allowed_types=","OpenID::AssociationNegotiator","classes/OpenID/AssociationNegotiator.html#M000034","(allowed_types)","",2],["anonymous=","OpenID::Consumer::CheckIDRequest","classes/OpenID/Consumer/CheckIDRequest.html#M000049","(is_anonymous)","Set whether this request should be made anonymously. If a request is anonymous, the identifier will not",2],["answer","OpenID::Server::AssociateRequest","classes/OpenID/Server/AssociateRequest.html#M000347","(assoc)","Respond to this request with an association. assoc:: The association to send back. Returns a response",2],["answer","OpenID::Server::CheckAuthRequest","classes/OpenID/Server/CheckAuthRequest.html#M000325","(signatory)","Respond to this request. Given a Signatory, I can check the validity of the signature and the invalidate_handle.",2],["answer","OpenID::Server::CheckIDRequest","classes/OpenID/Server/CheckIDRequest.html#M000365","(allow, server_url=nil, identity=nil, claimed_id=nil)","Respond to this request. allow:: Allow this user to claim this identity, and allow the consumer to have",2],["answer","OpenID::Server::DiffieHellmanSHA1ServerSession","classes/OpenID/Server/DiffieHellmanSHA1ServerSession.html#M000339","(secret)","",2],["answer","OpenID::Server::PlainTextServerSession","classes/OpenID/Server/PlainTextServerSession.html#M000336","(secret)","",2],["answer_unsupported","OpenID::Server::AssociateRequest","classes/OpenID/Server/AssociateRequest.html#M000349","(message, preferred_association_type=nil, preferred_session_type=nil)","Respond to this request indicating that the association type or association session type is not supported.",2],["append_args","OpenID::Util","classes/OpenID/Util.html#M000471","(url, args)","",2],["append_args","OpenID::Yadis::XRI","classes/OpenID/Yadis/XRI.html#M000537","(url, args)","",2],["apply_filter","OpenID::Yadis","classes/OpenID/Yadis.html#M000515","(normalized_uri, xrd_data, flt=nil)","",2],["apply_filters","OpenID::Yadis::TransformFilterMaker","classes/OpenID/Yadis/TransformFilterMaker.html#M000490","(endpoint)","",2],["arrange_by_type","OpenID","classes/OpenID.html#M000098","(service_list, preferred_types)","",2],["assert","OpenID::Util","classes/OpenID/Util.html#M000465","(value, message=nil)","",2],["assoc_key","OpenID::Store::Memcache","classes/OpenID/Store/Memcache.html#M000392","(server_url, assoc_handle=nil)","",2],["association_manager","OpenID::Consumer","classes/OpenID/Consumer.html#M000161","(service)","",2],["attr_hash","HTMLTag","classes/HTMLTag.html#M000513","()","Retrieve a hash of all the tag's attributes. Lazily done, so that if you don't look at a tag's attributes",2],["attributes","OpenID::AX::FetchRequest","classes/OpenID/AX/FetchRequest.html#M000211","()","return the list of AttrInfo objects contained in the FetchRequest ",2],["auto_submit_html","OpenID::Util","classes/OpenID/Util.html#M000476","(form, title='OpenID transaction in progress')","",2],["base64_to_num","OpenID::CryptUtil","classes/OpenID/CryptUtil.html#M000181","(s)","Decode a base64 byte string to a number. ",2],["begin","OpenID::Consumer","classes/OpenID/Consumer.html#M000147","(openid_identifier, anonymous=false)","Start the OpenID authentication process. See steps 1-2 in the overview for the Consumer class. user_url:",2],["begin_without_discovery","OpenID::Consumer","classes/OpenID/Consumer.html#M000149","(service, anonymous)","Start OpenID verification without doing OpenID server discovery. This method is used internally by Consumer.begin()",2],["best_matching_service","OpenID","classes/OpenID.html#M000097","(service, preferred_types)","",2],["binary_to_num","OpenID::CryptUtil","classes/OpenID/CryptUtil.html#M000177","(s)","Convert a string of bytes into a number. ",2],["body=","OpenID::HTTPResponse","classes/OpenID/HTTPResponse.html#M000265","(s)","",2],["build_discovery_url","OpenID::TrustRoot::TrustRoot","classes/OpenID/TrustRoot/TrustRoot.html#M000459","()","Return a discovery URL for this realm. This function does not check to make sure that the realm is valid.",2],["cancel_url","OpenID::Server::CheckIDRequest","classes/OpenID/Server/CheckIDRequest.html#M000374","()","",2],["check_alias","OpenID::AX","classes/OpenID/AX.html#M000190","(name)","check alias for invalid characters, raise AXError if found ",2],["check_auth","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000137","()","",2],["check_for_fields","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000121","()","",2],["check_message_signature","OpenID::Association","classes/OpenID/Association.html#M000023","(message)","Return whether the message's signature passes ",2],["check_mode","OpenID::AX::AXMessage","classes/OpenID/AX/AXMessage.html#M000192","(ax_args)","Raise an exception if the mode in the attribute exchange arguments does not match what is expected for",2],["check_nonce","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000140","()","",2],["check_sanity","OpenID::TrustRoot::TrustRoot","classes/OpenID/TrustRoot/TrustRoot.html#M000456","(trust_root_string)","",2],["check_session_type","OpenID::AssociationNegotiator","classes/OpenID/AssociationNegotiator.html#M000030","(assoc_type, session_type)","",2],["check_signature","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000136","()","Raises ProtocolError if the signature is bad ",2],["check_sreg_field_name","OpenID","classes/OpenID.html#M000245","(fieldname)","raise ArgumentError if fieldname is not in the defined sreg fields ",2],["check_status","HMAC::Base","classes/HMAC/Base.html#M000001","()","",2],["check_timestamp","OpenID::Nonce","classes/OpenID/Nonce.html#M000425","(nonce_str, allowed_skew=nil, now=nil)","Is the timestamp that is part of the specified nonce string within the allowed clock-skew of the current",2],["check_url","OpenID::TrustRoot::TrustRoot","classes/OpenID/TrustRoot/TrustRoot.html#M000458","(trust_root, url)","quick func for validating a url against a trust root.  See the TrustRoot class if you need more control.",2],["cleanup","OpenID::Consumer::DiscoveryManager","classes/OpenID/Consumer/DiscoveryManager.html#M000067","(force=false)","",2],["cleanup","OpenID::Store::Filesystem","classes/OpenID/Store/Filesystem.html#M000353","()","Remove expired entries from the database. This is potentially expensive, so only run when it is acceptable",2],["cleanup","OpenID::Store::Interface","classes/OpenID/Store/Interface.html#M000372","()","Remove expired nonces and associations from the store Not called during normal library operation, this",2],["cleanup","OpenID::Store::Memcache","classes/OpenID/Store/Memcache.html#M000394","()","",2],["cleanup_associations","OpenID::Store::Filesystem","classes/OpenID/Store/Filesystem.html#M000354","()","",2],["cleanup_associations","OpenID::Store::Interface","classes/OpenID/Store/Interface.html#M000371","()","Remove expired associations from the store Not called during normal library operation, this method is",2],["cleanup_associations","OpenID::Store::Memcache","classes/OpenID/Store/Memcache.html#M000395","()","",2],["cleanup_associations","OpenID::Store::Memory","classes/OpenID/Store/Memory.html#M000414","()","",2],["cleanup_last_requested_endpoint","OpenID::Consumer","classes/OpenID/Consumer.html#M000156","()","",2],["cleanup_nonces","OpenID::Store::Filesystem","classes/OpenID/Store/Filesystem.html#M000356","()","",2],["cleanup_nonces","OpenID::Store::Interface","classes/OpenID/Store/Interface.html#M000370","()","Remove expired nonces from the store Discards any nonce that is old enough that it wouldn't pass use_nonce",2],["cleanup_nonces","OpenID::Store::Memcache","classes/OpenID/Store/Memcache.html#M000393","()","",2],["cleanup_nonces","OpenID::Store::Memory","classes/OpenID/Store/Memory.html#M000416","()","",2],["cleanup_session","OpenID::Consumer","classes/OpenID/Consumer.html#M000158","()","",2],["compatibility_mode","OpenID::OpenIDServiceEndpoint","classes/OpenID/OpenIDServiceEndpoint.html#M000075","()","",2],["complete","OpenID::Consumer","classes/OpenID/Consumer.html#M000150","(query, current_url)","Returns a subclass of Response. The type of response is indicated by the status attribute, which will",2],["complete_cancel","OpenID::Consumer","classes/OpenID/Consumer.html#M000164","(unused_message, unused_return_to)","",2],["complete_error","OpenID::Consumer","classes/OpenID/Consumer.html#M000165","(message, unused_return_to)","",2],["complete_id_res","OpenID::Consumer","classes/OpenID/Consumer.html#M000167","(message, current_url)","",2],["complete_invalid","OpenID::Consumer","classes/OpenID/Consumer.html#M000163","(message, unused_return_to)","",2],["complete_setup_needed","OpenID::Consumer","classes/OpenID/Consumer.html#M000166","(message, unused_return_to)","",2],["const_eq","OpenID::CryptUtil","classes/OpenID/CryptUtil.html#M000182","(s1, s2)","",2],["copy","OpenID::AssociationNegotiator","classes/OpenID/AssociationNegotiator.html#M000033","()","",2],["copy","OpenID::Message","classes/OpenID/Message.html#M000299","()","",2],["copy","OpenID::Server::OpenIDResponse","classes/OpenID/Server/OpenIDResponse.html#M000391","()","",2],["count","OpenID::AX::KeyValueMessage","classes/OpenID/AX/KeyValueMessage.html#M000232","(type_uri)","get the number of responses for this attribute ",2],["create_associate_request","OpenID::Consumer::AssociationManager","classes/OpenID/Consumer/AssociationManager.html#M000046","(assoc_type, session_type)","Create an association request for the given assoc_type and session_type. Returns a pair of the association",2],["create_association","OpenID::Server::Signatory","classes/OpenID/Server/Signatory.html#M000406","(dumb=true, assoc_type='HMAC-SHA1')","Make a new association. ",2],["create_check_auth_request","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000138","()","",2],["create_manager","OpenID::Consumer::DiscoveryManager","classes/OpenID/Consumer/DiscoveryManager.html#M000072","(yadis_url, services)","",2],["create_session","OpenID::Consumer::AssociationManager","classes/OpenID/Consumer/AssociationManager.html#M000040","(session_type)","",2],["decode","OpenID::Server::Decoder","classes/OpenID/Server/Decoder.html#M000424","(query)","I transform query parameters into an OpenIDRequest. If the query does not seem to be an OpenID request",2],["decode_request","OpenID::Server::Server","classes/OpenID/Server/Server.html#M000432","(query)","Transform query parameters into an OpenIDRequest. query should contain the query parameters as a Hash",2],["deepcopy","OpenID::Store::Memory","classes/OpenID/Store/Memory.html#M000417","(o)","",2],["default_decoder","OpenID::Server::Decoder","classes/OpenID/Server/Decoder.html#M000426","(message, server)","Called to decode queries when no handler for that mode is found. This implementation always raises ProtocolError.",2],["del_arg","OpenID::Message","classes/OpenID/Message.html#M000313","(namespace, key)","Remove a single argument from this namespace. ",2],["delete","OpenID::Store::Memcache","classes/OpenID/Store/Memcache.html#M000397","(key)","",2],["deserialize","OpenID::Association","classes/OpenID/Association.html#M000016","(serialized)","Load a serialized Association ",2],["deserialize","OpenID::Store::Memcache","classes/OpenID/Store/Memcache.html#M000399","(assoc_str)","",2],["destroy!","OpenID::Consumer::DiscoveryManager","classes/OpenID/Consumer/DiscoveryManager.html#M000080","()","",2],["destroy_manager","OpenID::Consumer::DiscoveryManager","classes/OpenID/Consumer/DiscoveryManager.html#M000076","(force=false)","",2],["dict_to_kv","OpenID::Util","classes/OpenID/Util.html#M000282","(d)","",2],["digest","HMAC::Base","classes/HMAC/Base.html#M000006","()","",2],["digest","HMAC::Base","classes/HMAC/Base.html#M000009","(key, text)","These two class methods below are safer than using above instance methods combinatorially because an",2],["discover","OpenID","classes/OpenID.html#M000107","(identifier)","",2],["discover","OpenID::Consumer","classes/OpenID/Consumer.html#M000159","(identifier)","",2],["discover","OpenID::Yadis","classes/OpenID/Yadis.html#M000487","(uri)","Discover services for a given URI. uri: The identity URI as a well-formed http or https URI. The well-formedness",2],["discover_and_verify","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000144","(claimed_id, to_match_endpoints)","Given an endpoint object created from the information in an OpenID response, perform discovery and verify",2],["discover_no_yadis","OpenID","classes/OpenID.html#M000105","(uri)","",2],["discover_uri","OpenID","classes/OpenID.html#M000106","(uri)","",2],["discover_xri","OpenID","classes/OpenID.html#M000104","(iname)","",2],["discover_yadis","OpenID","classes/OpenID.html#M000103","(uri)","",2],["discovery_manager","OpenID::Consumer","classes/OpenID/Consumer.html#M000157","(openid_identifier)","",2],["display_identifier","OpenID::Consumer::Response","classes/OpenID/Consumer/Response.html#M000123","()","The display identifier is related to the Claimed Identifier, but the two are not always identical.  The",2],["display_identifier","OpenID::OpenIDServiceEndpoint","classes/OpenID/OpenIDServiceEndpoint.html#M000068","()","",2],["display_identifier=","OpenID::OpenIDServiceEndpoint","classes/OpenID/OpenIDServiceEndpoint.html#M000069","(display_identifier)","",2],["each","OpenID::NamespaceMap","classes/OpenID/NamespaceMap.html#M000327","()","",2],["each_service","OpenID::Yadis","classes/OpenID/Yadis.html#M000528","(xrds_tree, &block)","aka iterServices in Python ",2],["empty?","OpenID::Consumer::DiscoveredServices","classes/OpenID/Consumer/DiscoveredServices.html#M000063","()","",2],["empty?","OpenID::SReg::Response","classes/OpenID/SReg/Response.html#M000268","()","",2],["encode","OpenID::Server::Encoder","classes/OpenID/Server/Encoder.html#M000415","(response)","Encode a response to a WebResponse. Raises EncodingError when I can't figure out how to encode this message.",2],["encode","OpenID::Server::SigningEncoder","classes/OpenID/Server/SigningEncoder.html#M000419","(response)","Encode a response to a WebResponse, signing it first if appropriate. Raises EncodingError when I can't",2],["encode_response","OpenID::Server::Server","classes/OpenID/Server/Server.html#M000433","(response)","Encode a response to a WebResponse, signing it first if appropriate. Raises EncodingError when I can't",2],["encode_to_kvform","OpenID::Server::OpenIDResponse","classes/OpenID/Server/OpenIDResponse.html#M000390","()","",2],["encode_to_kvform","OpenID::Server::ProtocolError","classes/OpenID/Server/ProtocolError.html#M000439","()","",2],["encode_to_url","OpenID::Server::CheckIDRequest","classes/OpenID/Server/CheckIDRequest.html#M000373","(server_url)","",2],["encode_to_url","OpenID::Server::OpenIDResponse","classes/OpenID/Server/OpenIDResponse.html#M000387","()","",2],["encode_to_url","OpenID::Server::ProtocolError","classes/OpenID/Server/ProtocolError.html#M000438","()","implements IEncodable ",2],["ends_with?","String","classes/String.html#M000250","(other)","",2],["ensure_dir","OpenID::Store::Filesystem","classes/OpenID/Store/Filesystem.html#M000361","(dir_name)","ensure that a path exists ",2],["escape_for_iri","OpenID::Yadis::XRI","classes/OpenID/Yadis/XRI.html#M000520","(xri)","Note this is not not idempotent, so do not apply this more than once.  XRI Syntax section 2.3.2 ",2],["expand_service","OpenID::Yadis","classes/OpenID/Yadis.html#M000531","(service_element)","",2],["expires_in","OpenID::Association","classes/OpenID/Association.html#M000020","(now=nil)","The number of seconds until this association expires ",2],["expiry","OpenID::Store::Memcache","classes/OpenID/Store/Memcache.html#M000400","(t)","Convert a lifetime in seconds into a memcache expiry value ",2],["extension_response","OpenID::Consumer::SuccessResponse","classes/OpenID/Consumer/SuccessResponse.html#M000131","(namespace_uri, require_signed)","Return response arguments in the specified namespace. If require_signed is true and the arguments are",2],["extract_association","OpenID::Consumer::AssociationManager","classes/OpenID/Consumer/AssociationManager.html#M000053","(assoc_response, assoc_session)","Attempt to extract an association from the response, given the association response message and the established",2],["extract_expires_in","OpenID::Consumer::AssociationManager","classes/OpenID/Consumer/AssociationManager.html#M000052","(message)","",2],["extract_response","OpenID::SReg::Response","classes/OpenID/SReg/Response.html#M000261","(request, data)","Take a Request and a hash of simple registration values and create a Response object containing that",2],["extract_secret","OpenID::Consumer::DiffieHellmanSession","classes/OpenID/Consumer/DiffieHellmanSession.html#M000031","(response)","Process the response from a successful association request and return the shared secret for this association",2],["extract_secret","OpenID::Consumer::NoEncryptionSession","classes/OpenID/Consumer/NoEncryptionSession.html#M000039","(response)","",2],["extract_supported_association_type","OpenID::Consumer::AssociationManager","classes/OpenID/Consumer/AssociationManager.html#M000044","(server_error, assoc_type)","",2],["fetch","OpenID","classes/OpenID.html#M000269","(url, body=nil, headers=nil, redirect_limit=StandardFetcher::REDIRECT_LIMIT)","",2],["fetch","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000118","(field, default=NO_DEFAULT)","",2],["fetch","OpenID::StandardFetcher","classes/OpenID/StandardFetcher.html#M000279","(url, body=nil, headers=nil, redirect_limit=REDIRECT_LIMIT)","",2],["fetcher","OpenID","classes/OpenID.html#M000270","()","",2],["fetcher=","OpenID","classes/OpenID.html#M000271","(fetcher)","",2],["fetcher_use_env_http_proxy","OpenID","classes/OpenID.html#M000272","()","Set the default fetcher to use the HTTP proxy defined in the environment variable 'http_proxy'. ",2],["filename_escape","OpenID::Store::Filesystem","classes/OpenID/Store/Filesystem.html#M000358","(s)","create a safe filename from a url ",2],["find_first_href","OpenID","classes/OpenID.html#M000102","(link_attrs_list, target_rel)","",2],["find_links_rel","OpenID","classes/OpenID.html#M000100","(link_attrs_list, target_rel)","",2],["find_op_local_identifier","OpenID","classes/OpenID.html#M000090","(service_element, type_uris)","",2],["for_url?","OpenID::Consumer::DiscoveredServices","classes/OpenID/Consumer/DiscoveredServices.html#M000061","(url)","",2],["form_markup","OpenID::Consumer::CheckIDRequest","classes/OpenID/Consumer/CheckIDRequest.html#M000056","(realm, return_to=nil, immediate=false, form_tag_attrs=nil)","Get html for a form to submit this request to the IDP. form_tag_attrs is a hash of attributes to be added",2],["from_base64","OpenID::Util","classes/OpenID/Util.html#M000467","(s)","",2],["from_basic_service_endpoint","OpenID::OpenIDServiceEndpoint","classes/OpenID/OpenIDServiceEndpoint.html#M000084","(endpoint)","",2],["from_basic_service_endpoint","OpenID::Yadis::BasicServiceEndpoint","classes/OpenID/Yadis/BasicServiceEndpoint.html#M000484","(endpoint)","A hack to make both this class and its instances respond to this message since Ruby doesn't support static",2],["from_basic_service_endpoint","OpenID::Yadis::BasicServiceEndpoint","classes/OpenID/Yadis/BasicServiceEndpoint.html#M000483","(endpoint)","Trivial transform from a basic endpoint to itself. This method exists to allow BasicServiceEndpoint to",2],["from_defaults","OpenID::DiffieHellman","classes/OpenID/DiffieHellman.html#M000175","()","A new DiffieHellman object, using the modulus and generator from the OpenID specification ",2],["from_discovery_result","OpenID::OpenIDServiceEndpoint","classes/OpenID/OpenIDServiceEndpoint.html#M000087","(discoveryResult)","",2],["from_expires_in","OpenID::Association","classes/OpenID/Association.html#M000017","(expires_in, handle, secret, assoc_type)","Create an Association with an issued time of now ",2],["from_html","OpenID::OpenIDServiceEndpoint","classes/OpenID/OpenIDServiceEndpoint.html#M000085","(uri, html)","",2],["from_http_response","OpenID::Message","classes/OpenID/Message.html#M000286","(response, server_url)","",2],["from_kvform","OpenID::Message","classes/OpenID/Message.html#M000298","(kvform_string)","Create a message from a KVForm string ",2],["from_message","OpenID::Server::AssociateRequest","classes/OpenID/Server/AssociateRequest.html#M000344","(message, op_endpoint=UNUSED)","Construct me from an OpenID Message. ",2],["from_message","OpenID::Server::CheckAuthRequest","classes/OpenID/Server/CheckAuthRequest.html#M000323","(message, op_endpoint=UNUSED)","Construct me from an OpenID::Message. ",2],["from_message","OpenID::Server::CheckIDRequest","classes/OpenID/Server/CheckIDRequest.html#M000355","(message, op_endpoint)","Construct me from an OpenID message. message:: An OpenID checkid_* request Message op_endpoint:: The",2],["from_message","OpenID::Server::DiffieHellmanSHA1ServerSession","classes/OpenID/Server/DiffieHellmanSHA1ServerSession.html#M000338","(message)","Construct me from OpenID Message Raises ProtocolError when parameters required to establish the session",2],["from_message","OpenID::Server::PlainTextServerSession","classes/OpenID/Server/PlainTextServerSession.html#M000335","(unused_request)","",2],["from_message","OpenID::ServerError","classes/OpenID/ServerError.html#M000285","(msg)","",2],["from_op_endpoint_url","OpenID::OpenIDServiceEndpoint","classes/OpenID/OpenIDServiceEndpoint.html#M000088","(op_endpoint_url)","",2],["from_openid_args","OpenID::Message","classes/OpenID/Message.html#M000291","(openid_args)","Construct a Message from a parsed KVForm message. Raises InvalidNamespaceError if you try to instantiate",2],["from_openid_request","OpenID::AX::FetchRequest","classes/OpenID/AX/FetchRequest.html#M000209","(oidreq)","Extract a FetchRequest from an OpenID message message: OpenID::Message return a FetchRequest or nil if",2],["from_openid_request","OpenID::AX::StoreRequest","classes/OpenID/AX/StoreRequest.html#M000239","(oidreq)","Extract a StoreRequest from an OpenID message message: OpenID::Message return a StoreRequest or nil if",2],["from_openid_request","OpenID::OAuth::Request","classes/OpenID/OAuth/Request.html#M000198","(oid_req)","Instantiate a Request object from the arguments in a checkid_* OpenID message return nil if the extension",2],["from_openid_request","OpenID::PAPE::Request","classes/OpenID/PAPE/Request.html#M000221","(oid_req)","Instantiate a Request object from the arguments in a checkid_* OpenID message return nil if the extension",2],["from_openid_request","OpenID::SReg::Request","classes/OpenID/SReg/Request.html#M000251","(request)","Create a simple registration request that contains the fields that were requested in the OpenID request",2],["from_post_args","OpenID::Message","classes/OpenID/Message.html#M000290","(args)","Construct a Message containing a set of POST arguments. Raises InvalidNamespaceError if you try to instantiate",2],["from_success_response","OpenID::AX::FetchResponse","classes/OpenID/AX/FetchResponse.html#M000237","(success_response, signed=true)","Construct a FetchResponse object from an OpenID library SuccessResponse object. ",2],["from_success_response","OpenID::AX::StoreResponse","classes/OpenID/AX/StoreResponse.html#M000242","(success_response)","",2],["from_success_response","OpenID::OAuth::Response","classes/OpenID/OAuth/Response.html#M000202","(success_response)","Create a Response object from an OpenID::Consumer::SuccessResponse ",2],["from_success_response","OpenID::PAPE::Response","classes/OpenID/PAPE/Response.html#M000229","(success_response)","Create a Response object from an OpenID::Consumer::SuccessResponse ",2],["from_success_response","OpenID::SReg::Response","classes/OpenID/SReg/Response.html#M000263","(success_response, signed_only = true)","Create an Response object from an OpenID::Consumer::SuccessResponse from consumer.complete If you set",2],["from_xrds","OpenID::OpenIDServiceEndpoint","classes/OpenID/OpenIDServiceEndpoint.html#M000086","(uri, xrds)","",2],["generate_accept_header","OpenID::Yadis","classes/OpenID/Yadis.html#M000469","(*elements)","Generate an accept header value [str or (str, float)] -> str ",2],["get","OpenID::AX::KeyValueMessage","classes/OpenID/AX/KeyValueMessage.html#M000227","(type_uri)","retrieve the list of values for this attribute ",2],["getNextToken","HTMLTokenizer","classes/HTMLTokenizer.html#M000501","()","Get the next token, returns an instance of * HTMLText * HTMLToken * HTMLTag ",2],["getTag","HTMLTokenizer","classes/HTMLTokenizer.html#M000502","(*sought_tags)","Get a tag from the specified set of desired tags. For example: <tt>foo =  toke.getTag(\"h1\", \"h2\", \"h3\")</tt>",2],["getText","HTMLTokenizer","classes/HTMLTokenizer.html#M000503","(until_tag = nil)","Get all the text between the current position and the next tag (if specified) or a specific later tag",2],["getTrimmedText","HTMLTokenizer","classes/HTMLTokenizer.html#M000504","(until_tag = nil)","Like getText, but squeeze all whitespace, getting rid of leading and trailing whitespace, and squeezing",2],["get_acceptable","OpenID::Yadis","classes/OpenID/Yadis.html#M000478","(accept_header, have_types)","",2],["get_alias","OpenID::NamespaceMap","classes/OpenID/NamespaceMap.html#M000319","(namespace_uri)","",2],["get_aliased_arg","OpenID::Message","classes/OpenID/Message.html#M000315","(aliased_key, default=nil)","",2],["get_allowed_return_urls","OpenID::TrustRoot","classes/OpenID/TrustRoot.html#M000451","(relying_party_url)","Given a relying party discovery URL return a list of return_to URLs. ",2],["get_allowed_type","OpenID::AssociationNegotiator","classes/OpenID/AssociationNegotiator.html#M000037","()","",2],["get_arg","OpenID::Message","classes/OpenID/Message.html#M000309","(namespace, key, default=nil)","Get a value for a namespaced key. ",2],["get_args","OpenID::Message","classes/OpenID/Message.html#M000310","(namespace)","Get the arguments that are defined for this namespace URI. ",2],["get_association","OpenID::Consumer::AssociationManager","classes/OpenID/Consumer/AssociationManager.html#M000042","()","",2],["get_association","OpenID::Server::Signatory","classes/OpenID/Server/Signatory.html#M000409","(assoc_handle, dumb, checkExpiration=true)","Get the association with the specified handle. ",2],["get_association","OpenID::Store::Filesystem","classes/OpenID/Store/Filesystem.html#M000346","(server_url, handle=nil)","Retrieve an association ",2],["get_association","OpenID::Store::Interface","classes/OpenID/Store/Interface.html#M000367","(server_url, handle=nil)","Returns a Association object from storage that matches the server_url.  Returns nil if no such association",2],["get_association","OpenID::Store::Memcache","classes/OpenID/Store/Memcache.html#M000379","(server_url, handle=nil)","Returns a Association object from storage that matches the server_url.  Returns nil if no such association",2],["get_association","OpenID::Store::Memory","classes/OpenID/Store/Memory.html#M000410","(server_url, handle=nil)","",2],["get_association_filename","OpenID::Store::Filesystem","classes/OpenID/Store/Filesystem.html#M000343","(server_url, handle)","Create a unique filename for a given server url and handle. The filename that is returned will contain",2],["get_canonical_id","OpenID::Yadis","classes/OpenID/Yadis.html#M000517","(iname, xrd_tree)","",2],["get_extension_args","OpenID::AX::FetchRequest","classes/OpenID/AX/FetchRequest.html#M000207","()","Get the serialized form of this attribute fetch request. returns a hash of the arguments ",2],["get_extension_args","OpenID::AX::FetchResponse","classes/OpenID/AX/FetchResponse.html#M000234","(request = nil)","Serialize this object into arguments in the attribute exchange namespace Takes an optional FetchRequest.",2],["get_extension_args","OpenID::AX::StoreRequest","classes/OpenID/AX/StoreRequest.html#M000240","(aliases=nil)","",2],["get_extension_args","OpenID::AX::StoreResponse","classes/OpenID/AX/StoreResponse.html#M000244","()","",2],["get_extension_args","OpenID::Extension","classes/OpenID/Extension.html#M000188","()","Get the string arguments that should be added to an OpenID message for this extension. ",2],["get_extension_args","OpenID::OAuth::Request","classes/OpenID/OAuth/Request.html#M000197","()","",2],["get_extension_args","OpenID::OAuth::Response","classes/OpenID/OAuth/Response.html#M000204","()","",2],["get_extension_args","OpenID::PAPE::Request","classes/OpenID/PAPE/Request.html#M000220","()","",2],["get_extension_args","OpenID::PAPE::Response","classes/OpenID/PAPE/Response.html#M000235","()","",2],["get_extension_args","OpenID::SReg::Request","classes/OpenID/SReg/Request.html#M000258","()","Get a hash of unqualified simple registration arguments representing this request. This method is essentially",2],["get_extension_args","OpenID::SReg::Response","classes/OpenID/SReg/Response.html#M000266","()","Get the fields to put in the simple registration namespace when adding them to an id_res message. ",2],["get_key","OpenID::Message","classes/OpenID/Message.html#M000308","(namespace, ns_key)","Get the key for a particular namespaced argument ",2],["get_local_id","OpenID::OpenIDServiceEndpoint","classes/OpenID/OpenIDServiceEndpoint.html#M000083","()","",2],["get_manager","OpenID::Consumer::DiscoveryManager","classes/OpenID/Consumer/DiscoveryManager.html#M000071","(force=false)","",2],["get_message","OpenID::Consumer::CheckIDRequest","classes/OpenID/Consumer/CheckIDRequest.html#M000054","(realm, return_to=nil, immediate=false)","Produce a OpenID::Message representing this request. Not specifying a return_to URL means that the user",2],["get_message_signature","OpenID::Association","classes/OpenID/Association.html#M000024","(message)","Get the signature for this message ",2],["get_namespace_uri","OpenID::NamespaceMap","classes/OpenID/NamespaceMap.html#M000321","(namespace_alias)","",2],["get_next_service","OpenID::Consumer::DiscoveryManager","classes/OpenID/Consumer/DiscoveryManager.html#M000065","()","",2],["get_op_or_user_services","OpenID","classes/OpenID.html#M000101","(openid_services)","",2],["get_openid1_session_type","OpenID::Consumer::AssociationManager","classes/OpenID/Consumer/AssociationManager.html#M000048","(assoc_response)","Given an association response message, extract the OpenID 1.X session type. Returns the association type",2],["get_openid_namespace","OpenID::Message","classes/OpenID/Message.html#M000295","()","",2],["get_request","OpenID::Consumer::DiffieHellmanSession","classes/OpenID/Consumer/DiffieHellmanSession.html#M000028","()","Return the query parameters for requesting an association using this Diffie-Hellman association session",2],["get_request","OpenID::Consumer::NoEncryptionSession","classes/OpenID/Consumer/NoEncryptionSession.html#M000038","()","",2],["get_required_attrs","OpenID::AX::FetchRequest","classes/OpenID/AX/FetchRequest.html#M000208","()","Get the type URIs for all attributes that have been marked as required. ",2],["get_return_to","OpenID::Server::ProtocolError","classes/OpenID/Server/ProtocolError.html#M000435","()","Get the return_to argument from the request, if any. ",2],["get_secret_size","OpenID","classes/OpenID.html#M000015","(assoc_type)","",2],["get_service_endpoints","OpenID::Yadis","classes/OpenID/Yadis.html#M000514","(input_url, flt=nil)","",2],["get_service_endpoints","OpenID::Yadis::CompoundFilter","classes/OpenID/Yadis/CompoundFilter.html#M000493","(yadis_url, service_element)","Generate all endpoint objects for all of the subfilters of this filter and return their concatenation.",2],["get_service_endpoints","OpenID::Yadis::TransformFilterMaker","classes/OpenID/Yadis/TransformFilterMaker.html#M000489","(yadis_url, service_element)","Returns an array of endpoint objects produced by the filter procs. ",2],["get_session_types","OpenID::AssociationNegotiator","classes/OpenID/AssociationNegotiator.html#M000029","(assoc_type)","",2],["get_shared_secret","OpenID::DiffieHellman","classes/OpenID/DiffieHellman.html#M000178","(composite)","",2],["get_signed","OpenID::Consumer::SuccessResponse","classes/OpenID/Consumer/SuccessResponse.html#M000128","(ns_uri, ns_key, default=nil)","Return the specified signed field if available, otherwise return default ",2],["get_signed_ns","OpenID::Consumer::SuccessResponse","classes/OpenID/Consumer/SuccessResponse.html#M000130","(ns_uri)","Get signed arguments from the response message.  Return a dict of all arguments in the specified namespace.",2],["get_single","OpenID::AX::KeyValueMessage","classes/OpenID/AX/KeyValueMessage.html#M000226","(type_uri, default = nil)","Get a single value for an attribute. If no value was sent for this attribute, use the supplied default.",2],["get_sreg_ns","OpenID","classes/OpenID.html#M000247","(message)","Extract the simple registration namespace URI from the given OpenID message. Handles OpenID 1 and 2,",2],["get_yadis_xrd","OpenID::Yadis","classes/OpenID/Yadis.html#M000527","(xrds_tree)","",2],["handle_idres","OpenID::Consumer","classes/OpenID/Consumer.html#M000162","(message, current_url)","",2],["handle_request","OpenID::Server::Server","classes/OpenID/Server/Server.html#M000429","(request)","Handle a request. Give me a request, I will give you a response.  Unless it's a type of request I cannot",2],["has_key?","OpenID::Message","classes/OpenID/Message.html#M000307","(namespace, ns_key)","",2],["has_return_to","OpenID::Server::ProtocolError","classes/OpenID/Server/ProtocolError.html#M000436","()","Did this request have a return_to parameter? ",2],["hexdigest","HMAC::Base","classes/HMAC/Base.html#M000010","(key, text)","",2],["hexdigest","HMAC::Base","classes/HMAC/Base.html#M000007","()","",2],["hmac_sha1","OpenID::CryptUtil","classes/OpenID/CryptUtil.html#M000170","(key, text)","",2],["hmac_sha256","OpenID::CryptUtil","classes/OpenID/CryptUtil.html#M000172","(key, text)","",2],["html_markup","OpenID::Consumer::CheckIDRequest","classes/OpenID/Consumer/CheckIDRequest.html#M000057","(realm, return_to=nil, immediate=false, form_tag_attrs=nil)","Get a complete HTML document that autosubmits the request to the IDP with javascript.  This method wraps",2],["html_yadis_location","OpenID::Yadis","classes/OpenID/Yadis.html#M000500","(html)","",2],["id_res","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000115","()","This method will raise ProtocolError unless the request is a valid id_res response. Once it has been",2],["id_select","OpenID::Server::CheckIDRequest","classes/OpenID/Server/CheckIDRequest.html#M000362","()","Is the identifier to be selected by the IDP? ",2],["identifier_scheme","OpenID::Yadis::XRI","classes/OpenID/Yadis/XRI.html#M000518","(identifier)","",2],["identity_url","OpenID::Consumer::Response","classes/OpenID/Consumer/Response.html#M000122","()","The identity URL that has been authenticated; the Claimed Identifier. See also display_identifier. ",2],["implicit?","OpenID::NamespaceMap","classes/OpenID/NamespaceMap.html#M000330","(namespace_uri)","",2],["invalidate","OpenID::Server::Signatory","classes/OpenID/Server/Signatory.html#M000412","(assoc_handle, dumb)","Invalidates the association with the given handle. ",2],["iri_to_uri","OpenID::Yadis::XRI","classes/OpenID/Yadis/XRI.html#M000522","(iri)","RFC 3987 section 3.1 ",2],["is_op_identifier","OpenID::OpenIDServiceEndpoint","classes/OpenID/OpenIDServiceEndpoint.html#M000081","()","",2],["is_openid1","OpenID::Consumer::SuccessResponse","classes/OpenID/Consumer/SuccessResponse.html#M000126","()","Was this authentication response an OpenID 1 authentication response? ",2],["is_openid1","OpenID::Message","classes/OpenID/Message.html#M000296","()","",2],["is_openid2","OpenID::Message","classes/OpenID/Message.html#M000297","()","",2],["is_xrds","OpenID::Yadis::DiscoveryResult","classes/OpenID/Yadis/DiscoveryResult.html#M000486","()","Is the response text supposed to be an XRDS document? ",2],["is_xrds?","OpenID::Yadis","classes/OpenID/Yadis.html#M000526","(xrds_tree)","",2],["kv_to_dict","OpenID::Util","classes/OpenID/Util.html#M000283","(s)","",2],["kv_to_seq","OpenID::Util","classes/OpenID/Util.html#M000280","(data, strict=false)","",2],["last_requested_endpoint","OpenID::Consumer","classes/OpenID/Consumer.html#M000154","()","",2],["last_requested_endpoint=","OpenID::Consumer","classes/OpenID/Consumer.html#M000155","(endpoint)","",2],["link_has_rel","OpenID","classes/OpenID.html#M000099","(link_attrs, target_rel)","",2],["load","OpenID::Consumer::DiscoveryManager","classes/OpenID/Consumer/DiscoveryManager.html#M000079","()","",2],["log","OpenID::Util","classes/OpenID/Util.html#M000475","(message)","change the message below to do whatever you like for logging ",2],["logger","OpenID::Util","classes/OpenID/Util.html#M000474","()","",2],["logger=","OpenID::Util","classes/OpenID/Util.html#M000473","(logger)","",2],["make_connection","OpenID::StandardFetcher","classes/OpenID/StandardFetcher.html#M000277","(uri)","",2],["make_filter","OpenID::Yadis","classes/OpenID/Yadis.html#M000494","(parts)","Convert a filter-convertable thing into a filter parts should be a filter, an endpoint, a callable, or",2],["make_http","OpenID::StandardFetcher","classes/OpenID/StandardFetcher.html#M000275","(uri)","",2],["make_kv_post","OpenID","classes/OpenID.html#M000287","(request_message, server_url)","Send the message to the server via HTTP POST and receive and parse a response in KV Form ",2],["make_pairs","OpenID::Association","classes/OpenID/Association.html#M000022","(message)","Generate the list of pairs that form the signed elements of the given message ",2],["make_xri","OpenID::Yadis::XRI","classes/OpenID/Yadis/XRI.html#M000529","(xri)","",2],["match_types","OpenID::Yadis","classes/OpenID/Yadis.html#M000477","(accept_types, have_types)","",2],["match_types","OpenID::Yadis::BasicServiceEndpoint","classes/OpenID/Yadis/BasicServiceEndpoint.html#M000482","(type_uris)","Query this endpoint to see if it has any of the given type URIs. This is useful for implementing other",2],["member?","OpenID::AX::FetchRequest","classes/OpenID/AX/FetchRequest.html#M000213","(type_uri)","",2],["member?","OpenID::NamespaceMap","classes/OpenID/NamespaceMap.html#M000326","(namespace_uri)","",2],["member?","OpenID::SReg::Request","classes/OpenID/SReg/Request.html#M000259","(field_name)","",2],["method_missing","OpenID::HTTPResponse","classes/OpenID/HTTPResponse.html#M000264","(method, *args)","",2],["mk_compound_filter","OpenID::Yadis","classes/OpenID/Yadis.html#M000495","(parts)","Create a filter out of a list of filter-like things Used by make_filter parts should be a list of things",2],["mk_nonce","OpenID::Nonce","classes/OpenID/Nonce.html#M000427","(time = nil)","generate a nonce with the specified timestamp (defaults to now) ",2],["mktemp","OpenID::Store::Filesystem","classes/OpenID/Store/Filesystem.html#M000357","()","Create a temporary file and return the File object and filename. ",2],["namespace","OpenID::Server::OpenIDRequest","classes/OpenID/Server/OpenIDRequest.html#M000317","()","",2],["namespace_uris","OpenID::NamespaceMap","classes/OpenID/NamespaceMap.html#M000329","()","",2],["needs_signing","OpenID::Server::OpenIDResponse","classes/OpenID/Server/OpenIDResponse.html#M000385","()","",2],["negotiate_association","OpenID::Consumer::AssociationManager","classes/OpenID/Consumer/AssociationManager.html#M000043","()","",2],["negotiator","OpenID::Consumer","classes/OpenID/Consumer.html#M000160","()","",2],["new","HMAC::Base","classes/HMAC/Base.html#M000000","(algorithm, block_size, output_length, key)","",2],["new","HMAC::SHA1","classes/HMAC/SHA1.html#M000011","(key = nil)","",2],["new","HMAC::SHA256","classes/HMAC/SHA256.html#M000012","(key = nil)","",2],["new","HMAC::SHA384","classes/HMAC/SHA384.html#M000013","(key = nil)","",2],["new","HMAC::SHA512","classes/HMAC/SHA512.html#M000014","(key = nil)","",2],["new","HTMLComment","classes/HTMLComment.html#M000511","(text)","",2],["new","HTMLTag","classes/HTMLTag.html#M000512","(text)","",2],["new","HTMLToken","classes/HTMLToken.html#M000505","(text)","Initialize the token based on the raw text ",2],["new","HTMLTokenizer","classes/HTMLTokenizer.html#M000497","(content)","Create a new tokenizer, based on the content, used as a string. ",2],["new","OpenID::AX::AXMessage","classes/OpenID/AX/AXMessage.html#M000191","()","",2],["new","OpenID::AX::AttrInfo","classes/OpenID/AX/AttrInfo.html#M000195","(type_uri, ns_alias=nil, required=false, count=1)","",2],["new","OpenID::AX::FetchRequest","classes/OpenID/AX/FetchRequest.html#M000205","(update_url = nil)","",2],["new","OpenID::AX::FetchResponse","classes/OpenID/AX/FetchResponse.html#M000233","(update_url = nil)","",2],["new","OpenID::AX::KeyValueMessage","classes/OpenID/AX/KeyValueMessage.html#M000215","()","",2],["new","OpenID::AX::StoreRequest","classes/OpenID/AX/StoreRequest.html#M000238","()","",2],["new","OpenID::AX::StoreResponse","classes/OpenID/AX/StoreResponse.html#M000241","(succeeded = true, error_message = nil)","",2],["new","OpenID::Association","classes/OpenID/Association.html#M000018","(handle, secret, issued, lifetime, assoc_type)","",2],["new","OpenID::AssociationNegotiator","classes/OpenID/AssociationNegotiator.html#M000032","(allowed_types)","",2],["new","OpenID::Consumer","classes/OpenID/Consumer.html#M000145","(session, store)","Initialize a Consumer instance. You should create a new instance of the Consumer object with every HTTP",2],["new","OpenID::Consumer::AssociationManager","classes/OpenID/Consumer/AssociationManager.html#M000041","(store, server_url, compatibility_mode=false, negotiator=nil)","",2],["new","OpenID::Consumer::CancelResponse","classes/OpenID/Consumer/CancelResponse.html#M000133","(endpoint)","",2],["new","OpenID::Consumer::CheckIDRequest","classes/OpenID/Consumer/CheckIDRequest.html#M000047","(assoc, endpoint)","Users of this library should not create instances of this class.  Instances of this class are created",2],["new","OpenID::Consumer::DiffieHellmanSession","classes/OpenID/Consumer/DiffieHellmanSession.html#M000027","(dh=nil)","",2],["new","OpenID::Consumer::DiscoveredServices","classes/OpenID/Consumer/DiscoveredServices.html#M000059","(starting_url, yadis_url, services)","",2],["new","OpenID::Consumer::DiscoveryManager","classes/OpenID/Consumer/DiscoveryManager.html#M000064","(session, url, session_key_suffix=nil)","",2],["new","OpenID::Consumer::FailureResponse","classes/OpenID/Consumer/FailureResponse.html#M000132","(endpoint, message, contact=nil, reference=nil)","",2],["new","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000113","(message, current_url, store=nil, endpoint=nil)","",2],["new","OpenID::Consumer::SetupNeededResponse","classes/OpenID/Consumer/SetupNeededResponse.html#M000134","(endpoint, setup_url)","",2],["new","OpenID::Consumer::SuccessResponse","classes/OpenID/Consumer/SuccessResponse.html#M000124","(endpoint, message, signed_fields)","",2],["new","OpenID::DiffieHellman","classes/OpenID/DiffieHellman.html#M000176","(modulus=nil, generator=nil, priv=nil)","",2],["new","OpenID::DiscoveryFailure","classes/OpenID/DiscoveryFailure.html#M000479","(message, http_response)","",2],["new","OpenID::Extension","classes/OpenID/Extension.html#M000187","()","",2],["new","OpenID::Message","classes/OpenID/Message.html#M000289","(openid_namespace=nil)","Raises InvalidNamespaceError if you try to instantiate a Message with a namespace not in the above allowed",2],["new","OpenID::NamespaceMap","classes/OpenID/NamespaceMap.html#M000318","()","",2],["new","OpenID::OAuth::Request","classes/OpenID/OAuth/Request.html#M000194","(consumer=nil, scope=nil)","",2],["new","OpenID::OAuth::Response","classes/OpenID/OAuth/Response.html#M000201","(request_token=nil, scope=nil)","",2],["new","OpenID::OpenIDServiceEndpoint","classes/OpenID/OpenIDServiceEndpoint.html#M000066","()","",2],["new","OpenID::PAPE::Request","classes/OpenID/PAPE/Request.html#M000214","(preferred_auth_policies=[], max_auth_age=nil)","",2],["new","OpenID::PAPE::Response","classes/OpenID/PAPE/Response.html#M000225","(auth_policies=[], auth_time=nil, nist_auth_level=nil)","",2],["new","OpenID::RealmVerificationRedirected","classes/OpenID/RealmVerificationRedirected.html#M000443","(relying_party_url, rp_url_after_redirects)","Attempting to verify this realm resulted in a redirect. ",2],["new","OpenID::SReg::Request","classes/OpenID/SReg/Request.html#M000248","(required = nil, optional = nil, policy_url = nil, ns_uri = NS_URI)","",2],["new","OpenID::SReg::Response","classes/OpenID/SReg/Response.html#M000260","(data = {}, ns_uri=NS_URI)","",2],["new","OpenID::Server::AssociateRequest","classes/OpenID/Server/AssociateRequest.html#M000342","(session, assoc_type)","Construct me. The session is assigned directly as a class attribute. See my class documentation for its",2],["new","OpenID::Server::BaseServerSession","classes/OpenID/Server/BaseServerSession.html#M000332","(session_type, allowed_assoc_types)","",2],["new","OpenID::Server::CheckAuthRequest","classes/OpenID/Server/CheckAuthRequest.html#M000320","(assoc_handle, signed, invalidate_handle=nil)","Construct me. These parameters are assigned directly as class attributes. Parameters: assoc_handle::",2],["new","OpenID::Server::CheckIDRequest","classes/OpenID/Server/CheckIDRequest.html#M000352","(identity, return_to, op_endpoint, trust_root=nil, immediate=false, assoc_handle=nil, claimed_id=nil)","These parameters are assigned directly as attributes, see the #CheckIDRequest class documentation for",2],["new","OpenID::Server::Decoder","classes/OpenID/Server/Decoder.html#M000420","(server)","Construct a Decoder. The server is necessary because some replies reference their server. ",2],["new","OpenID::Server::DiffieHellmanSHA1ServerSession","classes/OpenID/Server/DiffieHellmanSHA1ServerSession.html#M000337","(dh, consumer_pubkey)","",2],["new","OpenID::Server::DiffieHellmanSHA256ServerSession","classes/OpenID/Server/DiffieHellmanSHA256ServerSession.html#M000340","(*args)","",2],["new","OpenID::Server::EncodingError","classes/OpenID/Server/EncodingError.html#M000445","(response)","",2],["new","OpenID::Server::MalformedReturnURL","classes/OpenID/Server/MalformedReturnURL.html#M000449","(openid_message, return_to)","",2],["new","OpenID::Server::OpenIDRequest","classes/OpenID/Server/OpenIDRequest.html#M000316","()","I represent an incoming OpenID request. Attributes: mode:: The \"openid.mode\" of this request ",2],["new","OpenID::Server::OpenIDResponse","classes/OpenID/Server/OpenIDResponse.html#M000378","(request)","",2],["new","OpenID::Server::PlainTextServerSession","classes/OpenID/Server/PlainTextServerSession.html#M000334","()","",2],["new","OpenID::Server::ProtocolError","classes/OpenID/Server/ProtocolError.html#M000434","(message, text=nil, reference=nil, contact=nil)","text:: A message about the encountered error. ",2],["new","OpenID::Server::Server","classes/OpenID/Server/Server.html#M000428","(store, op_endpoint)","op_endpoint is new in library version 2.0. ",2],["new","OpenID::Server::Signatory","classes/OpenID/Server/Signatory.html#M000403","(store)","Create a new Signatory. store is The back-end where my associations are stored. ",2],["new","OpenID::Server::SigningEncoder","classes/OpenID/Server/SigningEncoder.html#M000418","(signatory)","Create a SigningEncoder given a Signatory ",2],["new","OpenID::Server::UntrustedReturnURL","classes/OpenID/Server/UntrustedReturnURL.html#M000447","(message, return_to, trust_root)","",2],["new","OpenID::Server::WebResponse","classes/OpenID/Server/WebResponse.html#M000396","(code=HTTP_OK, headers=nil, body=\"\")","",2],["new","OpenID::ServerError","classes/OpenID/ServerError.html#M000284","(error_text, error_code, message)","",2],["new","OpenID::StandardFetcher","classes/OpenID/StandardFetcher.html#M000273","(proxy_addr=nil, proxy_port=nil, proxy_user=nil, proxy_pass=nil)","I can fetch through a HTTP proxy; arguments are as for Net::HTTP::Proxy. ",2],["new","OpenID::Store::Filesystem","classes/OpenID/Store/Filesystem.html#M000341","(directory)","Create a Filesystem store instance, putting all data in +directory+. ",2],["new","OpenID::Store::Memcache","classes/OpenID/Store/Memcache.html#M000376","(cache_client, key_prefix='openid-store:')","",2],["new","OpenID::Store::Memory","classes/OpenID/Store/Memory.html#M000407","()","",2],["new","OpenID::TrustRoot::TrustRoot","classes/OpenID/TrustRoot/TrustRoot.html#M000461","(unparsed, proto, wildcard, host, port, path)","",2],["new","OpenID::TypeURIMismatch","classes/OpenID/TypeURIMismatch.html#M000108","(type_uri, endpoint)","",2],["new","OpenID::Yadis::BasicServiceEndpoint","classes/OpenID/Yadis/BasicServiceEndpoint.html#M000480","(yadis_url, type_uris, uri, service_element)","Generic endpoint object that contains parsed service information, as well as a reference to the service",2],["new","OpenID::Yadis::CompoundFilter","classes/OpenID/Yadis/CompoundFilter.html#M000492","(subfilters)","Create a new filter that applies a set of filters to an endpoint and collects their results. ",2],["new","OpenID::Yadis::DiscoveryResult","classes/OpenID/Yadis/DiscoveryResult.html#M000481","(request_uri)","",2],["new","OpenID::Yadis::TransformFilterMaker","classes/OpenID/Yadis/TransformFilterMaker.html#M000488","(filter_procs)","Initialize the filter maker's state filter_functions are the endpoint transformer Procs to apply to the",2],["new","OpenID::Yadis::XRI::ProxyResolver","classes/OpenID/Yadis/XRI/ProxyResolver.html#M000533","(proxy_url=nil)","",2],["new_args","OpenID::AX::AXMessage","classes/OpenID/AX/AXMessage.html#M000193","()","",2],["next","OpenID::Consumer::DiscoveredServices","classes/OpenID/Consumer/DiscoveredServices.html#M000060","()","",2],["normalize_url","OpenID","classes/OpenID.html#M000095","(url)","",2],["normalize_xri","OpenID","classes/OpenID.html#M000094","(xri)","",2],["num_to_base64","OpenID::CryptUtil","classes/OpenID/CryptUtil.html#M000180","(l)","Encode a number as a base64-encoded byte string. ",2],["num_to_binary","OpenID::CryptUtil","classes/OpenID/CryptUtil.html#M000174","(n)","Convert a number to its binary representation; return a string of bytes. ",2],["openid1_return_to_claimed_id_name","OpenID::Consumer","classes/OpenID/Consumer.html#M000112","()","See openid1_return_to_claimed_id_name= ",2],["openid1_return_to_claimed_id_name=","OpenID::Consumer","classes/OpenID/Consumer.html#M000111","(query_arg_name)","Set the name of the query parameter that this library will use to thread the requested URL through an",2],["openid1_return_to_nonce_name","OpenID::Consumer","classes/OpenID/Consumer.html#M000110","()","See openid1_return_to_nonce_name= documentation ",2],["openid1_return_to_nonce_name=","OpenID::Consumer","classes/OpenID/Consumer.html#M000109","(query_arg_name)","Set the name of the query parameter that this library will use to thread a nonce through an OpenID 1",2],["openid_associate","OpenID::Server::Server","classes/OpenID/Server/Server.html#M000431","(request)","Handle and respond to associate requests. ",2],["openid_check_authentication","OpenID::Server::Server","classes/OpenID/Server/Server.html#M000430","(request)","Handle and respond to check_authentication requests. ",2],["openid_namespace","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000117","()","",2],["openid_unescape","OpenID","classes/OpenID.html#M000091","(s)","",2],["parse","OpenID::TrustRoot::TrustRoot","classes/OpenID/TrustRoot/TrustRoot.html#M000455","(trust_root)","",2],["parseXRDS","OpenID::Yadis","classes/OpenID/Yadis.html#M000524","(text)","",2],["parse_accept_header","OpenID::Yadis","classes/OpenID/Yadis.html#M000472","(value)","",2],["parse_extension_args","OpenID::AX::FetchRequest","classes/OpenID/AX/FetchRequest.html#M000210","(ax_args)","",2],["parse_extension_args","OpenID::AX::FetchResponse","classes/OpenID/AX/FetchResponse.html#M000236","(ax_args)","",2],["parse_extension_args","OpenID::AX::KeyValueMessage","classes/OpenID/AX/KeyValueMessage.html#M000222","(ax_args)","Parse attribute exchange key/value arguments into this object. ",2],["parse_extension_args","OpenID::OAuth::Request","classes/OpenID/OAuth/Request.html#M000200","(args)","Set the state of this request to be that expressed in these OAuth arguments ",2],["parse_extension_args","OpenID::OAuth::Response","classes/OpenID/OAuth/Response.html#M000203","(args, strict=false)","parse the oauth request arguments into the internal state of this object if strict is specified, raise",2],["parse_extension_args","OpenID::PAPE::Request","classes/OpenID/PAPE/Request.html#M000223","(args)","Set the state of this request to be that expressed in these PAPE arguments ",2],["parse_extension_args","OpenID::PAPE::Response","classes/OpenID/PAPE/Response.html#M000230","(args, strict=false)","parse the provider authentication policy arguments into the internal state of this object if strict is",2],["parse_extension_args","OpenID::SReg::Request","classes/OpenID/SReg/Request.html#M000252","(args, strict = false)","Parse the unqualified simple registration request parameters and add them to this object. This method",2],["parse_link_attrs","OpenID","classes/OpenID.html#M000093","(html)","",2],["parse_query","OpenID::Util","classes/OpenID/Util.html#M000470","(qs)","",2],["parse_service","OpenID::OpenIDServiceEndpoint","classes/OpenID/OpenIDServiceEndpoint.html#M000082","(yadis_url, uri, type_uris, service_element)","",2],["peekNextToken","HTMLTokenizer","classes/HTMLTokenizer.html#M000499","()","Look at the next token, but don't actually grab it ",2],["post_connection_check","Net::HTTP","classes/Net/HTTP.html#M000257","(hostname)","",2],["powermod","OpenID::DiffieHellman","classes/OpenID/DiffieHellman.html#M000186","(x, n, q)","This code is taken from this post: <http://blade.nagaokaut.ac.jp/cgi-bin/scat.\\rb/ruby/ruby-talk/19098>",2],["preferred_namespace","OpenID::OpenIDServiceEndpoint","classes/OpenID/OpenIDServiceEndpoint.html#M000073","()","",2],["preferred_types","OpenID::PAPE::Request","classes/OpenID/PAPE/Request.html#M000224","(supported_types)","Given a list of authentication policy URIs that a provider supports, this method returns the subset of",2],["prio_sort","OpenID::Yadis","classes/OpenID/Yadis.html#M000532","(elements)","Sort a list of elements that have priority attributes. ",2],["process_check_auth_response","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000139","(response)","Process the response message from a check_authentication request, invalidating associations if requested.",2],["provider_is_authoritative","OpenID::Yadis::XRI","classes/OpenID/Yadis/XRI.html#M000523","(provider_id, canonical_id)","",2],["query","OpenID::Yadis::XRI::ProxyResolver","classes/OpenID/Yadis/XRI/ProxyResolver.html#M000535","(xri)","",2],["query_url","OpenID::Yadis::XRI::ProxyResolver","classes/OpenID/Yadis/XRI/ProxyResolver.html#M000534","(xri, service_type=nil)","",2],["rand","OpenID::CryptUtil","classes/OpenID/CryptUtil.html#M000168","(max)","Generate a random number, doing a little extra work to make it more likely that it's suitable for cryptography.",2],["random_string","OpenID::CryptUtil","classes/OpenID/CryptUtil.html#M000173","(length, chars=nil)","Generate a random string of the given length, composed of the specified characters.  If chars is nil,",2],["redirect_url","OpenID::Consumer::CheckIDRequest","classes/OpenID/Consumer/CheckIDRequest.html#M000055","(realm, return_to=nil, immediate=false)","Returns a URL with an encoded OpenID request. The resulting URL is the OpenID provider's endpoint URL",2],["register_namespace_alias","OpenID::Message","classes/OpenID/Message.html#M000288","(namespace_uri, alias_)","Registers a (namespace URI, alias) mapping in a global namespace alias map.  Raises NamespaceAliasRegistrationError",2],["rel_matches","OpenID","classes/OpenID.html#M000096","(rel_attr, target_rel)","",2],["remove_association","OpenID::Store::Filesystem","classes/OpenID/Store/Filesystem.html#M000350","(server_url, handle)","Remove an association if it exists, otherwise do nothing. ",2],["remove_association","OpenID::Store::Interface","classes/OpenID/Store/Interface.html#M000368","(server_url, handle)","If there is a matching association, remove it from the store and return true, otherwise return false.",2],["remove_association","OpenID::Store::Memcache","classes/OpenID/Store/Memcache.html#M000380","(server_url, handle)","If there is a matching association, remove it from the store and return true, otherwise return false.",2],["remove_association","OpenID::Store::Memory","classes/OpenID/Store/Memory.html#M000411","(server_url, handle)","",2],["remove_dot_segments","OpenID::URINorm","classes/OpenID/URINorm.html#M000462","(path)","",2],["remove_if_present","OpenID::Store::Filesystem","classes/OpenID/Store/Filesystem.html#M000360","(filename)","remove file if present in filesystem ",2],["render_as_form","OpenID::Server::OpenIDResponse","classes/OpenID/Server/OpenIDResponse.html#M000384","()","",2],["request_association","OpenID::Consumer::AssociationManager","classes/OpenID/Consumer/AssociationManager.html#M000045","(assoc_type, session_type)","Make and process one association request to this endpoint's OP endpoint URL. Returns an association object",2],["request_field","OpenID::SReg::Request","classes/OpenID/SReg/Request.html#M000255","(field_name, required=false, strict=false)","Request the specified field from the OpenID user field_name: the unqualified simple registration field",2],["request_fields","OpenID::SReg::Request","classes/OpenID/SReg/Request.html#M000256","(field_names, required = false, strict = false)","Add the given list of fields to the request. ",2],["requested_types","OpenID::AX::FetchRequest","classes/OpenID/AX/FetchRequest.html#M000212","()","return the list of requested attribute type URIs ",2],["reserved","OpenID::URINorm","classes/OpenID/URINorm.html#M000460","(chr)","",2],["reset","HTMLTokenizer","classes/HTMLTokenizer.html#M000498","()","Reset the parser, setting the current position back at the stop ",2],["reset_key","HMAC::Base","classes/HMAC/Base.html#M000003","()","",2],["return_to_matches","OpenID::TrustRoot","classes/OpenID/TrustRoot.html#M000450","(allowed_return_to_urls, return_to)","Is the return_to URL under one of the supplied allowed return_to URLs? ",2],["return_to_verified","OpenID::Server::CheckIDRequest","classes/OpenID/Server/CheckIDRequest.html#M000364","()","Does the relying party publish the return_to URL for this response under the realm? It is up to the provider",2],["root_authority","OpenID::Yadis::XRI","classes/OpenID/Yadis/XRI.html#M000525","(xri)","",2],["safe64","OpenID::Store::Filesystem","classes/OpenID/Store/Filesystem.html#M000359","(s)","",2],["sane?","OpenID::TrustRoot::TrustRoot","classes/OpenID/TrustRoot/TrustRoot.html#M000463","()","",2],["send_redirect?","OpenID::Consumer::CheckIDRequest","classes/OpenID/Consumer/CheckIDRequest.html#M000058","(realm, return_to=nil, immediate=false)","Should this OpenID authentication request be sent as a HTTP redirect or as a POST (form submission)?",2],["seq_to_kv","OpenID::Util","classes/OpenID/Util.html#M000278","(seq, strict=false)","",2],["serialize","OpenID::Association","classes/OpenID/Association.html#M000019","()","Serialize the association to a form that's consistent across JanRain OpenID libraries. ",2],["serialize","OpenID::Store::Memcache","classes/OpenID/Store/Memcache.html#M000398","(assoc)","",2],["server_url","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000116","()","",2],["services","OpenID::Yadis","classes/OpenID/Yadis.html#M000530","(xrds_tree)","",2],["session_get","OpenID::Consumer","classes/OpenID/Consumer.html#M000151","(name)","",2],["session_key","OpenID::Consumer","classes/OpenID/Consumer.html#M000153","(suffix)","",2],["session_key","OpenID::Consumer::DiscoveryManager","classes/OpenID/Consumer/DiscoveryManager.html#M000077","()","",2],["session_set","OpenID::Consumer","classes/OpenID/Consumer.html#M000152","(name, val)","",2],["set_arg","OpenID::Message","classes/OpenID/Message.html#M000312","(namespace, key, value)","Set a single argument in this namespace ",2],["set_key","HMAC::Base","classes/HMAC/Base.html#M000002","(key)","",2],["set_openid_namespace","OpenID::Message","classes/OpenID/Message.html#M000294","(openid_ns_uri, implicit)","",2],["set_private","OpenID::DiffieHellman","classes/OpenID/DiffieHellman.html#M000184","(priv)","",2],["set_values","OpenID::AX::KeyValueMessage","classes/OpenID/AX/KeyValueMessage.html#M000217","(type_uri, values)","Set the values for the given attribute type. This replaces any values that have already been set for",2],["set_verified","OpenID::StandardFetcher","classes/OpenID/StandardFetcher.html#M000276","(conn, verify)","",2],["setup_encoding","OpenID::StandardFetcher","classes/OpenID/StandardFetcher.html#M000281","(response)","",2],["sha1","OpenID::CryptUtil","classes/OpenID/CryptUtil.html#M000169","(text)","",2],["sha256","OpenID::CryptUtil","classes/OpenID/CryptUtil.html#M000171","(text)","",2],["sign","OpenID::Association","classes/OpenID/Association.html#M000021","(pairs)","Generate a signature for a sequence of [key, value] pairs ",2],["sign","OpenID::Server::Signatory","classes/OpenID/Server/Signatory.html#M000405","(response)","Sign a response. I take an OpenIDResponse, create a signature for everything in its signed list, and",2],["sign_message","OpenID::Association","classes/OpenID/Association.html#M000026","(message)","Add a signature (and a signed list) to a message. ",2],["signed?","OpenID::Consumer::SuccessResponse","classes/OpenID/Consumer/SuccessResponse.html#M000127","(ns_uri, ns_key)","Return whether a particular key is signed, regardless of its namespace alias ",2],["signed_fields","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000114","()","",2],["signed_list","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000119","()","",2],["skew","OpenID::Nonce","classes/OpenID/Nonce.html#M000421","()","The allowed nonce time skew in seconds.  Defaults to 5 hours. Used for checking nonce validity, and by",2],["skew=","OpenID::Nonce","classes/OpenID/Nonce.html#M000422","(new_skew)","",2],["split_nonce","OpenID::Nonce","classes/OpenID/Nonce.html#M000423","(nonce_str)","Extract timestamp from a nonce string ",2],["started?","OpenID::Consumer::DiscoveredServices","classes/OpenID/Consumer/DiscoveredServices.html#M000062","()","",2],["starts_with?","String","classes/String.html#M000249","(other)","",2],["status","OpenID::Consumer::Response","classes/OpenID/Consumer/Response.html#M000120","()","",2],["store","OpenID::Consumer::DiscoveryManager","classes/OpenID/Consumer/DiscoveryManager.html#M000078","(manager)","",2],["store_association","OpenID::Store::Filesystem","classes/OpenID/Store/Filesystem.html#M000345","(server_url, association)","Store an association in the assoc directory ",2],["store_association","OpenID::Store::Interface","classes/OpenID/Store/Interface.html#M000366","(server_url, association)","Put a Association object into storage. When implementing a store, don't assume that there are any limitations",2],["store_association","OpenID::Store::Memcache","classes/OpenID/Store/Memcache.html#M000377","(server_url, association)","Put a Association object into storage. When implementing a store, don't assume that there are any limitations",2],["store_association","OpenID::Store::Memory","classes/OpenID/Store/Memory.html#M000408","(server_url, assoc)","",2],["strxor","OpenID::DiffieHellman","classes/OpenID/DiffieHellman.html#M000185","(s, t)","",2],["succeeded?","OpenID::AX::StoreResponse","classes/OpenID/AX/StoreResponse.html#M000243","()","",2],["supports_sreg?","OpenID","classes/OpenID.html#M000246","(endpoint)","Does the given endpoint advertise support for simple registration? ",2],["supports_ssl?","OpenID::StandardFetcher","classes/OpenID/StandardFetcher.html#M000274","(conn)","",2],["supports_type","OpenID::OpenIDServiceEndpoint","classes/OpenID/OpenIDServiceEndpoint.html#M000074","(type_uri)","",2],["text","HTMLTag","classes/HTMLTag.html#M000516","()","Get the 'alt' text for a tag, if it exists, or an empty string otherwise ",2],["text","HTMLText","classes/HTMLText.html#M000510","()","",2],["text","HTMLToken","classes/HTMLToken.html#M000507","()","By default tokens have no text representation ",2],["to_args","OpenID::Message","classes/OpenID/Message.html#M000301","()","Return all namespaced arguments, failing if any non-namespaced arguments exist. ",2],["to_base64","OpenID::Util","classes/OpenID/Util.html#M000466","(s)","",2],["to_form_markup","OpenID::Message","classes/OpenID/Message.html#M000302","(action_url, form_tag_attrs=nil, submit_text='Continue')","Generate HTML form markup that contains the values in this message, to be HTTP POSTed as x-www-form-urlencoded",2],["to_form_markup","OpenID::Server::OpenIDResponse","classes/OpenID/Server/OpenIDResponse.html#M000382","(form_tag_attrs=nil)","form_tag_attrs is a hash of attributes to be added to the form tag. 'accept-charset' and 'enctype' have",2],["to_form_markup","OpenID::Server::ProtocolError","classes/OpenID/Server/ProtocolError.html#M000440","()","",2],["to_html","OpenID::Server::OpenIDResponse","classes/OpenID/Server/OpenIDResponse.html#M000383","(form_tag_attrs=nil)","Wraps the form tag from to_form_markup in a complete HTML document that uses javascript to autosubmit",2],["to_html","OpenID::Server::ProtocolError","classes/OpenID/Server/ProtocolError.html#M000441","()","",2],["to_iri_normal","OpenID::Yadis::XRI","classes/OpenID/Yadis/XRI.html#M000519","(xri)","Transform an XRI reference to an IRI reference.  Note this is not not idempotent, so do not apply this",2],["to_kvform","OpenID::Message","classes/OpenID/Message.html#M000304","()","Generate a KVForm string that contains the parameters in this message. This will fail is the message",2],["to_message","OpenID::Extension","classes/OpenID/Extension.html#M000189","(message = nil)","Add the arguments from this extension to the provided message, or create a new message containing only",2],["to_message","OpenID::Server::ProtocolError","classes/OpenID/Server/ProtocolError.html#M000437","()","Generate a Message object for sending to the relying party, after encoding. ",2],["to_post_args","OpenID::Message","classes/OpenID/Message.html#M000300","()","Return all arguments with \"openid.\" in from of namespaced arguments. ",2],["to_s","HMAC::Base","classes/HMAC/Base.html#M000008","()","Alias for #hexdigest",2],["to_s","HTMLToken","classes/HTMLToken.html#M000506","()","By default, return exactly the string used to create the text ",2],["to_s","OpenID::OpenIDServiceEndpoint","classes/OpenID/OpenIDServiceEndpoint.html#M000089","()","",2],["to_s","OpenID::RealmVerificationRedirected","classes/OpenID/RealmVerificationRedirected.html#M000444","()","",2],["to_s","OpenID::Server::CheckAuthRequest","classes/OpenID/Server/CheckAuthRequest.html#M000328","()","",2],["to_s","OpenID::Server::CheckIDRequest","classes/OpenID/Server/CheckIDRequest.html#M000375","()","",2],["to_s","OpenID::Server::OpenIDResponse","classes/OpenID/Server/OpenIDResponse.html#M000381","()","",2],["to_s","OpenID::Server::UntrustedReturnURL","classes/OpenID/Server/UntrustedReturnURL.html#M000448","()","",2],["to_type_uris","OpenID::AX","classes/OpenID/AX.html#M000199","(namespace_map, alias_list_s)","Given a namespace mapping and a string containing a comma-separated list of namespace aliases, return",2],["to_uri_normal","OpenID::Yadis::XRI","classes/OpenID/Yadis/XRI.html#M000521","(xri)","Transform an XRI reference to a URI reference.  Note this is not not idempotent, so do not apply this",2],["to_url","OpenID::Message","classes/OpenID/Message.html#M000303","(base_url)","Generate a GET URL with the paramters in this message attacked as query parameters. ",2],["to_url_encoded","OpenID::Message","classes/OpenID/Message.html#M000305","()","Generate an x-www-urlencoded string. ",2],["trimmed_text","HTMLToken","classes/HTMLToken.html#M000508","()","",2],["trust_root_valid","OpenID::Server::CheckIDRequest","classes/OpenID/Server/CheckIDRequest.html#M000363","()","Is my return_to under my trust_root? ",2],["unescape_hash","OpenID","classes/OpenID.html#M000092","(h)","",2],["update","HMAC::Base","classes/HMAC/Base.html#M000004","(text)","",2],["update_args","OpenID::Message","classes/OpenID/Message.html#M000311","(namespace, updates)","Set multiple key/value pairs in one call. ",2],["urinorm","OpenID::URINorm","classes/OpenID/URINorm.html#M000457","(uri)","",2],["urlencode","OpenID::Util","classes/OpenID/Util.html#M000468","(args)","",2],["urlencode","OpenID::Yadis::XRI","classes/OpenID/Yadis/XRI.html#M000536","(args)","",2],["use_nonce","OpenID::Store::Filesystem","classes/OpenID/Store/Filesystem.html#M000351","(server_url, timestamp, salt)","Return whether the nonce is valid ",2],["use_nonce","OpenID::Store::Interface","classes/OpenID/Store/Interface.html#M000369","(server_url, timestamp, salt)","Return true if the nonce has not been used before, and store it for a while to make sure someone doesn't",2],["use_nonce","OpenID::Store::Memcache","classes/OpenID/Store/Memcache.html#M000388","(server_url, timestamp, salt)","Return true if the nonce has not been used before, and store it for a while to make sure someone doesn't",2],["use_nonce","OpenID::Store::Memory","classes/OpenID/Store/Memory.html#M000413","(server_url, timestamp, salt)","",2],["used_yadis_location?","OpenID::Yadis::DiscoveryResult","classes/OpenID/Yadis/DiscoveryResult.html#M000485","()","Was the Yadis protocol's indirection used? ",2],["uses_extension","OpenID::OpenIDServiceEndpoint","classes/OpenID/OpenIDServiceEndpoint.html#M000070","(extension_uri)","",2],["using_default_values?","OpenID::DiffieHellman","classes/OpenID/DiffieHellman.html#M000183","()","",2],["validate_url","OpenID::TrustRoot::TrustRoot","classes/OpenID/TrustRoot/TrustRoot.html#M000464","(url)","",2],["verify","OpenID::Server::Signatory","classes/OpenID/Server/Signatory.html#M000404","(assoc_handle, message)","Verify that the signature for some data is valid. ",2],["verify_discovered_services","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000146","(claimed_id, services, to_match_endpoints)","",2],["verify_discovery_results","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000141","()","",2],["verify_discovery_results_openid1","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000143","()","",2],["verify_discovery_results_openid2","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000142","()","",2],["verify_discovery_single","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000148","(endpoint, to_match)","",2],["verify_return_to","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000125","()","",2],["verify_return_to","OpenID::TrustRoot","classes/OpenID/TrustRoot.html#M000452","(realm_str, return_to, _vrfy=nil)","Verify that a return_to URL is valid for the given realm. This function builds a discovery URL, performs",2],["verify_return_to_args","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000129","(msg_return_to)","",2],["verify_return_to_base","OpenID::Consumer::IdResHandler","classes/OpenID/Consumer/IdResHandler.html#M000135","(msg_return_to)","",2],["version","HTMLTokenizer","classes/HTMLTokenizer.html#M000496","()","Get version of HTMLTokenizer lib ",2],["wants_unlimited_values?","OpenID::AX::AttrInfo","classes/OpenID/AX/AttrInfo.html#M000196","()","",2],["were_fields_requested?","OpenID::SReg::Request","classes/OpenID/SReg/Request.html#M000254","()","Have any simple registration fields been requested? ",2],["where_is_yadis?","OpenID::Yadis","classes/OpenID/Yadis.html#M000491","(resp)","Given a HTTPResponse, return the location of the Yadis document. May be the URL just retrieved, another",2],["which_encoding","OpenID::Server::OpenIDResponse","classes/OpenID/Server/OpenIDResponse.html#M000386","()","implements IEncodable ",2],["which_encoding","OpenID::Server::ProtocolError","classes/OpenID/Server/ProtocolError.html#M000442","()","How should I be encoded? Returns one of ENCODE_URL, ENCODE_KVFORM, or None.  If None, I cannot be encoded",2],["xor_secret","OpenID::DiffieHellman","classes/OpenID/DiffieHellman.html#M000179","(algorithm, composite, secret)","",2],["CHANGELOG","files/CHANGELOG.html","files/CHANGELOG.html","","Mon Jan 23 12:48:00 PST 2006  brian@janrain.com   * fixed bug in expiresIn.  added expired? method  ",3],["INSTALL","files/INSTALL.html","files/INSTALL.html","","= Ruby OpenID Library Installation  == Rubygems Installation  Rubygems is a tool for installing ruby",3],["LICENSE","files/LICENSE.html","files/LICENSE.html","","The code in lib/hmac/ is Copyright 2001 by Daiki Ueno, and distributed under the terms of the Ruby license.",3],["README","files/README.html","files/README.html","","=Ruby OpenID  A Ruby library for verifying and serving OpenID identities.  ==Features * Easy to use API",3],["UPGRADE","files/UPGRADE.html","files/UPGRADE.html","","= Upgrading from the OpenID 1.x series library  == Consumer Upgrade  The flow is largely the same, however",3],["hmac.rb","files/lib/hmac/hmac_rb.html","files/lib/hmac/hmac_rb.html","","Copyright (C) 2001  Daiki Ueno <ueno@unixuser.org> This library is distributed under the terms of the",3],["sha1.rb","files/lib/hmac/sha1_rb.html","files/lib/hmac/sha1_rb.html","","",3],["sha2.rb","files/lib/hmac/sha2_rb.html","files/lib/hmac/sha2_rb.html","","",3],["openid.rb","files/lib/openid_rb.html","files/lib/openid_rb.html","","Copyright 2006-2007 JanRain, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you",3],["association.rb","files/lib/openid/association_rb.html","files/lib/openid/association_rb.html","","",3],["consumer.rb","files/lib/openid/consumer_rb.html","files/lib/openid/consumer_rb.html","","",3],["associationmanager.rb","files/lib/openid/consumer/associationmanager_rb.html","files/lib/openid/consumer/associationmanager_rb.html","","",3],["checkid_request.rb","files/lib/openid/consumer/checkid_request_rb.html","files/lib/openid/consumer/checkid_request_rb.html","","",3],["discovery.rb","files/lib/openid/consumer/discovery_rb.html","files/lib/openid/consumer/discovery_rb.html","","Functions to discover OpenID endpoints from identifiers. ",3],["discovery_manager.rb","files/lib/openid/consumer/discovery_manager_rb.html","files/lib/openid/consumer/discovery_manager_rb.html","","",3],["html_parse.rb","files/lib/openid/consumer/html_parse_rb.html","files/lib/openid/consumer/html_parse_rb.html","","",3],["idres.rb","files/lib/openid/consumer/idres_rb.html","files/lib/openid/consumer/idres_rb.html","","",3],["responses.rb","files/lib/openid/consumer/responses_rb.html","files/lib/openid/consumer/responses_rb.html","","",3],["cryptutil.rb","files/lib/openid/cryptutil_rb.html","files/lib/openid/cryptutil_rb.html","","",3],["dh.rb","files/lib/openid/dh_rb.html","files/lib/openid/dh_rb.html","","",3],["extension.rb","files/lib/openid/extension_rb.html","files/lib/openid/extension_rb.html","","",3],["ax.rb","files/lib/openid/extensions/ax_rb.html","files/lib/openid/extensions/ax_rb.html","","Implements the OpenID attribute exchange specification, version 1.0 ",3],["oauth.rb","files/lib/openid/extensions/oauth_rb.html","files/lib/openid/extensions/oauth_rb.html","","An implementation of the OpenID OAuth Extension Extension 1.0 see: http://openid.net/specs/ ",3],["pape.rb","files/lib/openid/extensions/pape_rb.html","files/lib/openid/extensions/pape_rb.html","","An implementation of the OpenID Provider Authentication Policy Extension 1.0 see: http://openid.net/specs/",3],["sreg.rb","files/lib/openid/extensions/sreg_rb.html","files/lib/openid/extensions/sreg_rb.html","","",3],["extras.rb","files/lib/openid/extras_rb.html","files/lib/openid/extras_rb.html","","",3],["fetchers.rb","files/lib/openid/fetchers_rb.html","files/lib/openid/fetchers_rb.html","","",3],["kvform.rb","files/lib/openid/kvform_rb.html","files/lib/openid/kvform_rb.html","","",3],["kvpost.rb","files/lib/openid/kvpost_rb.html","files/lib/openid/kvpost_rb.html","","",3],["message.rb","files/lib/openid/message_rb.html","files/lib/openid/message_rb.html","","",3],["protocolerror.rb","files/lib/openid/protocolerror_rb.html","files/lib/openid/protocolerror_rb.html","","",3],["server.rb","files/lib/openid/server_rb.html","files/lib/openid/server_rb.html","","",3],["filesystem.rb","files/lib/openid/store/filesystem_rb.html","files/lib/openid/store/filesystem_rb.html","","",3],["interface.rb","files/lib/openid/store/interface_rb.html","files/lib/openid/store/interface_rb.html","","",3],["memcache.rb","files/lib/openid/store/memcache_rb.html","files/lib/openid/store/memcache_rb.html","","",3],["memory.rb","files/lib/openid/store/memory_rb.html","files/lib/openid/store/memory_rb.html","","",3],["nonce.rb","files/lib/openid/store/nonce_rb.html","files/lib/openid/store/nonce_rb.html","","",3],["trustroot.rb","files/lib/openid/trustroot_rb.html","files/lib/openid/trustroot_rb.html","","",3],["urinorm.rb","files/lib/openid/urinorm_rb.html","files/lib/openid/urinorm_rb.html","","",3],["util.rb","files/lib/openid/util_rb.html","files/lib/openid/util_rb.html","","",3],["accept.rb","files/lib/openid/yadis/accept_rb.html","files/lib/openid/yadis/accept_rb.html","","",3],["constants.rb","files/lib/openid/yadis/constants_rb.html","files/lib/openid/yadis/constants_rb.html","","",3],["discovery.rb","files/lib/openid/yadis/discovery_rb.html","files/lib/openid/yadis/discovery_rb.html","","",3],["filters.rb","files/lib/openid/yadis/filters_rb.html","files/lib/openid/yadis/filters_rb.html","","This file contains functions and classes used for extracting endpoint information out of a Yadis XRD",3],["htmltokenizer.rb","files/lib/openid/yadis/htmltokenizer_rb.html","files/lib/openid/yadis/htmltokenizer_rb.html","","= HTMLTokenizer Author::    Ben Giddings  (mailto:bg-rubyforge@infofiend.com) Copyright:: Copyright (c)",3],["parsehtml.rb","files/lib/openid/yadis/parsehtml_rb.html","files/lib/openid/yadis/parsehtml_rb.html","","",3],["services.rb","files/lib/openid/yadis/services_rb.html","files/lib/openid/yadis/services_rb.html","","",3],["xrds.rb","files/lib/openid/yadis/xrds_rb.html","files/lib/openid/yadis/xrds_rb.html","","",3],["xri.rb","files/lib/openid/yadis/xri_rb.html","files/lib/openid/yadis/xri_rb.html","","",3],["xrires.rb","files/lib/openid/yadis/xrires_rb.html","files/lib/openid/yadis/xrires_rb.html","","",3]],"searchIndex":["hmac","base","sha1","sha256","sha384","sha512","htmlcomment","htmltag","htmltext","htmltoken","htmltokenizer","htmltokenizererror","net","http","openid","ax","axmessage","attrinfo","error","fetchrequest","fetchresponse","keyvaluemessage","storerequest","storeresponse","assertionerror","association","associationnegotiator","consumer","associationmanager","cancelresponse","checkidrequest","diffiehellmansha1session","diffiehellmansha256session","diffiehellmansession","discoveredservices","discoverymanager","failureresponse","idreshandler","noencryptionsession","response","setupneededresponse","successresponse","cryptutil","diffiehellman","discoveryfailure","extension","fetchingerror","httpredirectlimitreached","httpresponse","httpstatuserror","invalidopenidnamespace","kvformerror","kvpostnetworkerror","message","keynotfound","namespacealiasregistrationerror","namespacemap","nonce","oauth","request","response","openiderror","openidserviceendpoint","pape","request","response","protocolerror","realmverificationredirected","sreg","namespaceerror","request","response","sslfetchingerror","server","alreadysigned","associaterequest","baseserversession","checkauthrequest","checkidrequest","decoder","diffiehellmansha1serversession","diffiehellmansha256serversession","encoder","encodingerror","malformedreturnurl","malformedtrustroot","noreturntoerror","openidrequest","openidresponse","plaintextserversession","protocolerror","server","signatory","signingencoder","untrustedreturnurl","versionerror","webresponse","servererror","standardfetcher","store","filesystem","interface","memcache","memory","trustroot","trustroot","typeurimismatch","urinorm","undefinedopenidnamespace","util","yadis","basicserviceendpoint","compoundfilter","discoveryresult","transformfiltermaker","xrdserror","xrdsfraud","xri","proxyresolver","xrihttperror","string","<<()","==()","==()","==()","[]()","[]()","_build_path()","_dumb_key()","_extract_return_url()","_fix_ns()","_from_net_response()","_from_openid_args()","_get_association()","_get_default_namespace()","_get_extension_kv_args()","_normal_key()","_parse_url()","add()","add()","add_alias()","add_allowed_type()","add_extension()","add_extension()","add_extension_arg()","add_policy_uri()","add_policy_uri()","add_value()","aliases()","all_requested_fields()","allowed?()","allowed_assoc_type?()","allowed_types=()","anonymous=()","answer()","answer()","answer()","answer()","answer()","answer_unsupported()","append_args()","append_args()","apply_filter()","apply_filters()","arrange_by_type()","assert()","assoc_key()","association_manager()","attr_hash()","attributes()","auto_submit_html()","base64_to_num()","begin()","begin_without_discovery()","best_matching_service()","binary_to_num()","body=()","build_discovery_url()","cancel_url()","check_alias()","check_auth()","check_for_fields()","check_message_signature()","check_mode()","check_nonce()","check_sanity()","check_session_type()","check_signature()","check_sreg_field_name()","check_status()","check_timestamp()","check_url()","cleanup()","cleanup()","cleanup()","cleanup()","cleanup_associations()","cleanup_associations()","cleanup_associations()","cleanup_associations()","cleanup_last_requested_endpoint()","cleanup_nonces()","cleanup_nonces()","cleanup_nonces()","cleanup_nonces()","cleanup_session()","compatibility_mode()","complete()","complete_cancel()","complete_error()","complete_id_res()","complete_invalid()","complete_setup_needed()","const_eq()","copy()","copy()","copy()","count()","create_associate_request()","create_association()","create_check_auth_request()","create_manager()","create_session()","decode()","decode_request()","deepcopy()","default_decoder()","del_arg()","delete()","deserialize()","deserialize()","destroy!()","destroy_manager()","dict_to_kv()","digest()","digest()","discover()","discover()","discover()","discover_and_verify()","discover_no_yadis()","discover_uri()","discover_xri()","discover_yadis()","discovery_manager()","display_identifier()","display_identifier()","display_identifier=()","each()","each_service()","empty?()","empty?()","encode()","encode()","encode_response()","encode_to_kvform()","encode_to_kvform()","encode_to_url()","encode_to_url()","encode_to_url()","ends_with?()","ensure_dir()","escape_for_iri()","expand_service()","expires_in()","expiry()","extension_response()","extract_association()","extract_expires_in()","extract_response()","extract_secret()","extract_secret()","extract_supported_association_type()","fetch()","fetch()","fetch()","fetcher()","fetcher=()","fetcher_use_env_http_proxy()","filename_escape()","find_first_href()","find_links_rel()","find_op_local_identifier()","for_url?()","form_markup()","from_base64()","from_basic_service_endpoint()","from_basic_service_endpoint()","from_basic_service_endpoint()","from_defaults()","from_discovery_result()","from_expires_in()","from_html()","from_http_response()","from_kvform()","from_message()","from_message()","from_message()","from_message()","from_message()","from_message()","from_op_endpoint_url()","from_openid_args()","from_openid_request()","from_openid_request()","from_openid_request()","from_openid_request()","from_openid_request()","from_post_args()","from_success_response()","from_success_response()","from_success_response()","from_success_response()","from_success_response()","from_xrds()","generate_accept_header()","get()","getnexttoken()","gettag()","gettext()","gettrimmedtext()","get_acceptable()","get_alias()","get_aliased_arg()","get_allowed_return_urls()","get_allowed_type()","get_arg()","get_args()","get_association()","get_association()","get_association()","get_association()","get_association()","get_association()","get_association_filename()","get_canonical_id()","get_extension_args()","get_extension_args()","get_extension_args()","get_extension_args()","get_extension_args()","get_extension_args()","get_extension_args()","get_extension_args()","get_extension_args()","get_extension_args()","get_extension_args()","get_key()","get_local_id()","get_manager()","get_message()","get_message_signature()","get_namespace_uri()","get_next_service()","get_op_or_user_services()","get_openid1_session_type()","get_openid_namespace()","get_request()","get_request()","get_required_attrs()","get_return_to()","get_secret_size()","get_service_endpoints()","get_service_endpoints()","get_service_endpoints()","get_session_types()","get_shared_secret()","get_signed()","get_signed_ns()","get_single()","get_sreg_ns()","get_yadis_xrd()","handle_idres()","handle_request()","has_key?()","has_return_to()","hexdigest()","hexdigest()","hmac_sha1()","hmac_sha256()","html_markup()","html_yadis_location()","id_res()","id_select()","identifier_scheme()","identity_url()","implicit?()","invalidate()","iri_to_uri()","is_op_identifier()","is_openid1()","is_openid1()","is_openid2()","is_xrds()","is_xrds?()","kv_to_dict()","kv_to_seq()","last_requested_endpoint()","last_requested_endpoint=()","link_has_rel()","load()","log()","logger()","logger=()","make_connection()","make_filter()","make_http()","make_kv_post()","make_pairs()","make_xri()","match_types()","match_types()","member?()","member?()","member?()","method_missing()","mk_compound_filter()","mk_nonce()","mktemp()","namespace()","namespace_uris()","needs_signing()","negotiate_association()","negotiator()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new_args()","next()","normalize_url()","normalize_xri()","num_to_base64()","num_to_binary()","openid1_return_to_claimed_id_name()","openid1_return_to_claimed_id_name=()","openid1_return_to_nonce_name()","openid1_return_to_nonce_name=()","openid_associate()","openid_check_authentication()","openid_namespace()","openid_unescape()","parse()","parsexrds()","parse_accept_header()","parse_extension_args()","parse_extension_args()","parse_extension_args()","parse_extension_args()","parse_extension_args()","parse_extension_args()","parse_extension_args()","parse_extension_args()","parse_link_attrs()","parse_query()","parse_service()","peeknexttoken()","post_connection_check()","powermod()","preferred_namespace()","preferred_types()","prio_sort()","process_check_auth_response()","provider_is_authoritative()","query()","query_url()","rand()","random_string()","redirect_url()","register_namespace_alias()","rel_matches()","remove_association()","remove_association()","remove_association()","remove_association()","remove_dot_segments()","remove_if_present()","render_as_form()","request_association()","request_field()","request_fields()","requested_types()","reserved()","reset()","reset_key()","return_to_matches()","return_to_verified()","root_authority()","safe64()","sane?()","send_redirect?()","seq_to_kv()","serialize()","serialize()","server_url()","services()","session_get()","session_key()","session_key()","session_set()","set_arg()","set_key()","set_openid_namespace()","set_private()","set_values()","set_verified()","setup_encoding()","sha1()","sha256()","sign()","sign()","sign_message()","signed?()","signed_fields()","signed_list()","skew()","skew=()","split_nonce()","started?()","starts_with?()","status()","store()","store_association()","store_association()","store_association()","store_association()","strxor()","succeeded?()","supports_sreg?()","supports_ssl?()","supports_type()","text()","text()","text()","to_args()","to_base64()","to_form_markup()","to_form_markup()","to_form_markup()","to_html()","to_html()","to_iri_normal()","to_kvform()","to_message()","to_message()","to_post_args()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_type_uris()","to_uri_normal()","to_url()","to_url_encoded()","trimmed_text()","trust_root_valid()","unescape_hash()","update()","update_args()","urinorm()","urlencode()","urlencode()","use_nonce()","use_nonce()","use_nonce()","use_nonce()","used_yadis_location?()","uses_extension()","using_default_values?()","validate_url()","verify()","verify_discovered_services()","verify_discovery_results()","verify_discovery_results_openid1()","verify_discovery_results_openid2()","verify_discovery_single()","verify_return_to()","verify_return_to()","verify_return_to_args()","verify_return_to_base()","version()","wants_unlimited_values?()","were_fields_requested?()","where_is_yadis?()","which_encoding()","which_encoding()","xor_secret()","changelog","install","license","readme","upgrade","hmac.rb","sha1.rb","sha2.rb","openid.rb","association.rb","consumer.rb","associationmanager.rb","checkid_request.rb","discovery.rb","discovery_manager.rb","html_parse.rb","idres.rb","responses.rb","cryptutil.rb","dh.rb","extension.rb","ax.rb","oauth.rb","pape.rb","sreg.rb","extras.rb","fetchers.rb","kvform.rb","kvpost.rb","message.rb","protocolerror.rb","server.rb","filesystem.rb","interface.rb","memcache.rb","memory.rb","nonce.rb","trustroot.rb","urinorm.rb","util.rb","accept.rb","constants.rb","discovery.rb","filters.rb","htmltokenizer.rb","parsehtml.rb","services.rb","xrds.rb","xri.rb","xrires.rb"],"longSearchIndex":["lib/hmac/sha2.rb","hmac","hmac","hmac","hmac","hmac","lib/openid/yadis/htmltokenizer.rb","lib/openid/yadis/htmltokenizer.rb","lib/openid/yadis/htmltokenizer.rb","lib/openid/yadis/htmltokenizer.rb","lib/openid/yadis/htmltokenizer.rb","lib/openid/yadis/htmltokenizer.rb","lib/openid/fetchers.rb","net","lib/openid.rb","openid","openid::ax","openid::ax","openid::ax","openid::ax","openid::ax","openid::ax","openid::ax","openid::ax","openid","openid","openid","openid","openid::consumer","openid::consumer","openid::consumer","openid::consumer","openid::consumer","openid::consumer","openid::consumer","openid::consumer","openid::consumer","openid::consumer","openid::consumer","openid::consumer","openid::consumer","openid::consumer","openid","openid","openid","openid","openid","openid","openid","openid","openid","openid","openid","openid","openid::message","openid","openid","openid","openid","openid::oauth","openid::oauth","openid","openid","openid","openid::pape","openid::pape","openid","openid","openid","openid::sreg","openid::sreg","openid::sreg","openid","openid","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid::server","openid","openid","openid","openid::store","openid::store","openid::store","openid::store","openid","openid::trustroot","openid","openid","openid","openid","openid","openid::yadis","openid::yadis","openid::yadis","openid::yadis","openid::yadis","openid::yadis","openid::yadis","openid::yadis::xri","openid::yadis::xri","lib/openid/extras.rb","hmac::base","htmltoken","openid::association","openid::message","openid::ax::keyvaluemessage","openid::sreg::response","openid::trustroot::trustroot","openid::server::signatory","openid::trustroot","openid::message","openid::httpresponse","openid::message","openid::store::filesystem","openid::message","openid::ax::keyvaluemessage","openid::server::signatory","openid::trustroot::trustroot","openid::ax::fetchrequest","openid::namespacemap","openid::namespacemap","openid::associationnegotiator","openid::consumer::checkidrequest","openid::server::openidresponse","openid::consumer::checkidrequest","openid::pape::request","openid::pape::response","openid::ax::keyvaluemessage","openid::namespacemap","openid::sreg::request","openid::associationnegotiator","openid::server::baseserversession","openid::associationnegotiator","openid::consumer::checkidrequest","openid::server::associaterequest","openid::server::checkauthrequest","openid::server::checkidrequest","openid::server::diffiehellmansha1serversession","openid::server::plaintextserversession","openid::server::associaterequest","openid::util","openid::yadis::xri","openid::yadis","openid::yadis::transformfiltermaker","openid","openid::util","openid::store::memcache","openid::consumer","htmltag","openid::ax::fetchrequest","openid::util","openid::cryptutil","openid::consumer","openid::consumer","openid","openid::cryptutil","openid::httpresponse","openid::trustroot::trustroot","openid::server::checkidrequest","openid::ax","openid::consumer::idreshandler","openid::consumer::idreshandler","openid::association","openid::ax::axmessage","openid::consumer::idreshandler","openid::trustroot::trustroot","openid::associationnegotiator","openid::consumer::idreshandler","openid","hmac::base","openid::nonce","openid::trustroot::trustroot","openid::consumer::discoverymanager","openid::store::filesystem","openid::store::interface","openid::store::memcache","openid::store::filesystem","openid::store::interface","openid::store::memcache","openid::store::memory","openid::consumer","openid::store::filesystem","openid::store::interface","openid::store::memcache","openid::store::memory","openid::consumer","openid::openidserviceendpoint","openid::consumer","openid::consumer","openid::consumer","openid::consumer","openid::consumer","openid::consumer","openid::cryptutil","openid::associationnegotiator","openid::message","openid::server::openidresponse","openid::ax::keyvaluemessage","openid::consumer::associationmanager","openid::server::signatory","openid::consumer::idreshandler","openid::consumer::discoverymanager","openid::consumer::associationmanager","openid::server::decoder","openid::server::server","openid::store::memory","openid::server::decoder","openid::message","openid::store::memcache","openid::association","openid::store::memcache","openid::consumer::discoverymanager","openid::consumer::discoverymanager","openid::util","hmac::base","hmac::base","openid","openid::consumer","openid::yadis","openid::consumer::idreshandler","openid","openid","openid","openid","openid::consumer","openid::consumer::response","openid::openidserviceendpoint","openid::openidserviceendpoint","openid::namespacemap","openid::yadis","openid::consumer::discoveredservices","openid::sreg::response","openid::server::encoder","openid::server::signingencoder","openid::server::server","openid::server::openidresponse","openid::server::protocolerror","openid::server::checkidrequest","openid::server::openidresponse","openid::server::protocolerror","string","openid::store::filesystem","openid::yadis::xri","openid::yadis","openid::association","openid::store::memcache","openid::consumer::successresponse","openid::consumer::associationmanager","openid::consumer::associationmanager","openid::sreg::response","openid::consumer::diffiehellmansession","openid::consumer::noencryptionsession","openid::consumer::associationmanager","openid","openid::consumer::idreshandler","openid::standardfetcher","openid","openid","openid","openid::store::filesystem","openid","openid","openid","openid::consumer::discoveredservices","openid::consumer::checkidrequest","openid::util","openid::openidserviceendpoint","openid::yadis::basicserviceendpoint","openid::yadis::basicserviceendpoint","openid::diffiehellman","openid::openidserviceendpoint","openid::association","openid::openidserviceendpoint","openid::message","openid::message","openid::server::associaterequest","openid::server::checkauthrequest","openid::server::checkidrequest","openid::server::diffiehellmansha1serversession","openid::server::plaintextserversession","openid::servererror","openid::openidserviceendpoint","openid::message","openid::ax::fetchrequest","openid::ax::storerequest","openid::oauth::request","openid::pape::request","openid::sreg::request","openid::message","openid::ax::fetchresponse","openid::ax::storeresponse","openid::oauth::response","openid::pape::response","openid::sreg::response","openid::openidserviceendpoint","openid::yadis","openid::ax::keyvaluemessage","htmltokenizer","htmltokenizer","htmltokenizer","htmltokenizer","openid::yadis","openid::namespacemap","openid::message","openid::trustroot","openid::associationnegotiator","openid::message","openid::message","openid::consumer::associationmanager","openid::server::signatory","openid::store::filesystem","openid::store::interface","openid::store::memcache","openid::store::memory","openid::store::filesystem","openid::yadis","openid::ax::fetchrequest","openid::ax::fetchresponse","openid::ax::storerequest","openid::ax::storeresponse","openid::extension","openid::oauth::request","openid::oauth::response","openid::pape::request","openid::pape::response","openid::sreg::request","openid::sreg::response","openid::message","openid::openidserviceendpoint","openid::consumer::discoverymanager","openid::consumer::checkidrequest","openid::association","openid::namespacemap","openid::consumer::discoverymanager","openid","openid::consumer::associationmanager","openid::message","openid::consumer::diffiehellmansession","openid::consumer::noencryptionsession","openid::ax::fetchrequest","openid::server::protocolerror","openid","openid::yadis","openid::yadis::compoundfilter","openid::yadis::transformfiltermaker","openid::associationnegotiator","openid::diffiehellman","openid::consumer::successresponse","openid::consumer::successresponse","openid::ax::keyvaluemessage","openid","openid::yadis","openid::consumer","openid::server::server","openid::message","openid::server::protocolerror","hmac::base","hmac::base","openid::cryptutil","openid::cryptutil","openid::consumer::checkidrequest","openid::yadis","openid::consumer::idreshandler","openid::server::checkidrequest","openid::yadis::xri","openid::consumer::response","openid::namespacemap","openid::server::signatory","openid::yadis::xri","openid::openidserviceendpoint","openid::consumer::successresponse","openid::message","openid::message","openid::yadis::discoveryresult","openid::yadis","openid::util","openid::util","openid::consumer","openid::consumer","openid","openid::consumer::discoverymanager","openid::util","openid::util","openid::util","openid::standardfetcher","openid::yadis","openid::standardfetcher","openid","openid::association","openid::yadis::xri","openid::yadis","openid::yadis::basicserviceendpoint","openid::ax::fetchrequest","openid::namespacemap","openid::sreg::request","openid::httpresponse","openid::yadis","openid::nonce","openid::store::filesystem","openid::server::openidrequest","openid::namespacemap","openid::server::openidresponse","openid::consumer::associationmanager","openid::consumer","hmac::base","hmac::sha1","hmac::sha256","hmac::sha384","hmac::sha512","htmlcomment","htmltag","htmltoken","htmltokenizer","openid::ax::axmessage","openid::ax::attrinfo","openid::ax::fetchrequest","openid::ax::fetchresponse","openid::ax::keyvaluemessage","openid::ax::storerequest","openid::ax::storeresponse","openid::association","openid::associationnegotiator","openid::consumer","openid::consumer::associationmanager","openid::consumer::cancelresponse","openid::consumer::checkidrequest","openid::consumer::diffiehellmansession","openid::consumer::discoveredservices","openid::consumer::discoverymanager","openid::consumer::failureresponse","openid::consumer::idreshandler","openid::consumer::setupneededresponse","openid::consumer::successresponse","openid::diffiehellman","openid::discoveryfailure","openid::extension","openid::message","openid::namespacemap","openid::oauth::request","openid::oauth::response","openid::openidserviceendpoint","openid::pape::request","openid::pape::response","openid::realmverificationredirected","openid::sreg::request","openid::sreg::response","openid::server::associaterequest","openid::server::baseserversession","openid::server::checkauthrequest","openid::server::checkidrequest","openid::server::decoder","openid::server::diffiehellmansha1serversession","openid::server::diffiehellmansha256serversession","openid::server::encodingerror","openid::server::malformedreturnurl","openid::server::openidrequest","openid::server::openidresponse","openid::server::plaintextserversession","openid::server::protocolerror","openid::server::server","openid::server::signatory","openid::server::signingencoder","openid::server::untrustedreturnurl","openid::server::webresponse","openid::servererror","openid::standardfetcher","openid::store::filesystem","openid::store::memcache","openid::store::memory","openid::trustroot::trustroot","openid::typeurimismatch","openid::yadis::basicserviceendpoint","openid::yadis::compoundfilter","openid::yadis::discoveryresult","openid::yadis::transformfiltermaker","openid::yadis::xri::proxyresolver","openid::ax::axmessage","openid::consumer::discoveredservices","openid","openid","openid::cryptutil","openid::cryptutil","openid::consumer","openid::consumer","openid::consumer","openid::consumer","openid::server::server","openid::server::server","openid::consumer::idreshandler","openid","openid::trustroot::trustroot","openid::yadis","openid::yadis","openid::ax::fetchrequest","openid::ax::fetchresponse","openid::ax::keyvaluemessage","openid::oauth::request","openid::oauth::response","openid::pape::request","openid::pape::response","openid::sreg::request","openid","openid::util","openid::openidserviceendpoint","htmltokenizer","net::http","openid::diffiehellman","openid::openidserviceendpoint","openid::pape::request","openid::yadis","openid::consumer::idreshandler","openid::yadis::xri","openid::yadis::xri::proxyresolver","openid::yadis::xri::proxyresolver","openid::cryptutil","openid::cryptutil","openid::consumer::checkidrequest","openid::message","openid","openid::store::filesystem","openid::store::interface","openid::store::memcache","openid::store::memory","openid::urinorm","openid::store::filesystem","openid::server::openidresponse","openid::consumer::associationmanager","openid::sreg::request","openid::sreg::request","openid::ax::fetchrequest","openid::urinorm","htmltokenizer","hmac::base","openid::trustroot","openid::server::checkidrequest","openid::yadis::xri","openid::store::filesystem","openid::trustroot::trustroot","openid::consumer::checkidrequest","openid::util","openid::association","openid::store::memcache","openid::consumer::idreshandler","openid::yadis","openid::consumer","openid::consumer","openid::consumer::discoverymanager","openid::consumer","openid::message","hmac::base","openid::message","openid::diffiehellman","openid::ax::keyvaluemessage","openid::standardfetcher","openid::standardfetcher","openid::cryptutil","openid::cryptutil","openid::association","openid::server::signatory","openid::association","openid::consumer::successresponse","openid::consumer::idreshandler","openid::consumer::idreshandler","openid::nonce","openid::nonce","openid::nonce","openid::consumer::discoveredservices","string","openid::consumer::response","openid::consumer::discoverymanager","openid::store::filesystem","openid::store::interface","openid::store::memcache","openid::store::memory","openid::diffiehellman","openid::ax::storeresponse","openid","openid::standardfetcher","openid::openidserviceendpoint","htmltag","htmltext","htmltoken","openid::message","openid::util","openid::message","openid::server::openidresponse","openid::server::protocolerror","openid::server::openidresponse","openid::server::protocolerror","openid::yadis::xri","openid::message","openid::extension","openid::server::protocolerror","openid::message","hmac::base","htmltoken","openid::openidserviceendpoint","openid::realmverificationredirected","openid::server::checkauthrequest","openid::server::checkidrequest","openid::server::openidresponse","openid::server::untrustedreturnurl","openid::ax","openid::yadis::xri","openid::message","openid::message","htmltoken","openid::server::checkidrequest","openid","hmac::base","openid::message","openid::urinorm","openid::util","openid::yadis::xri","openid::store::filesystem","openid::store::interface","openid::store::memcache","openid::store::memory","openid::yadis::discoveryresult","openid::openidserviceendpoint","openid::diffiehellman","openid::trustroot::trustroot","openid::server::signatory","openid::consumer::idreshandler","openid::consumer::idreshandler","openid::consumer::idreshandler","openid::consumer::idreshandler","openid::consumer::idreshandler","openid::consumer::idreshandler","openid::trustroot","openid::consumer::idreshandler","openid::consumer::idreshandler","htmltokenizer","openid::ax::attrinfo","openid::sreg::request","openid::yadis","openid::server::openidresponse","openid::server::protocolerror","openid::diffiehellman","files/changelog.html","files/install.html","files/license.html","files/readme.html","files/upgrade.html","files/lib/hmac/hmac_rb.html","files/lib/hmac/sha1_rb.html","files/lib/hmac/sha2_rb.html","files/lib/openid_rb.html","files/lib/openid/association_rb.html","files/lib/openid/consumer_rb.html","files/lib/openid/consumer/associationmanager_rb.html","files/lib/openid/consumer/checkid_request_rb.html","files/lib/openid/consumer/discovery_rb.html","files/lib/openid/consumer/discovery_manager_rb.html","files/lib/openid/consumer/html_parse_rb.html","files/lib/openid/consumer/idres_rb.html","files/lib/openid/consumer/responses_rb.html","files/lib/openid/cryptutil_rb.html","files/lib/openid/dh_rb.html","files/lib/openid/extension_rb.html","files/lib/openid/extensions/ax_rb.html","files/lib/openid/extensions/oauth_rb.html","files/lib/openid/extensions/pape_rb.html","files/lib/openid/extensions/sreg_rb.html","files/lib/openid/extras_rb.html","files/lib/openid/fetchers_rb.html","files/lib/openid/kvform_rb.html","files/lib/openid/kvpost_rb.html","files/lib/openid/message_rb.html","files/lib/openid/protocolerror_rb.html","files/lib/openid/server_rb.html","files/lib/openid/store/filesystem_rb.html","files/lib/openid/store/interface_rb.html","files/lib/openid/store/memcache_rb.html","files/lib/openid/store/memory_rb.html","files/lib/openid/store/nonce_rb.html","files/lib/openid/trustroot_rb.html","files/lib/openid/urinorm_rb.html","files/lib/openid/util_rb.html","files/lib/openid/yadis/accept_rb.html","files/lib/openid/yadis/constants_rb.html","files/lib/openid/yadis/discovery_rb.html","files/lib/openid/yadis/filters_rb.html","files/lib/openid/yadis/htmltokenizer_rb.html","files/lib/openid/yadis/parsehtml_rb.html","files/lib/openid/yadis/services_rb.html","files/lib/openid/yadis/xrds_rb.html","files/lib/openid/yadis/xri_rb.html","files/lib/openid/yadis/xrires_rb.html"]}}