<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>SM::SimpleMarkup</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../../css/reset.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="../../css/main.css" type="text/css" media="screen" />
    <script src="../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../js/main.js" type="text/javascript" charset="utf-8"></script>
</head>

<body>     
    <div class="banner">
        <h1>
            <span class="type">Class</span> 
            SM::SimpleMarkup 
            
                <span class="parent">&lt; 
                    
                    <a href="../Object.html">Object</a>
                    
                </span>
            
        </h1>
        <ul class="files">
            
            <li><a href="../../files/lib/rdoc/markup/simple_markup_rb.html">lib/rdoc/markup/simple_markup.rb</a></li>
            
        </ul>
    </div>
    <div id="bodyContent">
        <div id="content">
    
    <div class="description">
        <h2>Synopsis</h2>
<p>
This code converts <tt>input_string</tt>, which is in the format described
in markup/simple_markup.rb, to HTML. The conversion takes place in the
<tt>convert</tt> method, so you can use the same <a
href="SimpleMarkup.html">SimpleMarkup</a> object to convert multiple input
strings.
</p>
<pre>
  require 'rdoc/markup/simple_markup'
  require 'rdoc/markup/simple_markup/to_html'

  p = SM::SimpleMarkup.new
  h = SM::ToHtml.new

  puts p.convert(input_string, h)
</pre>
<p>
You can extend the <a href="SimpleMarkup.html">SimpleMarkup</a> parser to
recognise new markup sequences, and to add special processing for text that
matches a regular epxression. Here we make WikiWords significant to the
parser, and also make the sequences {word} and <no>text...</no> signify
strike-through text. When then subclass the HTML output class to deal with
these:
</p>
<pre>
  require 'rdoc/markup/simple_markup'
  require 'rdoc/markup/simple_markup/to_html'

  class WikiHtml &lt; SM::ToHtml
    def handle_special_WIKIWORD(special)
      &quot;&lt;font color=red&gt;&quot; + special.text + &quot;&lt;/font&gt;&quot;
    end
  end

  p = SM::SimpleMarkup.new
  p.add_word_pair(&quot;{&quot;, &quot;}&quot;, :STRIKE)
  p.add_html(&quot;no&quot;, :STRIKE)

  p.add_special(/\b([A-Z][a-z]+[A-Z]\w+)/, :WIKIWORD)

  h = WikiHtml.new
  h.add_tag(:STRIKE, &quot;&lt;strike&gt;&quot;, &quot;&lt;/strike&gt;&quot;)

  puts &quot;&lt;body&gt;&quot; + p.convert(ARGF.read, h) + &quot;&lt;/body&gt;&quot;
</pre>
<h2>Output Formatters</h2>
<p>
<em>missing</em>
</p>

    </div>
    

    

    
    

    
    
    <div class="sectiontitle">Methods</div>
    <dl class="methods">
    
        <dt>A</dt>
        <dd>
            <ul>
                
                <li><a href="#M003792">add_html</a>,</li>
                
                <li><a href="#M003795">add_special</a>,</li>
                
                <li><a href="#M003791">add_word_pair</a>,</li>
                
                <li><a href="#M003797">assign_types_to_lines</a></li>
                
            </ul>
        </dd>
    
        <dt>C</dt>
        <dd>
            <ul>
                
                <li><a href="#M003800">content</a>,</li>
                
                <li><a href="#M003796">convert</a></li>
                
            </ul>
        </dd>
    
        <dt>G</dt>
        <dd>
            <ul>
                
                <li><a href="#M003801">get_line_types</a>,</li>
                
                <li><a href="#M003799">group_lines</a></li>
                
            </ul>
        </dd>
    
        <dt>H</dt>
        <dd>
            <ul>
                
                <li><a href="#M003798">handled_labeled_list</a></li>
                
            </ul>
        </dd>
    
        <dt>N</dt>
        <dd>
            <ul>
                
                <li><a href="#M003790">new</a></li>
                
            </ul>
        </dd>
    
    </dl>
    

    

    

    

    
    <div class="sectiontitle">Constants</div>
    <table border='0' cellpadding='5'>
        
        <tr valign='top'>
            <td class="attr-name">SPACE</td>
            <td>=</td>
            <td class="attr-value">?\s</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">SIMPLE_LIST_RE</td>
            <td>=</td>
            <td class="attr-value">/^(                   (  \*          (?# bullet)                     |-           (?# bullet)                     |\d+\.       (?# numbered )                     |[A-Za-z]\.  (?# alphabetically numbered )                   )                   \s+                 )\S/x</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
<a href="../List.html">List</a> entries look like:
</p>
<pre>
 *       text
 1.      text
 [label] text
 label:: text
</pre>
<p>
Flag it as a list entry, and work out the indent for subsequent lines
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">LABEL_LIST_RE</td>
            <td>=</td>
            <td class="attr-value">/^(                         (  \[.*?\]    (?# labeled  )                           |\S.*::     (?# note     )                         )(?:\s+|$)                       )/x</td>
        </tr>
        
        
    </table>
    

    

    
            <div class="sectiontitle">Instance Public methods</div>
            
            <div class="method">
                <div class="title" id="M003792">
                    
                    <a name="M003792"></a><b>add_html</b>(tag, name)
                    
                </div>
                
                <div class="description">
                  <p>
Add to the sequences recognized as general markup
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M003792_source')" id="l_M003792_source">show</a>
                        
                    </p>
                    <div id="M003792_source" class="dyn-source">
                        <pre>     <span class="ruby-comment cmt"># File lib/rdoc/markup/simple_markup.rb, line 225</span>
225:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">add_html</span>(<span class="ruby-identifier">tag</span>, <span class="ruby-identifier">name</span>)
226:       <span class="ruby-ivar">@am</span>.<span class="ruby-identifier">add_html</span>(<span class="ruby-identifier">tag</span>, <span class="ruby-identifier">name</span>)
227:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M003795">
                    
                    <a name="M003795"></a><b>add_special</b>(pattern, name)
                    
                </div>
                
                <div class="description">
                  <p>
Add to other inline sequences. For example, we could add WikiWords using
something like:
</p>
<pre>
   parser.add_special(/\b([A-Z][a-z]+[A-Z]\w+)/, :WIKIWORD)
</pre>
<p>
Each wiki word will be presented to the output formatter via the
accept_special method
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M003795_source')" id="l_M003795_source">show</a>
                        
                    </p>
                    <div id="M003795_source" class="dyn-source">
                        <pre>     <span class="ruby-comment cmt"># File lib/rdoc/markup/simple_markup.rb, line 239</span>
239:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">add_special</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-identifier">name</span>)
240:       <span class="ruby-ivar">@am</span>.<span class="ruby-identifier">add_special</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-identifier">name</span>)
241:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M003791">
                    
                    <a name="M003791"></a><b>add_word_pair</b>(start, stop, name)
                    
                </div>
                
                <div class="description">
                  <p>
Add to the sequences used to add formatting to an individual word (such as
<b>bold</b>). Matching entries will generate attibutes that the output
formatters can recognize by their <tt>name</tt>
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M003791_source')" id="l_M003791_source">show</a>
                        
                    </p>
                    <div id="M003791_source" class="dyn-source">
                        <pre>     <span class="ruby-comment cmt"># File lib/rdoc/markup/simple_markup.rb, line 217</span>
217:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">add_word_pair</span>(<span class="ruby-identifier">start</span>, <span class="ruby-identifier">stop</span>, <span class="ruby-identifier">name</span>)
218:       <span class="ruby-ivar">@am</span>.<span class="ruby-identifier">add_word_pair</span>(<span class="ruby-identifier">start</span>, <span class="ruby-identifier">stop</span>, <span class="ruby-identifier">name</span>)
219:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M003800">
                    
                    <a name="M003800"></a><b>content</b>()
                    
                </div>
                
                <div class="description">
                  <p>
for debugging, we allow access to our line contents as text
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M003800_source')" id="l_M003800_source">show</a>
                        
                    </p>
                    <div id="M003800_source" class="dyn-source">
                        <pre>     <span class="ruby-comment cmt"># File lib/rdoc/markup/simple_markup.rb, line 464</span>
464:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">content</span>
465:       <span class="ruby-ivar">@lines</span>.<span class="ruby-identifier">as_text</span>
466:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M003796">
                    
                    <a name="M003796"></a><b>convert</b>(str, op)
                    
                </div>
                
                <div class="description">
                  <p>
We take a string, split it into lines, work out the type of each line, and
from there deduce groups of lines (for example all lines in a paragraph).
We then invoke the output formatter using a Visitor to display the result
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M003796_source')" id="l_M003796_source">show</a>
                        
                    </p>
                    <div id="M003796_source" class="dyn-source">
                        <pre>     <span class="ruby-comment cmt"># File lib/rdoc/markup/simple_markup.rb, line 249</span>
249:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">convert</span>(<span class="ruby-identifier">str</span>, <span class="ruby-identifier">op</span>)
250:       <span class="ruby-ivar">@lines</span> = <span class="ruby-constant">Lines</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">str</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp re">/\r?\n/</span>).<span class="ruby-identifier">collect</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">aLine</span><span class="ruby-operator">|</span> 
251:                            <span class="ruby-constant">Line</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">aLine</span>) })
252:       <span class="ruby-keyword kw">return</span> <span class="ruby-value str">&quot;&quot;</span> <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@lines</span>.<span class="ruby-identifier">empty?</span>
253:       <span class="ruby-ivar">@lines</span>.<span class="ruby-identifier">normalize</span>
254:       <span class="ruby-identifier">assign_types_to_lines</span>
255:       <span class="ruby-identifier">group</span> = <span class="ruby-identifier">group_lines</span>
256:       <span class="ruby-comment cmt"># call the output formatter to handle the result</span>
257:       <span class="ruby-comment cmt">#      group.to_a.each {|i| p i}</span>
258:       <span class="ruby-identifier">group</span>.<span class="ruby-identifier">accept</span>(<span class="ruby-ivar">@am</span>, <span class="ruby-identifier">op</span>)
259:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M003801">
                    
                    <a name="M003801"></a><b>get_line_types</b>()
                    
                </div>
                
                <div class="description">
                  <p>
for debugging, return the list of line types
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M003801_source')" id="l_M003801_source">show</a>
                        
                    </p>
                    <div id="M003801_source" class="dyn-source">
                        <pre>     <span class="ruby-comment cmt"># File lib/rdoc/markup/simple_markup.rb, line 470</span>
470:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">get_line_types</span>
471:       <span class="ruby-ivar">@lines</span>.<span class="ruby-identifier">line_types</span>
472:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="sectiontitle">Instance Private methods</div>
            
            <div class="method">
                <div class="title" id="M003797">
                    
                    <a name="M003797"></a><b>assign_types_to_lines</b>(margin = 0, level = 0)
                    
                </div>
                
                <div class="description">
                  <p>
Look through the text at line indentation. We flag each line as being
Blank, a paragraph, a list element, or verbatim text
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M003797_source')" id="l_M003797_source">show</a>
                        
                    </p>
                    <div id="M003797_source" class="dyn-source">
                        <pre>     <span class="ruby-comment cmt"># File lib/rdoc/markup/simple_markup.rb, line 272</span>
272:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">assign_types_to_lines</span>(<span class="ruby-identifier">margin</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">level</span> = <span class="ruby-value">0</span>)
273: 
274:       <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">line</span> = <span class="ruby-ivar">@lines</span>.<span class="ruby-identifier">next</span>
275:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">isBlank?</span>
276:           <span class="ruby-identifier">line</span>.<span class="ruby-identifier">stamp</span>(<span class="ruby-constant">Line</span><span class="ruby-operator">::</span><span class="ruby-constant">BLANK</span>, <span class="ruby-identifier">level</span>)
277:           <span class="ruby-keyword kw">next</span>
278:         <span class="ruby-keyword kw">end</span>
279:         
280:         <span class="ruby-comment cmt"># if a line contains non-blanks before the margin, then it must belong</span>
281:         <span class="ruby-comment cmt"># to an outer level</span>
282: 
283:         <span class="ruby-identifier">text</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">text</span>
284:         
285:         <span class="ruby-keyword kw">for</span> <span class="ruby-identifier">i</span> <span class="ruby-keyword kw">in</span> <span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">margin</span>
286:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">text</span>[<span class="ruby-identifier">i</span>] <span class="ruby-operator">!=</span> <span class="ruby-constant">SPACE</span>
287:             <span class="ruby-ivar">@lines</span>.<span class="ruby-identifier">unget</span>
288:             <span class="ruby-keyword kw">return</span>
289:           <span class="ruby-keyword kw">end</span>
290:         <span class="ruby-keyword kw">end</span>
291: 
292:         <span class="ruby-identifier">active_line</span> = <span class="ruby-identifier">text</span>[<span class="ruby-identifier">margin</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
293: 
294:         <span class="ruby-comment cmt"># Rules (horizontal lines) look like</span>
295:         <span class="ruby-comment cmt">#</span>
296:         <span class="ruby-comment cmt">#  ---   (three or more hyphens)</span>
297:         <span class="ruby-comment cmt">#</span>
298:         <span class="ruby-comment cmt"># The more hyphens, the thicker the rule</span>
299:         <span class="ruby-comment cmt">#</span>
300: 
301:         <span class="ruby-keyword kw">if</span> <span class="ruby-regexp re">/^(---+)\s*$/</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">active_line</span>
302:           <span class="ruby-identifier">line</span>.<span class="ruby-identifier">stamp</span>(<span class="ruby-constant">Line</span><span class="ruby-operator">::</span><span class="ruby-constant">RULE</span>, <span class="ruby-identifier">level</span>, <span class="ruby-identifier">$1</span>.<span class="ruby-identifier">length</span><span class="ruby-operator">-</span><span class="ruby-value">2</span>)
303:           <span class="ruby-keyword kw">next</span>
304:         <span class="ruby-keyword kw">end</span>
305: 
306:         <span class="ruby-comment cmt"># Then look for list entries. First the ones that have to have</span>
307:         <span class="ruby-comment cmt"># text following them (* xxx, - xxx, and dd. xxx)</span>
308: 
309:         <span class="ruby-keyword kw">if</span> <span class="ruby-constant">SIMPLE_LIST_RE</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">active_line</span>
310: 
311:           <span class="ruby-identifier">offset</span> = <span class="ruby-identifier">margin</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">$1</span>.<span class="ruby-identifier">length</span>
312:           <span class="ruby-identifier">prefix</span> = <span class="ruby-identifier">$2</span>
313:           <span class="ruby-identifier">prefix_length</span> = <span class="ruby-identifier">prefix</span>.<span class="ruby-identifier">length</span>
314: 
315:           <span class="ruby-identifier">flag</span> = <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">prefix</span>
316:                  <span class="ruby-keyword kw">when</span> <span class="ruby-value str">&quot;*&quot;</span>,<span class="ruby-value str">&quot;-&quot;</span> <span class="ruby-keyword kw">then</span> <span class="ruby-constant">ListBase</span><span class="ruby-operator">::</span><span class="ruby-constant">BULLET</span>
317:                  <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^\d/</span>   <span class="ruby-keyword kw">then</span> <span class="ruby-constant">ListBase</span><span class="ruby-operator">::</span><span class="ruby-constant">NUMBER</span>
318:                  <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^[A-Z]/</span> <span class="ruby-keyword kw">then</span> <span class="ruby-constant">ListBase</span><span class="ruby-operator">::</span><span class="ruby-constant">UPPERALPHA</span>
319:                  <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^[a-z]/</span> <span class="ruby-keyword kw">then</span> <span class="ruby-constant">ListBase</span><span class="ruby-operator">::</span><span class="ruby-constant">LOWERALPHA</span>
320:                  <span class="ruby-keyword kw">else</span> <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;Invalid List Type: #{self.inspect}&quot;</span>
321:                  <span class="ruby-keyword kw">end</span>
322: 
323:           <span class="ruby-identifier">line</span>.<span class="ruby-identifier">stamp</span>(<span class="ruby-constant">Line</span><span class="ruby-operator">::</span><span class="ruby-constant">LIST</span>, <span class="ruby-identifier">level</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>, <span class="ruby-identifier">prefix</span>, <span class="ruby-identifier">flag</span>)
324:           <span class="ruby-identifier">text</span>[<span class="ruby-identifier">margin</span>, <span class="ruby-identifier">prefix_length</span>] = <span class="ruby-value str">&quot; &quot;</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">prefix_length</span>
325:           <span class="ruby-identifier">assign_types_to_lines</span>(<span class="ruby-identifier">offset</span>, <span class="ruby-identifier">level</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>)
326:           <span class="ruby-keyword kw">next</span>
327:         <span class="ruby-keyword kw">end</span>
328: 
329: 
330:         <span class="ruby-keyword kw">if</span> <span class="ruby-constant">LABEL_LIST_RE</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">active_line</span>
331:           <span class="ruby-identifier">offset</span> = <span class="ruby-identifier">margin</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">$1</span>.<span class="ruby-identifier">length</span>
332:           <span class="ruby-identifier">prefix</span> = <span class="ruby-identifier">$2</span>
333:           <span class="ruby-identifier">prefix_length</span> = <span class="ruby-identifier">prefix</span>.<span class="ruby-identifier">length</span>
334: 
335:           <span class="ruby-keyword kw">next</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">handled_labeled_list</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">level</span>, <span class="ruby-identifier">margin</span>, <span class="ruby-identifier">offset</span>, <span class="ruby-identifier">prefix</span>)
336:         <span class="ruby-keyword kw">end</span>
337: 
338:         <span class="ruby-comment cmt"># Headings look like</span>
339:         <span class="ruby-comment cmt"># = Main heading</span>
340:         <span class="ruby-comment cmt"># == Second level</span>
341:         <span class="ruby-comment cmt"># === Third</span>
342:         <span class="ruby-comment cmt">#</span>
343:         <span class="ruby-comment cmt"># Headings reset the level to 0</span>
344: 
345:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">active_line</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">?=</span> <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">active_line</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/^(=+)\s*(.*)/</span>
346:           <span class="ruby-identifier">prefix_length</span> = <span class="ruby-identifier">$1</span>.<span class="ruby-identifier">length</span>
347:           <span class="ruby-identifier">prefix_length</span> = <span class="ruby-value">6</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">prefix_length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">6</span>
348:           <span class="ruby-identifier">line</span>.<span class="ruby-identifier">stamp</span>(<span class="ruby-constant">Line</span><span class="ruby-operator">::</span><span class="ruby-constant">HEADING</span>, <span class="ruby-value">0</span>, <span class="ruby-identifier">prefix_length</span>)
349:           <span class="ruby-identifier">line</span>.<span class="ruby-identifier">strip_leading</span>(<span class="ruby-identifier">margin</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">prefix_length</span>)
350:           <span class="ruby-keyword kw">next</span>
351:         <span class="ruby-keyword kw">end</span>
352:         
353:         <span class="ruby-comment cmt"># If the character's a space, then we have verbatim text,</span>
354:         <span class="ruby-comment cmt"># otherwise </span>
355: 
356:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">active_line</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-constant">SPACE</span>
357:           <span class="ruby-identifier">line</span>.<span class="ruby-identifier">strip_leading</span>(<span class="ruby-identifier">margin</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">margin</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
358:           <span class="ruby-identifier">line</span>.<span class="ruby-identifier">stamp</span>(<span class="ruby-constant">Line</span><span class="ruby-operator">::</span><span class="ruby-constant">VERBATIM</span>, <span class="ruby-identifier">level</span>)
359:         <span class="ruby-keyword kw">else</span>
360:           <span class="ruby-identifier">line</span>.<span class="ruby-identifier">stamp</span>(<span class="ruby-constant">Line</span><span class="ruby-operator">::</span><span class="ruby-constant">PARAGRAPH</span>, <span class="ruby-identifier">level</span>)
361:         <span class="ruby-keyword kw">end</span>
362:       <span class="ruby-keyword kw">end</span>
363:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M003799">
                    
                    <a name="M003799"></a><b>group_lines</b>()
                    
                </div>
                
                <div class="description">
                  <p>
Return a block consisting of fragments which are paragraphs, list entries
or verbatim text. We merge consecutive lines of the same type and level
together. We are also slightly tricky with lists: the lines following a
list introduction look like paragraph lines at the next level, and we remap
them into list entries instead
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M003799_source')" id="l_M003799_source">show</a>
                        
                    </p>
                    <div id="M003799_source" class="dyn-source">
                        <pre>     <span class="ruby-comment cmt"># File lib/rdoc/markup/simple_markup.rb, line 435</span>
435:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">group_lines</span>
436:       <span class="ruby-ivar">@lines</span>.<span class="ruby-identifier">rewind</span>
437: 
438:       <span class="ruby-identifier">inList</span> = <span class="ruby-keyword kw">false</span>
439:       <span class="ruby-identifier">wantedType</span> = <span class="ruby-identifier">wantedLevel</span> = <span class="ruby-keyword kw">nil</span>
440: 
441:       <span class="ruby-identifier">block</span> = <span class="ruby-constant">LineCollection</span>.<span class="ruby-identifier">new</span>
442:       <span class="ruby-identifier">group</span> = <span class="ruby-keyword kw">nil</span>
443: 
444:       <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">line</span> = <span class="ruby-ivar">@lines</span>.<span class="ruby-identifier">next</span>
445:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">wantedLevel</span> <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">wantedType</span>
446:           <span class="ruby-identifier">group</span>.<span class="ruby-identifier">add_text</span>(<span class="ruby-identifier">line</span>.<span class="ruby-identifier">text</span>)
447:         <span class="ruby-keyword kw">else</span>
448:           <span class="ruby-identifier">group</span> = <span class="ruby-identifier">block</span>.<span class="ruby-identifier">fragment_for</span>(<span class="ruby-identifier">line</span>)
449:           <span class="ruby-identifier">block</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">group</span>)
450:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Line</span><span class="ruby-operator">::</span><span class="ruby-constant">LIST</span>
451:             <span class="ruby-identifier">wantedType</span> = <span class="ruby-constant">Line</span><span class="ruby-operator">::</span><span class="ruby-constant">PARAGRAPH</span>
452:           <span class="ruby-keyword kw">else</span>
453:             <span class="ruby-identifier">wantedType</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">type</span>
454:           <span class="ruby-keyword kw">end</span>
455:           <span class="ruby-identifier">wantedLevel</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Line</span><span class="ruby-operator">::</span><span class="ruby-constant">HEADING</span> <span class="ruby-value">? </span><span class="ruby-identifier">line</span>.<span class="ruby-identifier">param</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">level</span>
456:         <span class="ruby-keyword kw">end</span>
457:       <span class="ruby-keyword kw">end</span>
458: 
459:       <span class="ruby-identifier">block</span>.<span class="ruby-identifier">normalize</span>
460:       <span class="ruby-identifier">block</span>
461:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M003798">
                    
                    <a name="M003798"></a><b>handled_labeled_list</b>(line, level, margin, offset, prefix)
                    
                </div>
                
                <div class="description">
                  <p>
Handle labeled list entries, We have a special case to deal with. Because
the labels can be long, they force the remaining block of text over the to
right:
</p>
<table>
<tr><td valign="top">this is a long label that I wrote:</td><td>and here is the block of text with a silly margin

</td></tr>
</table>
<p>
So we allow the special case. If the label is followed by nothing, and if
the following line is indented, then we take the indent of that line as the
new margin
</p>
<table>
<tr><td valign="top">this is a long label that I wrote:</td><td>here is a more reasonably indented block which will ab attached to the
label.

</td></tr>
</table>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M003798_source')" id="l_M003798_source">show</a>
                        
                    </p>
                    <div id="M003798_source" class="dyn-source">
                        <pre>     <span class="ruby-comment cmt"># File lib/rdoc/markup/simple_markup.rb, line 382</span>
382:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">handled_labeled_list</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">level</span>, <span class="ruby-identifier">margin</span>, <span class="ruby-identifier">offset</span>, <span class="ruby-identifier">prefix</span>)
383:       <span class="ruby-identifier">prefix_length</span> = <span class="ruby-identifier">prefix</span>.<span class="ruby-identifier">length</span>
384:       <span class="ruby-identifier">text</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">text</span>
385:       <span class="ruby-identifier">flag</span> = <span class="ruby-keyword kw">nil</span>
386:       <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">prefix</span>
387:       <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^\[/</span>
388:         <span class="ruby-identifier">flag</span> = <span class="ruby-constant">ListBase</span><span class="ruby-operator">::</span><span class="ruby-constant">LABELED</span>
389:         <span class="ruby-identifier">prefix</span> = <span class="ruby-identifier">prefix</span>[<span class="ruby-value">1</span>, <span class="ruby-identifier">prefix</span>.<span class="ruby-identifier">length</span><span class="ruby-operator">-</span><span class="ruby-value">2</span>]
390:       <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/:$/</span>
391:         <span class="ruby-identifier">flag</span> = <span class="ruby-constant">ListBase</span><span class="ruby-operator">::</span><span class="ruby-constant">NOTE</span>
392:         <span class="ruby-identifier">prefix</span>.<span class="ruby-identifier">chop!</span>
393:       <span class="ruby-keyword kw">else</span> <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;Invalid List Type: #{self.inspect}&quot;</span>
394:       <span class="ruby-keyword kw">end</span>
395:       
396:       <span class="ruby-comment cmt"># body is on the next line</span>
397:       
398:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">text</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">offset</span>
399:         <span class="ruby-identifier">original_line</span> = <span class="ruby-identifier">line</span>
400:         <span class="ruby-identifier">line</span> = <span class="ruby-ivar">@lines</span>.<span class="ruby-identifier">next</span>
401:         <span class="ruby-keyword kw">return</span>(<span class="ruby-keyword kw">false</span>) <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">line</span>
402:         <span class="ruby-identifier">text</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">text</span>
403:         
404:         <span class="ruby-keyword kw">for</span> <span class="ruby-identifier">i</span> <span class="ruby-keyword kw">in</span> <span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-identifier">margin</span>
405:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">text</span>[<span class="ruby-identifier">i</span>] <span class="ruby-operator">!=</span> <span class="ruby-constant">SPACE</span>
406:             <span class="ruby-ivar">@lines</span>.<span class="ruby-identifier">unget</span>
407:             <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">false</span>
408:           <span class="ruby-keyword kw">end</span>
409:         <span class="ruby-keyword kw">end</span>
410:         <span class="ruby-identifier">i</span> = <span class="ruby-identifier">margin</span>
411:         <span class="ruby-identifier">i</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">text</span>[<span class="ruby-identifier">i</span>] <span class="ruby-operator">==</span> <span class="ruby-constant">SPACE</span>
412:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">text</span>.<span class="ruby-identifier">length</span>
413:           <span class="ruby-ivar">@lines</span>.<span class="ruby-identifier">unget</span>
414:           <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">false</span>
415:         <span class="ruby-keyword kw">else</span>
416:           <span class="ruby-identifier">offset</span> = <span class="ruby-identifier">i</span>
417:           <span class="ruby-identifier">prefix_length</span> = <span class="ruby-value">0</span>
418:           <span class="ruby-ivar">@lines</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">original_line</span>)
419:         <span class="ruby-keyword kw">end</span>
420:       <span class="ruby-keyword kw">end</span>
421:       
422:       <span class="ruby-identifier">line</span>.<span class="ruby-identifier">stamp</span>(<span class="ruby-constant">Line</span><span class="ruby-operator">::</span><span class="ruby-constant">LIST</span>, <span class="ruby-identifier">level</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>, <span class="ruby-identifier">prefix</span>, <span class="ruby-identifier">flag</span>)
423:       <span class="ruby-identifier">text</span>[<span class="ruby-identifier">margin</span>, <span class="ruby-identifier">prefix_length</span>] = <span class="ruby-value str">&quot; &quot;</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">prefix_length</span>
424:       <span class="ruby-identifier">assign_types_to_lines</span>(<span class="ruby-identifier">offset</span>, <span class="ruby-identifier">level</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>)
425:       <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">true</span>
426:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="sectiontitle">Class Public methods</div>
            
            <div class="method">
                <div class="title" id="M003790">
                    
                    <a name="M003790"></a><b>new</b>()
                    
                </div>
                
                <div class="description">
                  <p>
take a block of text and use various heuristics to determine it&#8217;s
structure (paragraphs, lists, and so on). Invoke an event handler as we
identify significant chunks.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M003790_source')" id="l_M003790_source">show</a>
                        
                    </p>
                    <div id="M003790_source" class="dyn-source">
                        <pre>     <span class="ruby-comment cmt"># File lib/rdoc/markup/simple_markup.rb, line 207</span>
207:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">initialize</span>
208:       <span class="ruby-ivar">@am</span> = <span class="ruby-constant">AttributeManager</span>.<span class="ruby-identifier">new</span>
209:       <span class="ruby-ivar">@output</span> = <span class="ruby-keyword kw">nil</span>
210:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
</div>
    </div>
  </body>
</html>    