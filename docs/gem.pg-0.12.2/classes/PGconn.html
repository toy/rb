<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>PGconn</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../css/reset.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" />
    <script src="../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
    <script src="../js/main.js" type="text/javascript" charset="utf-8"></script>
</head>

<body>     
    <div class="banner">
        <h1>
            <span class="type">Class</span> 
            PGconn 
            
                <span class="parent">&lt; 
                    
                    Object
                    
                </span>
            
        </h1>
        <ul class="files">
            
            <li><a href="../files/lib/pg_rb.html">lib/pg.rb</a></li>
            
            <li><a href="../files/ext/pg_c.html">ext/pg.c</a></li>
            
        </ul>
    </div>
    <div id="bodyContent">
        <div id="content">
    
    <div class="description">
        <p>
The class to access PostgreSQL RDBMS, based on the libpq interface,
provides convenient OO methods to interact with PostgreSQL.
</p>
<p>
For example, to send query to the database on the localhost:
</p>
<pre>
   require 'pg'
   conn = PGconn.open(:dbname =&gt; 'test')
   res = conn.exec('SELECT $1 AS a, $2 AS b, $3 AS c',[1, 2, nil])
   # Equivalent to:
   #  res  = conn.exec('SELECT 1 AS a, 2 AS b, NULL AS c')
</pre>
<p>
See the <a href="PGresult.html">PGresult</a> class for information on
working with the results of a query.
</p>

    </div>
    

    

    
    

    
    
    <div class="sectiontitle">Methods</div>
    <dl class="methods">
    
        <dt>A</dt>
        <dd>
            <ul>
                
                <li><a href="#M000073">async_exec</a>,</li>
                
                <li><a href="#M000121">async_query</a></li>
                
            </ul>
        </dd>
    
        <dt>B</dt>
        <dd>
            <ul>
                
                <li><a href="#M000034">backend_pid</a>,</li>
                
                <li><a href="#M000070">block</a></li>
                
            </ul>
        </dd>
    
        <dt>C</dt>
        <dd>
            <ul>
                
                <li><a href="#M000057">cancel</a>,</li>
                
                <li><a href="#M000116">close</a>,</li>
                
                <li><a href="#M000019">conndefaults</a>,</li>
                
                <li><a href="#M000012">conndefaults</a>,</li>
                
                <li><a href="#M000014">connect_poll</a>,</li>
                
                <li><a href="#M000011">connect_start</a>,</li>
                
                <li><a href="#M000035">connection_needs_password</a>,</li>
                
                <li><a href="#M000036">connection_used_password</a>,</li>
                
                <li><a href="#M000052">consume_input</a></li>
                
            </ul>
        </dd>
    
        <dt>D</dt>
        <dd>
            <ul>
                
                <li><a href="#M000020">db</a>,</li>
                
                <li><a href="#M000041">describe_portal</a>,</li>
                
                <li><a href="#M000040">describe_prepared</a></li>
                
            </ul>
        </dd>
    
        <dt>E</dt>
        <dd>
            <ul>
                
                <li><a href="#M000009">encrypt_password</a>,</li>
                
                <li><a href="#M000032">error_message</a>,</li>
                
                <li><a href="#M000118">escape</a>,</li>
                
                <li><a href="#M000044">escape_bytea</a>,</li>
                
                <li><a href="#M000006">escape_bytea</a>,</li>
                
                <li><a href="#M000005">escape_string</a>,</li>
                
                <li><a href="#M000043">escape_string</a>,</li>
                
                <li><a href="#M000037">exec</a>,</li>
                
                <li><a href="#M000039">exec_prepared</a>,</li>
                
                <li><a href="#M000004">external_encoding</a></li>
                
            </ul>
        </dd>
    
        <dt>F</dt>
        <dd>
            <ul>
                
                <li><a href="#M000015">finish</a>,</li>
                
                <li><a href="#M000056">flush</a></li>
                
            </ul>
        </dd>
    
        <dt>G</dt>
        <dd>
            <ul>
                
                <li><a href="#M000067">get_client_encoding</a>,</li>
                
                <li><a href="#M000061">get_copy_data</a>,</li>
                
                <li><a href="#M000074">get_last_result</a>,</li>
                
                <li><a href="#M000051">get_result</a></li>
                
            </ul>
        </dd>
    
        <dt>H</dt>
        <dd>
            <ul>
                
                <li><a href="#M000023">host</a></li>
                
            </ul>
        </dd>
    
        <dt>I</dt>
        <dd>
            <ul>
                
                <li><a href="#M000002">internal_encoding</a>,</li>
                
                <li><a href="#M000003">internal_encoding=</a>,</li>
                
                <li><a href="#M000053">is_busy</a>,</li>
                
                <li><a href="#M000055">isnonblocking</a>,</li>
                
                <li><a href="#M000008">isthreadsafe</a></li>
                
            </ul>
        </dd>
    
        <dt>L</dt>
        <dd>
            <ul>
                
                <li><a href="#M000085">lo_close</a>,</li>
                
                <li><a href="#M000075">lo_creat</a>,</li>
                
                <li><a href="#M000076">lo_create</a>,</li>
                
                <li><a href="#M000078">lo_export</a>,</li>
                
                <li><a href="#M000077">lo_import</a>,</li>
                
                <li><a href="#M000082">lo_lseek</a>,</li>
                
                <li><a href="#M000079">lo_open</a>,</li>
                
                <li><a href="#M000081">lo_read</a>,</li>
                
                <li><a href="#M000130">lo_seek</a>,</li>
                
                <li><a href="#M000083">lo_tell</a>,</li>
                
                <li><a href="#M000084">lo_truncate</a>,</li>
                
                <li><a href="#M000086">lo_unlink</a>,</li>
                
                <li><a href="#M000080">lo_write</a>,</li>
                
                <li><a href="#M000134">loclose</a>,</li>
                
                <li><a href="#M000122">locreat</a>,</li>
                
                <li><a href="#M000123">locreate</a>,</li>
                
                <li><a href="#M000125">loexport</a>,</li>
                
                <li><a href="#M000124">loimport</a>,</li>
                
                <li><a href="#M000129">lolseek</a>,</li>
                
                <li><a href="#M000126">loopen</a>,</li>
                
                <li><a href="#M000128">loread</a>,</li>
                
                <li><a href="#M000131">loseek</a>,</li>
                
                <li><a href="#M000132">lotell</a>,</li>
                
                <li><a href="#M000133">lotruncate</a>,</li>
                
                <li><a href="#M000135">lounlink</a>,</li>
                
                <li><a href="#M000127">lowrite</a></li>
                
            </ul>
        </dd>
    
        <dt>M</dt>
        <dd>
            <ul>
                
                <li><a href="#M000042">make_empty_pgresult</a></li>
                
            </ul>
        </dd>
    
        <dt>N</dt>
        <dd>
            <ul>
                
                <li><a href="#M000013">new</a>,</li>
                
                <li><a href="#M000119">nonblocking?</a>,</li>
                
                <li><a href="#M000058">notifies</a>,</li>
                
                <li><a href="#M000120">notifies_wait</a></li>
                
            </ul>
        </dd>
    
        <dt>O</dt>
        <dd>
            <ul>
                
                <li><a href="#M000026">options</a></li>
                
            </ul>
        </dd>
    
        <dt>P</dt>
        <dd>
            <ul>
                
                <li><a href="#M000029">parameter_status</a>,</li>
                
                <li><a href="#M000001">parse_connect_args</a>,</li>
                
                <li><a href="#M000022">pass</a>,</li>
                
                <li><a href="#M000024">port</a>,</li>
                
                <li><a href="#M000038">prepare</a>,</li>
                
                <li><a href="#M000030">protocol_version</a>,</li>
                
                <li><a href="#M000059">put_copy_data</a>,</li>
                
                <li><a href="#M000060">put_copy_end</a></li>
                
            </ul>
        </dd>
    
        <dt>Q</dt>
        <dd>
            <ul>
                
                <li><a href="#M000117">query</a>,</li>
                
                <li><a href="#M000000">quote_connstr</a>,</li>
                
                <li><a href="#M000072">quote_ident</a>,</li>
                
                <li><a href="#M000010">quote_ident</a></li>
                
            </ul>
        </dd>
    
        <dt>R</dt>
        <dd>
            <ul>
                
                <li><a href="#M000016">reset</a>,</li>
                
                <li><a href="#M000018">reset_poll</a>,</li>
                
                <li><a href="#M000017">reset_start</a></li>
                
            </ul>
        </dd>
    
        <dt>S</dt>
        <dd>
            <ul>
                
                <li><a href="#M000050">send_describe_portal</a>,</li>
                
                <li><a href="#M000049">send_describe_prepared</a>,</li>
                
                <li><a href="#M000047">send_prepare</a>,</li>
                
                <li><a href="#M000046">send_query</a>,</li>
                
                <li><a href="#M000048">send_query_prepared</a>,</li>
                
                <li><a href="#M000031">server_version</a>,</li>
                
                <li><a href="#M000068">set_client_encoding</a>,</li>
                
                <li><a href="#M000062">set_error_verbosity</a>,</li>
                
                <li><a href="#M000066">set_notice_processor</a>,</li>
                
                <li><a href="#M000065">set_notice_receiver</a>,</li>
                
                <li><a href="#M000054">setnonblocking</a>,</li>
                
                <li><a href="#M000033">socket</a>,</li>
                
                <li><a href="#M000027">status</a></li>
                
            </ul>
        </dd>
    
        <dt>T</dt>
        <dd>
            <ul>
                
                <li><a href="#M000063">trace</a>,</li>
                
                <li><a href="#M000069">transaction</a>,</li>
                
                <li><a href="#M000028">transaction_status</a>,</li>
                
                <li><a href="#M000025">tty</a></li>
                
            </ul>
        </dd>
    
        <dt>U</dt>
        <dd>
            <ul>
                
                <li><a href="#M000045">unescape_bytea</a>,</li>
                
                <li><a href="#M000007">unescape_bytea</a>,</li>
                
                <li><a href="#M000064">untrace</a>,</li>
                
                <li><a href="#M000021">user</a></li>
                
            </ul>
        </dd>
    
        <dt>W</dt>
        <dd>
            <ul>
                
                <li><a href="#M000071">wait_for_notify</a></li>
                
            </ul>
        </dd>
    
    </dl>
    

    

    

    

    
    <div class="sectiontitle">Constants</div>
    <table border='0' cellpadding='5'>
        
        <tr valign='top'>
            <td class="attr-name">CONNECT_ARGUMENT_ORDER</td>
            <td>=</td>
            <td class="attr-value">%w[host port options tty dbname user password]</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
The order the options are passed to the ::connect method.
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">VERSION</td>
            <td>=</td>
            <td class="attr-value">rb_str_new2(VERSION)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Library version
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">CONNECTION_OK</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(CONNECTION_OK)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Connection succeeded
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">CONNECTION_BAD</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(CONNECTION_BAD)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Connection failed
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">CONNECTION_STARTED</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(CONNECTION_STARTED)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Waiting for connection to be made.
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">CONNECTION_MADE</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(CONNECTION_MADE)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Connection OK; waiting to send.
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">CONNECTION_AWAITING_RESPONSE</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(CONNECTION_AWAITING_RESPONSE)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Waiting for a response from the server.
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">CONNECTION_AUTH_OK</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(CONNECTION_AUTH_OK)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Received authentication; waiting for backend start-up to ﬁnish.
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">CONNECTION_SSL_STARTUP</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(CONNECTION_SSL_STARTUP)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Negotiating SSL encryption.
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">CONNECTION_SETENV</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(CONNECTION_SETENV)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Negotiating environment-driven parameter settings.
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">PGRES_POLLING_READING</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(PGRES_POLLING_READING)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Async connection is waiting to read
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">PGRES_POLLING_WRITING</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(PGRES_POLLING_WRITING)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Async connection is waiting to write
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">PGRES_POLLING_FAILED</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(PGRES_POLLING_FAILED)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Async connection failed or was reset
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">PGRES_POLLING_OK</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(PGRES_POLLING_OK)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Async connection succeeded
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">PQTRANS_IDLE</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(PQTRANS_IDLE)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Transaction is currently idle (<a
href="PGconn.html#M000028">transaction_status</a>)
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">PQTRANS_ACTIVE</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(PQTRANS_ACTIVE)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Transaction is currently active; query has been sent to the server, but not
yet completed. (<a href="PGconn.html#M000028">transaction_status</a>)
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">PQTRANS_INTRANS</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(PQTRANS_INTRANS)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Transaction is currently idle, in a valid transaction block (<a
href="PGconn.html#M000028">transaction_status</a>)
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">PQTRANS_INERROR</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(PQTRANS_INERROR)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Transaction is currently idle, in a failed transaction block (<a
href="PGconn.html#M000028">transaction_status</a>)
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">PQTRANS_UNKNOWN</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(PQTRANS_UNKNOWN)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Transaction&#8217;s connection is bad (<a
href="PGconn.html#M000028">transaction_status</a>)
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">PQERRORS_TERSE</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(PQERRORS_TERSE)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Terse error verbosity level (<a
href="PGconn.html#M000062">set_error_verbosity</a>)
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">PQERRORS_DEFAULT</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(PQERRORS_DEFAULT)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Default error verbosity level (<a
href="PGconn.html#M000062">set_error_verbosity</a>)
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">PQERRORS_VERBOSE</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(PQERRORS_VERBOSE)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Verbose error verbosity level (<a
href="PGconn.html#M000062">set_error_verbosity</a>)
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">INV_WRITE</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(INV_WRITE)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Flag for <a href="PGconn.html#M000075">lo_creat</a>, <a
href="PGconn.html#M000079">lo_open</a> &#8212; open for writing
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">INV_READ</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(INV_READ)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Flag for <a href="PGconn.html#M000075">lo_creat</a>, <a
href="PGconn.html#M000079">lo_open</a> &#8212; open for reading
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">SEEK_SET</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(SEEK_SET)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Flag for <a href="PGconn.html#M000082">lo_lseek</a> &#8212; seek from
object start
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">SEEK_CUR</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(SEEK_CUR)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Flag for <a href="PGconn.html#M000082">lo_lseek</a> &#8212; seek from
current position
</p>
</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">SEEK_END</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(SEEK_END)</td>
        </tr>
        
        <tr valign='top'>
            <td>&nbsp;</td>
            <td colspan="2" class="attr-desc"><p>
Flag for <a href="PGconn.html#M000082">lo_lseek</a> &#8212; seek from
object end
</p>
</td>
        </tr>
        
        
    </table>
    

    

    
            <div class="sectiontitle">Class Public methods</div>
            
            <div class="method">
                <div class="title" id="M000012">
                    
                    <a name="M000012"></a><b>PGconn.conndefaults() &rarr; Array
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns an array of hashes. Each hash has the keys:
</p>
<dl>
<dt><tt>:keyword</tt></dt><dd>the name of the option

</dd>
<dt><tt>:envvar</tt></dt><dd>the environment variable to fall back to

</dd>
<dt><tt>:compiled</tt></dt><dd>the compiled in option as a secondary fallback

</dd>
<dt><tt>:val</tt></dt><dd>the option&#8217;s current value, or <tt>nil</tt> if not known

</dd>
<dt><tt>:label</tt></dt><dd>the label for the field

</dd>
<dt><tt>:dispchar</tt></dt><dd>&#8220;&#8221; for normal, &#8220;D&#8221; for debug, and &#8220;*&#8221;
for password

</dd>
<dt><tt>:dispsize</tt></dt><dd>field size

</dd>
</dl>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000012_source')" id="l_M000012_source">show</a>
                        
                    </p>
                    <div id="M000012_source" class="dyn-source">
                        <pre>static VALUE
pgconn_s_conndefaults(VALUE self)
{
  PQconninfoOption *options = PQconndefaults();
  VALUE ary = rb_ary_new();
  VALUE hash;
  int i = 0;

  for(i = 0; options[i].keyword != NULL; i++) {
    hash = rb_hash_new();
    if(options[i].keyword)
      rb_hash_aset(hash, ID2SYM(rb_intern(&quot;keyword&quot;)), 
        rb_str_new2(options[i].keyword));
    if(options[i].envvar)
      rb_hash_aset(hash, ID2SYM(rb_intern(&quot;envvar&quot;)), 
        rb_str_new2(options[i].envvar));
    if(options[i].compiled)
      rb_hash_aset(hash, ID2SYM(rb_intern(&quot;compiled&quot;)), 
        rb_str_new2(options[i].compiled));
    if(options[i].val)
      rb_hash_aset(hash, ID2SYM(rb_intern(&quot;val&quot;)), 
        rb_str_new2(options[i].val));
    if(options[i].label)
      rb_hash_aset(hash, ID2SYM(rb_intern(&quot;label&quot;)), 
        rb_str_new2(options[i].label));
    if(options[i].dispchar)
      rb_hash_aset(hash, ID2SYM(rb_intern(&quot;dispchar&quot;)), 
        rb_str_new2(options[i].dispchar));
    rb_hash_aset(hash, ID2SYM(rb_intern(&quot;dispsize&quot;)), 
      INT2NUM(options[i].dispsize));
    rb_ary_push(ary, hash);
  }
  PQconninfoFree(options);
  return ary;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000011">
                    
                    <a name="M000011"></a><b>PGconn.connect_start(connection_hash)       &rarr; PGconn
PGconn.connect_start(connection_string)     &rarr; PGconn
PGconn.connect_start(host, port, options, tty, dbname, login, password) &rarr;  PGconn
</b>
                    
                </div>
                
                <div class="description">
                  <p>
This is an asynchronous version of PGconn.connect().
</p>
<p>
Use <a href="PGconn.html#M000014">PGconn#connect_poll</a> to poll the
status of the connection.
</p>
<p>
NOTE: this does <b>not</b> set the connection&#8217;s
<tt>client_encoding</tt> for you if Encoding.default_internal is set. To
set it after the connection is established, call <a
href="PGconn.html#M000003">PGconn#internal_encoding=</a>. You can also set
it automatically by setting ENV[&#8216;PGCLIENTENCODING&#8217;], or include
the &#8216;options&#8217; connection parameter.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000011_source')" id="l_M000011_source">show</a>
                        
                    </p>
                    <div id="M000011_source" class="dyn-source">
                        <pre>static VALUE
pgconn_s_connect_start(int argc, VALUE *argv, VALUE self)
{
  PGconn *conn = NULL;
  VALUE rb_conn;
  VALUE conninfo;
  VALUE error;

  /*
   * PGconn.connect_start must act as both alloc() and initialize()
   * because it is not invoked by calling new().
   */
  rb_conn = pgconn_alloc(rb_cPGconn);

  conninfo = rb_funcall2( rb_cPGconn, rb_intern(&quot;parse_connect_args&quot;), argc, argv );
  conn = PQconnectStart(StringValuePtr(conninfo));

  if(conn == NULL)
    rb_raise(rb_ePGError, &quot;PQconnectStart() unable to allocate structure&quot;);
  if (PQstatus(conn) == CONNECTION_BAD) {
    error = rb_exc_new2(rb_ePGError, PQerrorMessage(conn));
    rb_iv_set(error, &quot;@connection&quot;, self);
    rb_exc_raise(error);
  }

  Check_Type(rb_conn, T_DATA);
  DATA_PTR(rb_conn) = conn;

  if (rb_block_given_p()) {
    return rb_ensure(rb_yield, self, pgconn_finish, self);
  }
  return rb_conn;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000009">
                    
                    <a name="M000009"></a><b>PGconn.encrypt_password( password, username ) &rarr; String
</b>
                    
                </div>
                
                <div class="description">
                  <p>
This function is intended to be used by client applications that send
commands like: +ALTER USER joe PASSWORD &#8216;pwd&#8217;+. The arguments
are the cleartext password, and the SQL name of the user it is for.
</p>
<p>
Return value is the encrypted password.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000009_source')" id="l_M000009_source">show</a>
                        
                    </p>
                    <div id="M000009_source" class="dyn-source">
                        <pre>static VALUE
pgconn_s_encrypt_password(VALUE self, VALUE password, VALUE username)
{
  char *encrypted = NULL;
  VALUE rval = Qnil;

  Check_Type(password, T_STRING);
  Check_Type(username, T_STRING);

  encrypted = PQencryptPassword(StringValuePtr(password), StringValuePtr(username));
  rval = rb_str_new2( encrypted );
  PQfreemem( encrypted );

  OBJ_INFECT( rval, password );
  OBJ_INFECT( rval, username );

  return rval;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000006">
                    
                    <a name="M000006"></a><b>conn.escape_bytea( string ) &rarr; String 
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Connection instance method for versions of 8.1 and higher of libpq uses
PQescapeByteaConn, which is safer. Avoid calling as a class method, the
class method uses the deprecated PQescapeBytea() API function.
</p>
<p>
Use the instance method version of this function, it is safer than the
class method.
</p>
<p>
Escapes binary data for use within an SQL command with the type
<tt>bytea</tt>.
</p>
<p>
Certain byte values must be escaped (but all byte values may be escaped)
when used as part of a <tt>bytea</tt> literal in an SQL statement. In
general, to escape a byte, it is converted into the three digit octal
number equal to the octet value, and preceded by two backslashes. The
single quote (&#8217;) and backslash () characters have special alternative
escape sequences. <a href="PGconn.html#M000006">escape_bytea</a> performs
this operation, escaping only the minimally required bytes.
</p>
<p>
Consider using exec_params, which avoids the need for passing values inside
of SQL commands.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000006_source')" id="l_M000006_source">show</a>
                        
                    </p>
                    <div id="M000006_source" class="dyn-source">
                        <pre>static VALUE
pgconn_s_escape_bytea(VALUE self, VALUE str)
{
  unsigned char *from, *to;
  size_t from_len, to_len;
  VALUE ret;

  Check_Type(str, T_STRING);
  from      = (unsigned char*)RSTRING_PTR(str);
  from_len  = RSTRING_LEN(str);

  if(rb_obj_class(self) == rb_cPGconn) {
    to = PQescapeByteaConn(get_pgconn(self), from, from_len, &amp;to_len);
  } else {
    to = PQescapeBytea( from, from_len, &amp;to_len);
  }

  ret = rb_str_new((char*)to, to_len - 1);
  OBJ_INFECT(ret, str);
  PQfreemem(to);
  return ret;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000005">
                    
                    <a name="M000005"></a><b>conn.escape_string( str ) &rarr; String
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Connection instance method for versions of 8.1 and higher of libpq uses
PQescapeStringConn, which is safer. Avoid calling as a class method, the
class method uses the deprecated PQescapeString() API function.
</p>
<p>
Returns a SQL-safe version of the String <em>str</em>. This is the
preferred way to make strings safe for inclusion in SQL queries.
</p>
<p>
Consider using exec_params, which avoids the need for passing values inside
of SQL commands.
</p>
<p>
Encoding of escaped string will be equal to client encoding of connection.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000005_source')" id="l_M000005_source">show</a>
                        
                    </p>
                    <div id="M000005_source" class="dyn-source">
                        <pre>static VALUE
pgconn_s_escape(VALUE self, VALUE string)
{
  char *escaped;
  int size,error;
  VALUE result;
#ifdef M17N_SUPPORTED 
  rb_encoding* enc;
#endif

  Check_Type(string, T_STRING);

  escaped = ALLOC_N(char, RSTRING_LEN(string) * 2 + 1);
  if(rb_obj_class(self) == rb_cPGconn) {
    size = PQescapeStringConn(get_pgconn(self), escaped, 
      RSTRING_PTR(string), RSTRING_LEN(string), &amp;error);
    if(error) {
      xfree(escaped);
      rb_raise(rb_ePGError, &quot;%s&quot;, PQerrorMessage(get_pgconn(self)));
    }
  } else {
    size = PQescapeString(escaped, RSTRING_PTR(string),
      RSTRING_LEN(string));
  }
  result = rb_str_new(escaped, size);
  xfree(escaped);
  OBJ_INFECT(result, string);

#ifdef M17N_SUPPORTED
  if(rb_obj_class(self) == rb_cPGconn) {
    enc = pgconn_get_client_encoding_as_rb_encoding(get_pgconn(self));
  } else {
    enc = rb_enc_get(string);
  }
  rb_enc_associate(result, enc);
#endif

  return result;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000008">
                    
                    <a name="M000008"></a><b>PGconn.isthreadsafe() &rarr; Boolean
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns <tt>true</tt> if libpq is thread safe, <tt>false</tt> otherwise.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000008_source')" id="l_M000008_source">show</a>
                        
                    </p>
                    <div id="M000008_source" class="dyn-source">
                        <pre>static VALUE
pgconn_s_isthreadsafe(VALUE self)
{
  return PQisthreadsafe() ? Qtrue : Qfalse;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000013">
                    
                    <a name="M000013"></a><b>PGconn.new &rarr; PGconn
PGconn.new(connection_hash) &rarr; PGconn
PGconn.new(connection_string) &rarr; PGconn
PGconn.new(host, port, options, tty, dbname, user, password) &rarr;  PGconn
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Create a connection to the specified server.
</p>
<dl>
<dt><tt>host</tt></dt><dd>server hostname

</dd>
<dt><tt>hostaddr</tt></dt><dd>server address (avoids hostname lookup, overrides <tt>host</tt>)

</dd>
<dt><tt>port</tt></dt><dd>server port number

</dd>
<dt><tt>dbname</tt></dt><dd>connecting database name

</dd>
<dt><tt>user</tt></dt><dd>login user name

</dd>
<dt><tt>password</tt></dt><dd>login password

</dd>
<dt><tt>connect_timeout</tt></dt><dd>maximum time to wait for connection to succeed

</dd>
<dt><tt>options</tt></dt><dd>backend options

</dd>
<dt><tt>tty</tt></dt><dd>(ignored in newer versions of PostgreSQL)

</dd>
<dt><tt>sslmode</tt></dt><dd>(disable|allow|prefer|require)

</dd>
<dt><tt>krbsrvname</tt></dt><dd>kerberos service name

</dd>
<dt><tt>gsslib</tt></dt><dd>GSS library to use for GSSAPI authentication

</dd>
<dt><tt>service</tt></dt><dd>service name to use for additional parameters

</dd>
</dl>
<p>
Examples:
</p>
<pre>
  # Connect using all defaults
  PGconn.connect

  # As a Hash
  PGconn.connect( :dbname =&gt; 'test', :port =&gt; 5432 )

  # As a String
  PGconn.connect( &quot;dbname=test port=5432&quot; )

  # As an Array
  PGconn.connect( nil, 5432, nil, nil, 'test', nil, nil )
</pre>
<p>
If the Ruby default internal encoding is set (i.e.,
Encoding.default_internal != nil), the connection will have its
<tt>client_encoding</tt> set accordingly.
</p>
<p>
Raises a <a href="PGError.html">PGError</a> if the connection fails.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000013_source')" id="l_M000013_source">show</a>
                        
                    </p>
                    <div id="M000013_source" class="dyn-source">
                        <pre>static VALUE
pgconn_init(int argc, VALUE *argv, VALUE self)
{
  PGconn *conn = NULL;
  VALUE conninfo;
  VALUE error;
#ifdef M17N_SUPPORTED 
  rb_encoding *enc;
  const char *encname;
#endif

  conninfo = rb_funcall2( rb_cPGconn, rb_intern(&quot;parse_connect_args&quot;), argc, argv );
  conn = PQconnectdb(StringValuePtr(conninfo));

  if(conn == NULL)
    rb_raise(rb_ePGError, &quot;PQconnectStart() unable to allocate structure&quot;);

  Check_Type(self, T_DATA);
  DATA_PTR(self) = conn;

  if (PQstatus(conn) == CONNECTION_BAD) {
    error = rb_exc_new2(rb_ePGError, PQerrorMessage(conn));
    rb_iv_set(error, &quot;@connection&quot;, self);
    rb_exc_raise(error);
  }

#ifdef M17N_SUPPORTED
  /* If Ruby has its Encoding.default_internal set, set PostgreSQL's client_encoding 
   * to match */
  if (( enc = rb_default_internal_encoding() )) {
    encname = pgconn_get_rb_encoding_as_pg_encname( enc );
    if ( PQsetClientEncoding(conn, encname) != 0 )
      rb_warn( &quot;Failed to set the default_internal encoding to %s: '%s'&quot;,
               encname, PQerrorMessage(conn) );
  }
#endif

  if (rb_block_given_p()) {
    return rb_ensure(rb_yield, self, pgconn_finish, self);
  }
  return self;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000001">
                    
                    <a name="M000001"></a><b>parse_connect_args</b>( *args )
                    
                </div>
                
                <div class="description">
                  <p>
Parse the connection <tt>args</tt> into a connection-parameter string. See
<a href="PGconn.html#M000013">PGconn.new</a> for valid arguments.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000001_source')" id="l_M000001_source">show</a>
                        
                    </p>
                    <div id="M000001_source" class="dyn-source">
                        <pre>    <span class="ruby-comment cmt"># File lib/pg.rb, line 33</span>
33:   <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span><span class="ruby-operator">::</span><span class="ruby-identifier">parse_connect_args</span>( <span class="ruby-operator">*</span><span class="ruby-identifier">args</span> )
34:     <span class="ruby-keyword kw">return</span> <span class="ruby-value str">''</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">empty?</span>
35: 
36:     <span class="ruby-comment cmt"># This will be swapped soon for code that makes options like those required for</span>
37:     <span class="ruby-comment cmt"># PQconnectdbParams()/PQconnectStartParams(). For now, stick to an options string for</span>
38:     <span class="ruby-comment cmt"># PQconnectdb()/PQconnectStart().</span>
39:     <span class="ruby-identifier">connopts</span> = []
40: 
41:     <span class="ruby-comment cmt"># Handle an options hash first</span>
42:     <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span>( <span class="ruby-constant">Hash</span> )
43:       <span class="ruby-identifier">opthash</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">pop</span> 
44:       <span class="ruby-identifier">opthash</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">val</span><span class="ruby-operator">|</span>
45:         <span class="ruby-identifier">connopts</span>.<span class="ruby-identifier">push</span>( <span class="ruby-value str">&quot;%s=%s&quot;</span> <span class="ruby-operator">%</span> [<span class="ruby-identifier">key</span>, <span class="ruby-constant">PGconn</span>.<span class="ruby-identifier">quote_connstr</span>(<span class="ruby-identifier">val</span>)] )
46:       <span class="ruby-keyword kw">end</span>
47:     <span class="ruby-keyword kw">end</span>
48: 
49:     <span class="ruby-comment cmt"># Option string style</span>
50:     <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">index</span>( <span class="ruby-value str">'='</span> )
51:       <span class="ruby-identifier">connopts</span>.<span class="ruby-identifier">unshift</span>( <span class="ruby-identifier">args</span>.<span class="ruby-identifier">first</span> )
52: 
53:     <span class="ruby-comment cmt"># Append positional parameters</span>
54:     <span class="ruby-keyword kw">else</span>
55:       <span class="ruby-identifier">args</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">val</span>, <span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
56:         <span class="ruby-keyword kw">next</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">val</span> <span class="ruby-comment cmt"># Skip nil placeholders</span>
57: 
58:         <span class="ruby-identifier">key</span> = <span class="ruby-constant">CONNECT_ARGUMENT_ORDER</span>[ <span class="ruby-identifier">i</span> ] <span class="ruby-keyword kw">or</span>
59:           <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-value str">&quot;Extra positional parameter %d: %p&quot;</span> <span class="ruby-operator">%</span> [ <span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>, <span class="ruby-identifier">val</span> ]
60:         <span class="ruby-identifier">connopts</span>.<span class="ruby-identifier">push</span>( <span class="ruby-value str">&quot;%s=%s&quot;</span> <span class="ruby-operator">%</span> [<span class="ruby-identifier">key</span>, <span class="ruby-constant">PGconn</span>.<span class="ruby-identifier">quote_connstr</span>(<span class="ruby-identifier">val</span>.<span class="ruby-identifier">to_s</span>)] )
61:       <span class="ruby-keyword kw">end</span>
62:     <span class="ruby-keyword kw">end</span>
63: 
64:     <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">connopts</span>.<span class="ruby-identifier">join</span>(<span class="ruby-value str">' '</span>)
65:   <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000000">
                    
                    <a name="M000000"></a><b>quote_connstr</b>( value )
                    
                </div>
                
                <div class="description">
                  <p>
Quote the given <tt>value</tt> for use in a connection-parameter string.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000000_source')" id="l_M000000_source">show</a>
                        
                    </p>
                    <div id="M000000_source" class="dyn-source">
                        <pre>    <span class="ruby-comment cmt"># File lib/pg.rb, line 26</span>
26:   <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span><span class="ruby-operator">::</span><span class="ruby-identifier">quote_connstr</span>( <span class="ruby-identifier">value</span> )
27:     <span class="ruby-keyword kw">return</span> <span class="ruby-value str">&quot;'&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">gsub</span>( <span class="ruby-regexp re">/[\\']/</span> ) {<span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-value str">'\\'</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">m</span> } <span class="ruby-operator">+</span> <span class="ruby-value str">&quot;'&quot;</span>
28:   <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000010">
                    
                    <a name="M000010"></a><b>PGconn.quote_ident( str ) &rarr; String
conn.quote_ident( str ) &rarr; String
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns a string that is safe for inclusion in a SQL query as an
identifier. Note: this is not a quote function for values, but for
identifiers.
</p>
<p>
For example, in a typical SQL query: <tt>SELECT FOO FROM MYTABLE</tt> The
identifier <tt>FOO</tt> is folded to lower case, so it actually means
<tt>foo</tt>. If you really want to access the case-sensitive field name
<tt>FOO</tt>, use this function like <tt><a
href="PGconn.html#M000010">PGconn.quote_ident</a>('FOO')</tt>, which will
return <tt>&quot;FOO&quot;</tt> (with double-quotes). PostgreSQL will see
the double-quotes, and it will not fold to lower case.
</p>
<p>
Similarly, this function also protects against special characters, and
other things that might allow SQL injection if the identifier comes from an
untrusted source.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000010_source')" id="l_M000010_source">show</a>
                        
                    </p>
                    <div id="M000010_source" class="dyn-source">
                        <pre>static VALUE
pgconn_s_quote_ident(VALUE self, VALUE in_str)
{
  VALUE ret;
  char *str = StringValuePtr(in_str);
  /* result size at most NAMEDATALEN*2 plus surrounding
   * double-quotes. */
  char buffer[NAMEDATALEN*2+2];
  unsigned int i=0,j=0;

  if(strlen(str) &gt;= NAMEDATALEN) {
    rb_raise(rb_eArgError, 
      &quot;Input string is longer than NAMEDATALEN-1 (%d)&quot;,
      NAMEDATALEN-1);
  }
  buffer[j++] = '&quot;';
  for(i = 0; i &lt; strlen(str) &amp;&amp; str[i]; i++) {
    if(str[i] == '&quot;') 
      buffer[j++] = '&quot;';
    buffer[j++] = str[i];
  }
  buffer[j++] = '&quot;';
  ret = rb_str_new(buffer,j);
  OBJ_INFECT(ret, in_str);
  return ret;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000007">
                    
                    <a name="M000007"></a><b>PGconn.unescape_bytea( string )
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Converts an escaped string representation of binary data into binary data
&#8212; the reverse of <a href="PGconn.html#M000006">escape_bytea</a>. This
is needed when retrieving <tt>bytea</tt> data in text format, but not when
retrieving it in binary format.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000007_source')" id="l_M000007_source">show</a>
                        
                    </p>
                    <div id="M000007_source" class="dyn-source">
                        <pre>static VALUE
pgconn_s_unescape_bytea(VALUE self, VALUE str)
{
  unsigned char *from, *to;
  size_t to_len;
  VALUE ret;

  Check_Type(str, T_STRING);
  from = (unsigned char*)StringValuePtr(str);

  to = PQunescapeBytea(from, &amp;to_len);

  ret = rb_str_new((char*)to, to_len);
  OBJ_INFECT(ret, str);
  PQfreemem(to);
  return ret;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="sectiontitle">Instance Public methods</div>
            
            <div class="method">
                <div class="title" id="M000073">
                    
                    <a name="M000073"></a><b>conn.async_exec(sql [, params, result_format ] ) &rarr; PGresult
conn.async_exec(sql [, params, result_format ] ) {|pg_result| block }
</b>
                    
                </div>
                
                <div class="description">
                  <p>
This function has the same behavior as +<a
href="PGconn.html#M000037">PGconn#exec</a>+, except that it&#8217;s
implemented using asynchronous command processing and ruby&#8217;s
<tt>rb_thread_select</tt> in order to allow other threads to process while
waiting for the server to complete the request.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000121">async_query</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000073_source')" id="l_M000073_source">show</a>
                        
                    </p>
                    <div id="M000073_source" class="dyn-source">
                        <pre>static VALUE
pgconn_async_exec(int argc, VALUE *argv, VALUE self)
{
  VALUE rb_pgresult = Qnil;

  /* remove any remaining results from the queue */
  pgconn_block( 0, NULL, self ); /* wait for input (without blocking) before reading the last result */
  pgconn_get_last_result( self );

  pgconn_send_query( argc, argv, self );
  pgconn_block( 0, NULL, self );
  rb_pgresult = pgconn_get_last_result( self );

  if ( rb_block_given_p() ) {
    return rb_ensure( rb_yield, rb_pgresult, pgresult_clear, rb_pgresult );
  }
  return rb_pgresult;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000121">
                    
                    <a name="M000121"></a><b>async_query</b>(...)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000073">async_exec</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000034">
                    
                    <a name="M000034"></a><b>conn.backend_pid() &rarr; Fixnum
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the process ID of the backend server process for this connection.
Note that this is a PID on database server host.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000034_source')" id="l_M000034_source">show</a>
                        
                    </p>
                    <div id="M000034_source" class="dyn-source">
                        <pre>static VALUE
pgconn_backend_pid(VALUE self)
{
  return INT2NUM(PQbackendPID(get_pgconn(self)));
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000070">
                    
                    <a name="M000070"></a><b>conn.block( [ timeout ] ) &rarr; Boolean
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Blocks until the server is no longer busy, or until the optional
<em>timeout</em> is reached, whichever comes first. <em>timeout</em> is
measured in seconds and can be fractional.
</p>
<p>
Returns <tt>false</tt> if <em>timeout</em> is reached, <tt>true</tt>
otherwise.
</p>
<p>
If <tt>true</tt> is returned, <tt>conn.is_busy</tt> will return
<tt>false</tt> and <tt>conn.get_result</tt> will not block.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000070_source')" id="l_M000070_source">show</a>
                        
                    </p>
                    <div id="M000070_source" class="dyn-source">
                        <pre>static VALUE
pgconn_block( int argc, VALUE *argv, VALUE self ) </pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000057">
                    
                    <a name="M000057"></a><b>conn.cancel() &rarr; String
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Requests cancellation of the command currently being processed. (Only
implemented in PostgreSQL >= 8.0)
</p>
<p>
Returns <tt>nil</tt> on success, or a string containing the error message
if a failure occurs.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000057_source')" id="l_M000057_source">show</a>
                        
                    </p>
                    <div id="M000057_source" class="dyn-source">
                        <pre>static VALUE
pgconn_cancel(VALUE self)
{
#ifdef HAVE_PQGETCANCEL
  char errbuf[256];
  PGcancel *cancel;
  VALUE retval;
  int ret;

  cancel = PQgetCancel(get_pgconn(self));
  if(cancel == NULL)
    rb_raise(rb_ePGError,&quot;Invalid connection!&quot;);

  ret = PQcancel(cancel, errbuf, 256);
  if(ret == 1)
    retval = Qnil;
  else
    retval = rb_str_new2(errbuf);

  PQfreeCancel(cancel);
  return retval;
#else
  rb_notimplement();
#endif
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000116">
                    
                    <a name="M000116"></a><b>close</b>()
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000015">finish</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000019">
                    
                    <a name="M000019"></a><b>PGconn.conndefaults() &rarr; Array
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns an array of hashes. Each hash has the keys:
</p>
<dl>
<dt><tt>:keyword</tt></dt><dd>the name of the option

</dd>
<dt><tt>:envvar</tt></dt><dd>the environment variable to fall back to

</dd>
<dt><tt>:compiled</tt></dt><dd>the compiled in option as a secondary fallback

</dd>
<dt><tt>:val</tt></dt><dd>the option&#8217;s current value, or <tt>nil</tt> if not known

</dd>
<dt><tt>:label</tt></dt><dd>the label for the field

</dd>
<dt><tt>:dispchar</tt></dt><dd>&#8220;&#8221; for normal, &#8220;D&#8221; for debug, and &#8220;*&#8221;
for password

</dd>
<dt><tt>:dispsize</tt></dt><dd>field size

</dd>
</dl>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000019_source')" id="l_M000019_source">show</a>
                        
                    </p>
                    <div id="M000019_source" class="dyn-source">
                        <pre>static VALUE
pgconn_s_conndefaults(VALUE self)
{
  PQconninfoOption *options = PQconndefaults();
  VALUE ary = rb_ary_new();
  VALUE hash;
  int i = 0;

  for(i = 0; options[i].keyword != NULL; i++) {
    hash = rb_hash_new();
    if(options[i].keyword)
      rb_hash_aset(hash, ID2SYM(rb_intern(&quot;keyword&quot;)), 
        rb_str_new2(options[i].keyword));
    if(options[i].envvar)
      rb_hash_aset(hash, ID2SYM(rb_intern(&quot;envvar&quot;)), 
        rb_str_new2(options[i].envvar));
    if(options[i].compiled)
      rb_hash_aset(hash, ID2SYM(rb_intern(&quot;compiled&quot;)), 
        rb_str_new2(options[i].compiled));
    if(options[i].val)
      rb_hash_aset(hash, ID2SYM(rb_intern(&quot;val&quot;)), 
        rb_str_new2(options[i].val));
    if(options[i].label)
      rb_hash_aset(hash, ID2SYM(rb_intern(&quot;label&quot;)), 
        rb_str_new2(options[i].label));
    if(options[i].dispchar)
      rb_hash_aset(hash, ID2SYM(rb_intern(&quot;dispchar&quot;)), 
        rb_str_new2(options[i].dispchar));
    rb_hash_aset(hash, ID2SYM(rb_intern(&quot;dispsize&quot;)), 
      INT2NUM(options[i].dispsize));
    rb_ary_push(ary, hash);
  }
  PQconninfoFree(options);
  return ary;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000014">
                    
                    <a name="M000014"></a><b>conn.connect_poll() &rarr; Fixnum
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns one of:
</p>
<dl>
<dt><tt><a href="PGconn.html#PGRES_POLLING_READING">PGRES_POLLING_READING</a></tt></dt><dd>wait until the socket is ready to read

</dd>
<dt><tt><a href="PGconn.html#PGRES_POLLING_WRITING">PGRES_POLLING_WRITING</a></tt></dt><dd>wait until the socket is ready to write

</dd>
<dt><tt><a href="PGconn.html#PGRES_POLLING_FAILED">PGRES_POLLING_FAILED</a></tt></dt><dd>the asynchronous connection has failed

</dd>
<dt><tt><a href="PGconn.html#PGRES_POLLING_OK">PGRES_POLLING_OK</a></tt></dt><dd>the asynchronous connection is ready

</dd>
</dl>
<p>
Example:
</p>
<pre>
  conn = PGconn.connect_start(&quot;dbname=mydatabase&quot;)
  socket = IO.for_fd(conn.socket)
  status = conn.connect_poll
  while(status != PGconn::PGRES_POLLING_OK) do
    # do some work while waiting for the connection to complete
    if(status == PGconn::PGRES_POLLING_READING)
      if(not select([socket], [], [], 10.0))
        raise &quot;Asynchronous connection timed out!&quot;
      end
    elsif(status == PGconn::PGRES_POLLING_WRITING)
      if(not select([], [socket], [], 10.0))
        raise &quot;Asynchronous connection timed out!&quot;
      end
    end
    status = conn.connect_poll
  end
  # now conn.status == CONNECTION_OK, and connection
  # is ready.
</pre>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000014_source')" id="l_M000014_source">show</a>
                        
                    </p>
                    <div id="M000014_source" class="dyn-source">
                        <pre>static VALUE
pgconn_connect_poll(VALUE self)
{
  PostgresPollingStatusType status;
  status = PQconnectPoll(get_pgconn(self));
  return INT2FIX((int)status);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000035">
                    
                    <a name="M000035"></a><b>conn.connection_needs_password() &rarr; Boolean
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns <tt>true</tt> if the authentication method required a password, but
none was available. <tt>false</tt> otherwise.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000035_source')" id="l_M000035_source">show</a>
                        
                    </p>
                    <div id="M000035_source" class="dyn-source">
                        <pre>static VALUE
pgconn_connection_needs_password(VALUE self)
{
  return PQconnectionNeedsPassword(get_pgconn(self)) ? Qtrue : Qfalse;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000036">
                    
                    <a name="M000036"></a><b>conn.connection_used_password() &rarr; Boolean
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns <tt>true</tt> if the authentication method used a caller-supplied
password, <tt>false</tt> otherwise.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000036_source')" id="l_M000036_source">show</a>
                        
                    </p>
                    <div id="M000036_source" class="dyn-source">
                        <pre>static VALUE
pgconn_connection_used_password(VALUE self)
{
  return PQconnectionUsedPassword(get_pgconn(self)) ? Qtrue : Qfalse;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000052">
                    
                    <a name="M000052"></a><b>conn.consume_input()
</b>
                    
                </div>
                
                <div class="description">
                  <p>
If input is available from the server, consume it. After calling <tt><a
href="PGconn.html#M000052">consume_input</a></tt>, you can check <tt><a
href="PGconn.html#M000053">is_busy</a></tt> or <b>notifies</b> to see if
the state has changed.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000052_source')" id="l_M000052_source">show</a>
                        
                    </p>
                    <div id="M000052_source" class="dyn-source">
                        <pre>static VALUE
pgconn_consume_input(self)
  VALUE self;
{
  VALUE error;
  PGconn *conn = get_pgconn(self);
  /* returns 0 on error */
  if(PQconsumeInput(conn) == 0) {
    error = rb_exc_new2(rb_ePGError, PQerrorMessage(conn));
    rb_iv_set(error, &quot;@connection&quot;, self);
    rb_exc_raise(error);
  }
  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000020">
                    
                    <a name="M000020"></a><b>conn.db()
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the connected database name.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000020_source')" id="l_M000020_source">show</a>
                        
                    </p>
                    <div id="M000020_source" class="dyn-source">
                        <pre>static VALUE
pgconn_db(VALUE self)
{
  char *db = PQdb(get_pgconn(self));
  if (!db) return Qnil;
  return rb_tainted_str_new2(db);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000041">
                    
                    <a name="M000041"></a><b>conn.describe_portal( portal_name ) &rarr; PGresult
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Retrieve information about the portal <em>portal_name</em>.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000041_source')" id="l_M000041_source">show</a>
                        
                    </p>
                    <div id="M000041_source" class="dyn-source">
                        <pre>static VALUE
pgconn_describe_portal(self, stmt_name)
  VALUE self, stmt_name;
{
  PGresult *result;
  VALUE rb_pgresult;
  PGconn *conn = get_pgconn(self);
  char *stmt;
  if(stmt_name == Qnil) {
    stmt = NULL;
  }
  else {
    Check_Type(stmt_name, T_STRING);
    stmt = StringValuePtr(stmt_name);
  }
  result = PQdescribePortal(conn, stmt);
  rb_pgresult = new_pgresult(result, conn);
  pgresult_check(self, rb_pgresult);
  return rb_pgresult;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000040">
                    
                    <a name="M000040"></a><b>conn.describe_prepared( statement_name ) &rarr; PGresult
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Retrieve information about the prepared statement <em>statement_name</em>.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000040_source')" id="l_M000040_source">show</a>
                        
                    </p>
                    <div id="M000040_source" class="dyn-source">
                        <pre>static VALUE
pgconn_describe_prepared(VALUE self, VALUE stmt_name)
{
  PGresult *result;
  VALUE rb_pgresult;
  PGconn *conn = get_pgconn(self);
  char *stmt;
  if(stmt_name == Qnil) {
    stmt = NULL;
  }
  else {
    Check_Type(stmt_name, T_STRING);
    stmt = StringValuePtr(stmt_name);
  }
  result = PQdescribePrepared(conn, stmt);
  rb_pgresult = new_pgresult(result, conn);
  pgresult_check(self, rb_pgresult);
  return rb_pgresult;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000032">
                    
                    <a name="M000032"></a><b>conn.error_message &rarr; String
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the error message about connection.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000032_source')" id="l_M000032_source">show</a>
                        
                    </p>
                    <div id="M000032_source" class="dyn-source">
                        <pre>static VALUE
pgconn_error_message(VALUE self)
{
  char *error = PQerrorMessage(get_pgconn(self));
  if (!error) return Qnil;
  return rb_tainted_str_new2(error);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000118">
                    
                    <a name="M000118"></a><b>escape</b>(p1)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000005">escape_string</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000044">
                    
                    <a name="M000044"></a><b>conn.escape_bytea( string ) &rarr; String 
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Connection instance method for versions of 8.1 and higher of libpq uses
PQescapeByteaConn, which is safer. Avoid calling as a class method, the
class method uses the deprecated PQescapeBytea() API function.
</p>
<p>
Use the instance method version of this function, it is safer than the
class method.
</p>
<p>
Escapes binary data for use within an SQL command with the type
<tt>bytea</tt>.
</p>
<p>
Certain byte values must be escaped (but all byte values may be escaped)
when used as part of a <tt>bytea</tt> literal in an SQL statement. In
general, to escape a byte, it is converted into the three digit octal
number equal to the octet value, and preceded by two backslashes. The
single quote (&#8217;) and backslash () characters have special alternative
escape sequences. <a href="PGconn.html#M000006">escape_bytea</a> performs
this operation, escaping only the minimally required bytes.
</p>
<p>
Consider using exec_params, which avoids the need for passing values inside
of SQL commands.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000044_source')" id="l_M000044_source">show</a>
                        
                    </p>
                    <div id="M000044_source" class="dyn-source">
                        <pre>static VALUE
pgconn_s_escape_bytea(VALUE self, VALUE str)
{
  unsigned char *from, *to;
  size_t from_len, to_len;
  VALUE ret;

  Check_Type(str, T_STRING);
  from      = (unsigned char*)RSTRING_PTR(str);
  from_len  = RSTRING_LEN(str);

  if(rb_obj_class(self) == rb_cPGconn) {
    to = PQescapeByteaConn(get_pgconn(self), from, from_len, &amp;to_len);
  } else {
    to = PQescapeBytea( from, from_len, &amp;to_len);
  }

  ret = rb_str_new((char*)to, to_len - 1);
  OBJ_INFECT(ret, str);
  PQfreemem(to);
  return ret;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000043">
                    
                    <a name="M000043"></a><b>conn.escape_string( str ) &rarr; String
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Connection instance method for versions of 8.1 and higher of libpq uses
PQescapeStringConn, which is safer. Avoid calling as a class method, the
class method uses the deprecated PQescapeString() API function.
</p>
<p>
Returns a SQL-safe version of the String <em>str</em>. This is the
preferred way to make strings safe for inclusion in SQL queries.
</p>
<p>
Consider using exec_params, which avoids the need for passing values inside
of SQL commands.
</p>
<p>
Encoding of escaped string will be equal to client encoding of connection.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000118">escape</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000043_source')" id="l_M000043_source">show</a>
                        
                    </p>
                    <div id="M000043_source" class="dyn-source">
                        <pre>static VALUE
pgconn_s_escape(VALUE self, VALUE string)
{
  char *escaped;
  int size,error;
  VALUE result;
#ifdef M17N_SUPPORTED 
  rb_encoding* enc;
#endif

  Check_Type(string, T_STRING);

  escaped = ALLOC_N(char, RSTRING_LEN(string) * 2 + 1);
  if(rb_obj_class(self) == rb_cPGconn) {
    size = PQescapeStringConn(get_pgconn(self), escaped, 
      RSTRING_PTR(string), RSTRING_LEN(string), &amp;error);
    if(error) {
      xfree(escaped);
      rb_raise(rb_ePGError, &quot;%s&quot;, PQerrorMessage(get_pgconn(self)));
    }
  } else {
    size = PQescapeString(escaped, RSTRING_PTR(string),
      RSTRING_LEN(string));
  }
  result = rb_str_new(escaped, size);
  xfree(escaped);
  OBJ_INFECT(result, string);

#ifdef M17N_SUPPORTED
  if(rb_obj_class(self) == rb_cPGconn) {
    enc = pgconn_get_client_encoding_as_rb_encoding(get_pgconn(self));
  } else {
    enc = rb_enc_get(string);
  }
  rb_enc_associate(result, enc);
#endif

  return result;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000037">
                    
                    <a name="M000037"></a><b>conn.exec(sql [, params, result_format ] ) &rarr; PGresult
conn.exec(sql [, params, result_format ] ) {|pg_result| block }
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Sends SQL query request specified by <em>sql</em> to PostgreSQL. Returns a
<a href="PGresult.html">PGresult</a> instance on success. On failure, it
raises a <a href="PGError.html">PGError</a> exception.
</p>
<p>
<tt>params</tt> is an optional array of the bind parameters for the SQL
query. Each element of the <tt>params</tt> array may be either:
</p>
<pre>
  a hash of the form:
    {:value  =&gt; String (value of bind parameter)
     :type   =&gt; Fixnum (oid of type of bind parameter)
     :format =&gt; Fixnum (0 for text, 1 for binary)
    }
  or, it may be a String. If it is a string, that is equivalent to the hash:
    { :value =&gt; &lt;string value&gt;, :type =&gt; 0, :format =&gt; 0 }
</pre>
<p>
PostgreSQL bind parameters are represented as $1, $1, $2, etc., inside the
SQL query. The 0th element of the <tt>params</tt> array is bound to $1, the
1st element is bound to $2, etc. <tt>nil</tt> is treated as <tt>NULL</tt>.
</p>
<p>
If the types are not specified, they will be inferred by PostgreSQL.
Instead of specifying type oids, it&#8217;s recommended to simply add
explicit casts in the query to ensure that the right type is used.
</p>
<p>
For example: &#8220;SELECT $1::int&#8220;
</p>
<p>
The optional <tt>result_format</tt> should be 0 for text results, 1 for
binary.
</p>
<p>
If the optional code block is given, it will be passed <em>result</em> as
an argument, and the <a href="PGresult.html">PGresult</a> object will
automatically be cleared when the block terminates. In this instance,
<tt>conn.exec</tt> returns the value of the block.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000117">query</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000037_source')" id="l_M000037_source">show</a>
                        
                    </p>
                    <div id="M000037_source" class="dyn-source">
                        <pre>static VALUE
pgconn_exec(int argc, VALUE *argv, VALUE self)
{
  PGconn *conn = get_pgconn(self);
  PGresult *result = NULL;
  VALUE rb_pgresult;
  VALUE command, params, in_res_fmt;
  VALUE param, param_type, param_value, param_format;
  VALUE param_value_tmp;
  VALUE sym_type, sym_value, sym_format;
  VALUE gc_array;
  int i=0;
  int nParams;
  Oid *paramTypes;
  char ** paramValues;
  int *paramLengths;
  int *paramFormats;
  int resultFormat;

  rb_scan_args(argc, argv, &quot;12&quot;, &amp;command, &amp;params, &amp;in_res_fmt);

  Check_Type(command, T_STRING);

  /* If called with no parameters, use PQexec */
  if(NIL_P(params)) {
    result = PQexec(conn, StringValuePtr(command));
    rb_pgresult = new_pgresult(result, conn);
    pgresult_check(self, rb_pgresult);
    if (rb_block_given_p()) {
      return rb_ensure(rb_yield, rb_pgresult, 
        pgresult_clear, rb_pgresult);
    }
    return rb_pgresult;
  }

  /* If called with parameters, and optionally result_format,
   * use PQexecParams
   */
  Check_Type(params, T_ARRAY);

  if(NIL_P(in_res_fmt)) {
    resultFormat = 0;
  }
  else {
    resultFormat = NUM2INT(in_res_fmt);
  }

  gc_array = rb_ary_new();
  rb_gc_register_address(&amp;gc_array);
  sym_type = ID2SYM(rb_intern(&quot;type&quot;));
  sym_value = ID2SYM(rb_intern(&quot;value&quot;));
  sym_format = ID2SYM(rb_intern(&quot;format&quot;));
  nParams = RARRAY_LEN(params);
  paramTypes = ALLOC_N(Oid, nParams); 
  paramValues = ALLOC_N(char *, nParams);
  paramLengths = ALLOC_N(int, nParams);
  paramFormats = ALLOC_N(int, nParams);
  for(i = 0; i &lt; nParams; i++) {
    param = rb_ary_entry(params, i);
    if (TYPE(param) == T_HASH) {
      param_type = rb_hash_aref(param, sym_type);
      param_value_tmp = rb_hash_aref(param, sym_value);
      if(param_value_tmp == Qnil)
        param_value = param_value_tmp;
      else
        param_value = rb_obj_as_string(param_value_tmp);
      param_format = rb_hash_aref(param, sym_format);
    }
    else {
      param_type = Qnil;
      if(param == Qnil)
        param_value = param;
      else
        param_value = rb_obj_as_string(param);
      param_format = Qnil;
    }

    if(param_type == Qnil)
      paramTypes[i] = 0;
    else
      paramTypes[i] = NUM2INT(param_type);

    if(param_value == Qnil) {
      paramValues[i] = NULL;
      paramLengths[i] = 0;
    }
    else {
      Check_Type(param_value, T_STRING);
      /* make sure param_value doesn't get freed by the GC */
      rb_ary_push(gc_array, param_value);
      paramValues[i] = StringValuePtr(param_value);
      paramLengths[i] = RSTRING_LEN(param_value);
    }

    if(param_format == Qnil)
      paramFormats[i] = 0;
    else
      paramFormats[i] = NUM2INT(param_format);
  }

  result = PQexecParams(conn, StringValuePtr(command), nParams, paramTypes, 
    (const char * const *)paramValues, paramLengths, paramFormats, resultFormat);

  rb_gc_unregister_address(&amp;gc_array);

  xfree(paramTypes);
  xfree(paramValues);
  xfree(paramLengths);
  xfree(paramFormats);

  rb_pgresult = new_pgresult(result, conn);
  pgresult_check(self, rb_pgresult);
  if (rb_block_given_p()) {
    return rb_ensure(rb_yield, rb_pgresult, 
      pgresult_clear, rb_pgresult);
  }
  return rb_pgresult;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000039">
                    
                    <a name="M000039"></a><b>conn.exec_prepared(statement_name [, params, result_format ] ) &rarr; PGresult
conn.exec_prepared(statement_name [, params, result_format ] ) {|pg_result| block }
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Execute prepared named statement specified by <em>statement_name</em>.
Returns a <a href="PGresult.html">PGresult</a> instance on success. On
failure, it raises a <a href="PGError.html">PGError</a> exception.
</p>
<p>
<tt>params</tt> is an array of the optional bind parameters for the SQL
query. Each element of the <tt>params</tt> array may be either:
</p>
<pre>
  a hash of the form:
    {:value  =&gt; String (value of bind parameter)
     :format =&gt; Fixnum (0 for text, 1 for binary)
    }
  or, it may be a String. If it is a string, that is equivalent to the hash:
    { :value =&gt; &lt;string value&gt;, :format =&gt; 0 }
</pre>
<p>
PostgreSQL bind parameters are represented as $1, $1, $2, etc., inside the
SQL query. The 0th element of the <tt>params</tt> array is bound to $1, the
1st element is bound to $2, etc. <tt>nil</tt> is treated as <tt>NULL</tt>.
</p>
<p>
The optional <tt>result_format</tt> should be 0 for text results, 1 for
binary.
</p>
<p>
If the optional code block is given, it will be passed <em>result</em> as
an argument, and the <a href="PGresult.html">PGresult</a> object will
automatically be cleared when the block terminates. In this instance,
<tt>conn.exec_prepared</tt> returns the value of the block.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000039_source')" id="l_M000039_source">show</a>
                        
                    </p>
                    <div id="M000039_source" class="dyn-source">
                        <pre>static VALUE
pgconn_exec_prepared(int argc, VALUE *argv, VALUE self)
{
  PGconn *conn = get_pgconn(self);
  PGresult *result = NULL;
  VALUE rb_pgresult;
  VALUE name, params, in_res_fmt;
  VALUE param, param_value, param_format;
  VALUE param_value_tmp;
  VALUE sym_value, sym_format;
  VALUE gc_array;
  int i = 0;
  int nParams;
  char ** paramValues;
  int *paramLengths;
  int *paramFormats;
  int resultFormat;


  rb_scan_args(argc, argv, &quot;12&quot;, &amp;name, &amp;params, &amp;in_res_fmt);
  Check_Type(name, T_STRING);

  if(NIL_P(params)) {
    params = rb_ary_new2(0);
    resultFormat = 0;
  }
  else {
    Check_Type(params, T_ARRAY);
  }

  if(NIL_P(in_res_fmt)) {
    resultFormat = 0;
  }
  else {
    resultFormat = NUM2INT(in_res_fmt);
  }

  gc_array = rb_ary_new();
  rb_gc_register_address(&amp;gc_array);
  sym_value = ID2SYM(rb_intern(&quot;value&quot;));
  sym_format = ID2SYM(rb_intern(&quot;format&quot;));
  nParams = RARRAY_LEN(params);
  paramValues = ALLOC_N(char *, nParams);
  paramLengths = ALLOC_N(int, nParams);
  paramFormats = ALLOC_N(int, nParams);
  for(i = 0; i &lt; nParams; i++) {
    param = rb_ary_entry(params, i);
    if (TYPE(param) == T_HASH) {
      param_value_tmp = rb_hash_aref(param, sym_value);
      if(param_value_tmp == Qnil)
        param_value = param_value_tmp;
      else
        param_value = rb_obj_as_string(param_value_tmp);
      param_format = rb_hash_aref(param, sym_format);
    }
    else {
      if(param == Qnil)
        param_value = param;
      else
        param_value = rb_obj_as_string(param);
      param_format = INT2NUM(0);
    }
    if(param_value == Qnil) {
      paramValues[i] = NULL;
      paramLengths[i] = 0;
    }
    else {
      Check_Type(param_value, T_STRING);
      /* make sure param_value doesn't get freed by the GC */
      rb_ary_push(gc_array, param_value);
      paramValues[i] = StringValuePtr(param_value);
      paramLengths[i] = RSTRING_LEN(param_value);
    }

    if(param_format == Qnil)
      paramFormats[i] = 0;
    else
      paramFormats[i] = NUM2INT(param_format);
  }

  result = PQexecPrepared(conn, StringValuePtr(name), nParams, 
    (const char * const *)paramValues, paramLengths, paramFormats, 
    resultFormat);

  rb_gc_unregister_address(&amp;gc_array);

  xfree(paramValues);
  xfree(paramLengths);
  xfree(paramFormats);

  rb_pgresult = new_pgresult(result, conn);
  pgresult_check(self, rb_pgresult);
  if (rb_block_given_p()) {
    return rb_ensure(rb_yield, rb_pgresult, 
      pgresult_clear, rb_pgresult);
  }
  return rb_pgresult;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000004">
                    
                    <a name="M000004"></a><b>conn.external_encoding() &rarr; Encoding
</b>
                    
                </div>
                
                <div class="description">
                  <p>
defined in Ruby 1.9 or later.
</p>
<ul>
<li>Returns the server_encoding of the connected database as a Ruby Encoding
object.

</li>
<li>Maps &#8216;SQL_ASCII&#8217; to ASCII-8BIT.

</li>
</ul>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000004_source')" id="l_M000004_source">show</a>
                        
                    </p>
                    <div id="M000004_source" class="dyn-source">
                        <pre>static VALUE
pgconn_external_encoding(VALUE self)
{
  VALUE enc;
  enc = rb_iv_get(self, &quot;@external_encoding&quot;);
  if (RTEST(enc)) {
    return enc;
  }
  else {
    int i;
    VALUE query = rb_usascii_str_new_cstr(&quot;SHOW server_encoding&quot;);
    VALUE pgresult = pgconn_exec(1, &amp;query, self);
    VALUE enc_name = rb_ensure(enc_server_encoding_getvalue, pgresult, pgresult_clear, pgresult);

    if (strcmp(&quot;SQL_ASCII&quot;, StringValuePtr(enc_name)) == 0) {
      enc = rb_enc_from_encoding(rb_ascii8bit_encoding());
      goto cache;
    }
    for (i = 0; i &lt; sizeof(enc_pg2ruby_mapping)/sizeof(enc_pg2ruby_mapping[0]); ++i) {
      if (strcmp(StringValuePtr(enc_name), enc_pg2ruby_mapping[i][0]) == 0) {
        enc = rb_enc_from_encoding(rb_enc_find(enc_pg2ruby_mapping[i][1]));
        goto cache;
      }
    }

    /* Ruby 1.9.1 does not supoort JOHAB */
    if (strcmp(StringValuePtr(enc_name), &quot;JOHAB&quot;) == 0) {
      enc = rb_enc_from_encoding(find_or_create_johab());
      goto cache;
    }

    /* fallback */
    enc = rb_enc_from_encoding(rb_enc_find(StringValuePtr(enc_name)));
  }

cache:
  rb_iv_set(self, &quot;@external_encoding&quot;, enc);
  return enc;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000015">
                    
                    <a name="M000015"></a><b>conn.finish()
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Closes the backend connection.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000116">close</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000015_source')" id="l_M000015_source">show</a>
                        
                    </p>
                    <div id="M000015_source" class="dyn-source">
                        <pre>static VALUE
pgconn_finish(VALUE self)
{
  PQfinish(get_pgconn(self));
  DATA_PTR(self) = NULL;
  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000056">
                    
                    <a name="M000056"></a><b>conn.flush() &rarr; Boolean
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Attempts to flush any queued output data to the server. Returns
<tt>true</tt> if data is successfully flushed, <tt>false</tt> if not (can
only return <tt>false</tt> if connection is nonblocking. Raises <a
href="PGError.html">PGError</a> exception if some other failure occurred.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000056_source')" id="l_M000056_source">show</a>
                        
                    </p>
                    <div id="M000056_source" class="dyn-source">
                        <pre>static VALUE
pgconn_flush(self)
  VALUE self;
{
  PGconn *conn = get_pgconn(self);
  int ret;
  VALUE error;
  ret = PQflush(conn);
  if(ret == -1) {
    error = rb_exc_new2(rb_ePGError, PQerrorMessage(conn));
    rb_iv_set(error, &quot;@connection&quot;, self);
    rb_exc_raise(error);
  }
  return (ret) ? Qfalse : Qtrue;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000067">
                    
                    <a name="M000067"></a><b>conn.get_client_encoding() &rarr; String
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the client encoding as a String.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000067_source')" id="l_M000067_source">show</a>
                        
                    </p>
                    <div id="M000067_source" class="dyn-source">
                        <pre>static VALUE
pgconn_get_client_encoding(VALUE self)
{
  char *encoding = (char *)pg_encoding_to_char(PQclientEncoding(get_pgconn(self)));
  return rb_tainted_str_new2(encoding);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000061">
                    
                    <a name="M000061"></a><b>conn.get_copy_data( [ async = false ] ) &rarr; String
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Return a string containing one row of data, <tt>nil</tt> if the copy is
done, or <tt>false</tt> if the call would block (only possible if
<em>async</em> is true).
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000061_source')" id="l_M000061_source">show</a>
                        
                    </p>
                    <div id="M000061_source" class="dyn-source">
                        <pre>static VALUE
pgconn_get_copy_data(int argc, VALUE *argv, VALUE self )
{
  VALUE async_in;
  VALUE error;
  VALUE result_str;
  int ret;
  int async;
  char *buffer;
  PGconn *conn = get_pgconn(self);

  if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;async_in) == 0)
    async = 0;
  else
    async = (async_in == Qfalse || async_in == Qnil) ? 0 : 1;

  ret = PQgetCopyData(conn, &amp;buffer, async);
  if(ret == -2) { // error
    error = rb_exc_new2(rb_ePGError, PQerrorMessage(conn));
    rb_iv_set(error, &quot;@connection&quot;, self);
    rb_exc_raise(error);
  }
  if(ret == -1) { // No data left
    return Qnil;
  }
  if(ret == 0) { // would block
    return Qfalse;
  }
  result_str = rb_tainted_str_new(buffer, ret);
  PQfreemem(buffer);
  return result_str;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000074">
                    
                    <a name="M000074"></a><b>conn.get_last_result( ) &rarr; PGresult
</b>
                    
                </div>
                
                <div class="description">
                  <p>
This function retrieves all available results on the current connection
(from previously issued asynchronous commands like +<a
href="PGconn.html#M000046">send_query</a>()+) and returns the last non-NULL
result, or <tt>nil</tt> if no results are available.
</p>
<p>
This function is similar to +<a
href="PGconn.html#M000051">PGconn#get_result</a>+ except that it is
designed to get one and only one result.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000074_source')" id="l_M000074_source">show</a>
                        
                    </p>
                    <div id="M000074_source" class="dyn-source">
                        <pre>static VALUE
pgconn_get_last_result(VALUE self)
{
  PGconn *conn = get_pgconn(self);
  VALUE rb_pgresult = Qnil;
  PGresult *cur, *prev;


  cur = prev = NULL;
  while ((cur = PQgetResult(conn)) != NULL) {
    int status;

    if (prev) PQclear(prev);
    prev = cur;

    status = PQresultStatus(cur);
    if (status == PGRES_COPY_OUT || status == PGRES_COPY_IN)
      break;
  }

  if (prev) {
    rb_pgresult = new_pgresult(prev, conn);
    pgresult_check(self, rb_pgresult);
  }

  return rb_pgresult;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000051">
                    
                    <a name="M000051"></a><b>conn.get_result() &rarr; PGresult
conn.get_result() {|pg_result| block }
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Blocks waiting for the next result from a call to +<a
href="PGconn.html#M000046">PGconn#send_query</a>+ (or another asynchronous
command), and returns it. Returns <tt>nil</tt> if no more results are
available.
</p>
<p>
Note: call this function repeatedly until it returns <tt>nil</tt>, or else
you will not be able to issue further commands.
</p>
<p>
If the optional code block is given, it will be passed <em>result</em> as
an argument, and the <a href="PGresult.html">PGresult</a> object will
automatically be cleared when the block terminates. In this instance,
<tt>conn.exec</tt> returns the value of the block.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000051_source')" id="l_M000051_source">show</a>
                        
                    </p>
                    <div id="M000051_source" class="dyn-source">
                        <pre>static VALUE
pgconn_get_result(VALUE self)
{
  PGconn *conn = get_pgconn(self);
  PGresult *result;
  VALUE rb_pgresult;

  result = PQgetResult(conn);
  if(result == NULL)
    return Qnil;
  rb_pgresult = new_pgresult(result, conn);
  if (rb_block_given_p()) {
    return rb_ensure(rb_yield, rb_pgresult,
      pgresult_clear, rb_pgresult);
  }
  return rb_pgresult;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000023">
                    
                    <a name="M000023"></a><b>conn.host()
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the connected server name.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000023_source')" id="l_M000023_source">show</a>
                        
                    </p>
                    <div id="M000023_source" class="dyn-source">
                        <pre>static VALUE
pgconn_host(VALUE self)
{
  char *host = PQhost(get_pgconn(self));
  if (!host) return Qnil;
  return rb_tainted_str_new2(host);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000002">
                    
                    <a name="M000002"></a><b>conn.internal_encoding() &rarr; Encoding
</b>
                    
                </div>
                
                <div class="description">
                  <p>
defined in Ruby 1.9 or later.
</p>
<p>
Returns:
</p>
<ul>
<li>an Encoding - client_encoding of the connection as a Ruby Encoding object.

</li>
<li>nil - the client_encoding is &#8216;SQL_ASCII&#8216;

</li>
</ul>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000002_source')" id="l_M000002_source">show</a>
                        
                    </p>
                    <div id="M000002_source" class="dyn-source">
                        <pre>static VALUE
pgconn_internal_encoding(VALUE self)
{
  return rb_enc_from_encoding(pgconn_get_client_encoding_as_rb_encoding(get_pgconn(self)));
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000003">
                    
                    <a name="M000003"></a><b>conn.internal_encoding = value
</b>
                    
                </div>
                
                <div class="description">
                  <p>
A wrapper of +<a
href="PGconn.html#M000068">PGconn#set_client_encoding</a>+. defined in Ruby
1.9 or later.
</p>
<p>
<tt>value</tt> can be one of:
</p>
<ul>
<li>an Encoding

</li>
<li>a String - a name of Encoding

</li>
<li><tt>nil</tt> - sets &#8216;SQL_ASCII&#8217; to the client_encoding.

</li>
</ul>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000003_source')" id="l_M000003_source">show</a>
                        
                    </p>
                    <div id="M000003_source" class="dyn-source">
                        <pre>static VALUE
pgconn_internal_encoding_set(VALUE self, VALUE enc)
{
  if (NIL_P(enc)) {
    pgconn_set_client_encoding(self, rb_usascii_str_new_cstr(&quot;SQL_ASCII&quot;));
    return enc;
  }
  else if (TYPE(enc) == T_STRING &amp;&amp; strcasecmp(&quot;JOHAB&quot;, RSTRING_PTR(enc)) == 0) {
    pgconn_set_client_encoding(self, rb_usascii_str_new_cstr(&quot;JOHAB&quot;));
    return enc;
  }
  else {
    int i;
    const char *name; 
    name = rb_enc_name(rb_to_encoding(enc));

    /* sequential search becuase rarely called */
    for (i = 0; i &lt; sizeof(enc_pg2ruby_mapping)/sizeof(enc_pg2ruby_mapping[0]); ++i) {
      if (strcmp(name, enc_pg2ruby_mapping[i][1]) == 0) {
        if (PQsetClientEncoding(get_pgconn(self), enc_pg2ruby_mapping[i][0]) == -1) {
          VALUE server_encoding = pgconn_external_encoding(self);
          rb_raise(rb_eEncCompatError, &quot;imcompatible character encodings: %s and %s&quot;,
              rb_enc_name(rb_to_encoding(server_encoding)),
              enc_pg2ruby_mapping[i][0]);
        }
        return enc;
      }
    }

    /* Ruby 1.9.1 does not support JOHAB */
    if (strcasecmp(name, &quot;JOHAB&quot;) == 0) {
      pgconn_set_client_encoding(self, rb_usascii_str_new_cstr(&quot;JOHAB&quot;));
      return enc;
    }
  }

  enc = rb_inspect(enc);
  rb_raise(rb_ePGError, &quot;unknown encoding: %s&quot;, StringValuePtr(enc));
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000053">
                    
                    <a name="M000053"></a><b>conn.is_busy() &rarr; Boolean
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns <tt>true</tt> if a command is busy, that is, if PQgetResult would
block. Otherwise returns <tt>false</tt>.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000053_source')" id="l_M000053_source">show</a>
                        
                    </p>
                    <div id="M000053_source" class="dyn-source">
                        <pre>static VALUE
pgconn_is_busy(self)
  VALUE self;
{
  return PQisBusy(get_pgconn(self)) ? Qtrue : Qfalse;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000055">
                    
                    <a name="M000055"></a><b>conn.isnonblocking() &rarr; Boolean
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns <tt>true</tt> if a command is busy, that is, if PQgetResult would
block. Otherwise returns <tt>false</tt>.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000119">nonblocking?</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000055_source')" id="l_M000055_source">show</a>
                        
                    </p>
                    <div id="M000055_source" class="dyn-source">
                        <pre>static VALUE
pgconn_isnonblocking(self)
  VALUE self;
{
  return PQisnonblocking(get_pgconn(self)) ? Qtrue : Qfalse;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000085">
                    
                    <a name="M000085"></a><b>conn.lo_close( lo_desc ) &rarr; nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Closes the postgres large object of <em>lo_desc</em>.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000134">loclose</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000085_source')" id="l_M000085_source">show</a>
                        
                    </p>
                    <div id="M000085_source" class="dyn-source">
                        <pre>static VALUE
pgconn_loclose(VALUE self, VALUE in_lo_desc)
{
  PGconn *conn = get_pgconn(self);
  int lo_desc = NUM2INT(in_lo_desc);

  if(lo_close(conn,lo_desc) &lt; 0)
    rb_raise(rb_ePGError,&quot;lo_close failed&quot;);

  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000075">
                    
                    <a name="M000075"></a><b>conn.lo_creat( [mode] ) &rarr; Fixnum
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Creates a large object with mode <em>mode</em>. Returns a large object Oid.
On failure, it raises <a href="PGError.html">PGError</a> exception.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000122">locreat</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000075_source')" id="l_M000075_source">show</a>
                        
                    </p>
                    <div id="M000075_source" class="dyn-source">
                        <pre>static VALUE
pgconn_locreat(int argc, VALUE *argv, VALUE self)
{
  Oid lo_oid;
  int mode;
  VALUE nmode;
  PGconn *conn = get_pgconn(self);

  if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;nmode) == 0)
    mode = INV_READ;
  else
    mode = NUM2INT(nmode);

  lo_oid = lo_creat(conn, mode);
  if (lo_oid == 0)
    rb_raise(rb_ePGError, &quot;lo_creat failed&quot;);

  return INT2FIX(lo_oid);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000076">
                    
                    <a name="M000076"></a><b>conn.lo_create( oid ) &rarr; Fixnum
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Creates a large object with oid <em>oid</em>. Returns the large object Oid.
On failure, it raises <a href="PGError.html">PGError</a> exception.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000123">locreate</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000076_source')" id="l_M000076_source">show</a>
                        
                    </p>
                    <div id="M000076_source" class="dyn-source">
                        <pre>static VALUE
pgconn_locreate(VALUE self, VALUE in_lo_oid)
{
  Oid ret, lo_oid;
  PGconn *conn = get_pgconn(self);
  lo_oid = NUM2INT(in_lo_oid);

  ret = lo_create(conn, in_lo_oid);
  if (ret == InvalidOid)
    rb_raise(rb_ePGError, &quot;lo_create failed&quot;);

  return INT2FIX(ret);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000078">
                    
                    <a name="M000078"></a><b>conn.lo_export( oid, file ) &rarr; nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Saves a large object of <em>oid</em> to a <em>file</em>.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000125">loexport</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000078_source')" id="l_M000078_source">show</a>
                        
                    </p>
                    <div id="M000078_source" class="dyn-source">
                        <pre>static VALUE
pgconn_loexport(VALUE self, VALUE lo_oid, VALUE filename)
{
  PGconn *conn = get_pgconn(self);
  int oid;
  Check_Type(filename, T_STRING);

  oid = NUM2INT(lo_oid);
  if (oid &lt; 0) {
    rb_raise(rb_ePGError, &quot;invalid large object oid %d&quot;,oid);
  }

  if (lo_export(conn, oid, StringValuePtr(filename)) &lt; 0) {
    rb_raise(rb_ePGError, &quot;%s&quot;, PQerrorMessage(conn));
  }
  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000077">
                    
                    <a name="M000077"></a><b>conn.lo_import(file) &rarr; Fixnum
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Import a file to a large object. Returns a large object Oid.
</p>
<p>
On failure, it raises a <a href="PGError.html">PGError</a> exception.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000124">loimport</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000077_source')" id="l_M000077_source">show</a>
                        
                    </p>
                    <div id="M000077_source" class="dyn-source">
                        <pre>static VALUE
pgconn_loimport(VALUE self, VALUE filename)
{
  Oid lo_oid;

  PGconn *conn = get_pgconn(self);

  Check_Type(filename, T_STRING);

  lo_oid = lo_import(conn, StringValuePtr(filename));
  if (lo_oid == 0) {
    rb_raise(rb_ePGError, &quot;%s&quot;, PQerrorMessage(conn));
  }
  return INT2FIX(lo_oid);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000082">
                    
                    <a name="M000082"></a><b>conn.lo_lseek( lo_desc, offset, whence ) &rarr; Fixnum
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Move the large object pointer <em>lo_desc</em> to offset <em>offset</em>.
Valid values for <em>whence</em> are <tt><a
href="PGconn.html#SEEK_SET">SEEK_SET</a></tt>, <tt><a
href="PGconn.html#SEEK_CUR">SEEK_CUR</a></tt>, and <tt><a
href="PGconn.html#SEEK_END">SEEK_END</a></tt>. (Or 0, 1, or 2.)
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000129">lolseek</a>
                    
                    <a href="PGconn.html#M000130">lo_seek</a>
                    
                    <a href="PGconn.html#M000131">loseek</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000082_source')" id="l_M000082_source">show</a>
                        
                    </p>
                    <div id="M000082_source" class="dyn-source">
                        <pre>static VALUE
pgconn_lolseek(VALUE self, VALUE in_lo_desc, VALUE offset, VALUE whence)
{
  PGconn *conn = get_pgconn(self);
  int lo_desc = NUM2INT(in_lo_desc);
  int ret;

  if((ret = lo_lseek(conn, lo_desc, NUM2INT(offset), NUM2INT(whence))) &lt; 0) {
    rb_raise(rb_ePGError, &quot;lo_lseek failed&quot;);
  }

  return INT2FIX(ret);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000079">
                    
                    <a name="M000079"></a><b>conn.lo_open( oid, [mode] ) &rarr; Fixnum
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Open a large object of <em>oid</em>. Returns a large object descriptor
instance on success. The <em>mode</em> argument specifies the mode for the
opened large object,which is either <tt><a
href="PGconn.html#INV_READ">INV_READ</a></tt>, or <tt><a
href="PGconn.html#INV_WRITE">INV_WRITE</a></tt>.
</p>
<p>
If <em>mode</em> is omitted, the default is <tt><a
href="PGconn.html#INV_READ">INV_READ</a></tt>.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000126">loopen</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000079_source')" id="l_M000079_source">show</a>
                        
                    </p>
                    <div id="M000079_source" class="dyn-source">
                        <pre>static VALUE
pgconn_loopen(int argc, VALUE *argv, VALUE self)
{
  Oid lo_oid;
  int fd, mode;
  VALUE nmode, selfid;
  PGconn *conn = get_pgconn(self);

  rb_scan_args(argc, argv, &quot;11&quot;, &amp;selfid, &amp;nmode);
  lo_oid = NUM2INT(selfid);
  if(NIL_P(nmode))
    mode = INV_READ;
  else
    mode = NUM2INT(nmode);

  if((fd = lo_open(conn, lo_oid, mode)) &lt; 0) {
    rb_raise(rb_ePGError, &quot;can't open large object: %s&quot;, PQerrorMessage(conn));
  }
  return INT2FIX(fd);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000081">
                    
                    <a name="M000081"></a><b>conn.lo_read( lo_desc, len ) &rarr; String
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Attempts to read <em>len</em> bytes from large object <em>lo_desc</em>,
returns resulting data.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000128">loread</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000081_source')" id="l_M000081_source">show</a>
                        
                    </p>
                    <div id="M000081_source" class="dyn-source">
                        <pre>static VALUE
pgconn_loread(VALUE self, VALUE in_lo_desc, VALUE in_len)
{
  int ret;
  PGconn *conn = get_pgconn(self);
  int len = NUM2INT(in_len);
  int lo_desc = NUM2INT(in_lo_desc);
  VALUE str;
  char *buffer;

  buffer = ALLOC_N(char, len);
  if(buffer == NULL)
    rb_raise(rb_eNoMemError, &quot;ALLOC failed!&quot;);

  if (len &lt; 0){
    rb_raise(rb_ePGError,&quot;nagative length %d given&quot;, len);
  }

  if((ret = lo_read(conn, lo_desc, buffer, len)) &lt; 0)
    rb_raise(rb_ePGError, &quot;lo_read failed&quot;);

  if(ret == 0) {
    xfree(buffer);
    return Qnil;
  }

  str = rb_tainted_str_new(buffer, ret);
  xfree(buffer);

  return str;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000130">
                    
                    <a name="M000130"></a><b>lo_seek</b>(p1, p2, p3)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000082">lo_lseek</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000083">
                    
                    <a name="M000083"></a><b>conn.lo_tell( lo_desc ) &rarr; Fixnum
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the current position of the large object <em>lo_desc</em>.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000132">lotell</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000083_source')" id="l_M000083_source">show</a>
                        
                    </p>
                    <div id="M000083_source" class="dyn-source">
                        <pre>static VALUE
pgconn_lotell(VALUE self, VALUE in_lo_desc)
{
  int position;
  PGconn *conn = get_pgconn(self);
  int lo_desc = NUM2INT(in_lo_desc);

  if((position = lo_tell(conn, lo_desc)) &lt; 0)
    rb_raise(rb_ePGError,&quot;lo_tell failed&quot;);

  return INT2FIX(position);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000084">
                    
                    <a name="M000084"></a><b>conn.lo_truncate( lo_desc, len ) &rarr; nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Truncates the large object <em>lo_desc</em> to size <em>len</em>.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000133">lotruncate</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000084_source')" id="l_M000084_source">show</a>
                        
                    </p>
                    <div id="M000084_source" class="dyn-source">
                        <pre>static VALUE
pgconn_lotruncate(VALUE self, VALUE in_lo_desc, VALUE in_len)
{
  PGconn *conn = get_pgconn(self);
  int lo_desc = NUM2INT(in_lo_desc);
  size_t len = NUM2INT(in_len);

  if(lo_truncate(conn,lo_desc,len) &lt; 0)
    rb_raise(rb_ePGError,&quot;lo_truncate failed&quot;);

  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000086">
                    
                    <a name="M000086"></a><b>conn.lo_unlink( oid ) &rarr; nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Unlinks (deletes) the postgres large object of <em>oid</em>.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000135">lounlink</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000086_source')" id="l_M000086_source">show</a>
                        
                    </p>
                    <div id="M000086_source" class="dyn-source">
                        <pre>static VALUE
pgconn_lounlink(VALUE self, VALUE in_oid)
{
  PGconn *conn = get_pgconn(self);
  int oid = NUM2INT(in_oid);

  if (oid &lt; 0)
    rb_raise(rb_ePGError, &quot;invalid oid %d&quot;,oid);

  if(lo_unlink(conn,oid) &lt; 0)
    rb_raise(rb_ePGError,&quot;lo_unlink failed&quot;);

  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000080">
                    
                    <a name="M000080"></a><b>conn.lo_write( lo_desc, buffer ) &rarr; Fixnum
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Writes the string <em>buffer</em> to the large object <em>lo_desc</em>.
Returns the number of bytes written.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000127">lowrite</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000080_source')" id="l_M000080_source">show</a>
                        
                    </p>
                    <div id="M000080_source" class="dyn-source">
                        <pre>static VALUE
pgconn_lowrite(VALUE self, VALUE in_lo_desc, VALUE buffer)
{
  int n;
  PGconn *conn = get_pgconn(self);
  int fd = NUM2INT(in_lo_desc);

  Check_Type(buffer, T_STRING);

  if( RSTRING_LEN(buffer) &lt; 0) {
    rb_raise(rb_ePGError, &quot;write buffer zero string&quot;);
  }
  if((n = lo_write(conn, fd, StringValuePtr(buffer), 
        RSTRING_LEN(buffer))) &lt; 0) {
    rb_raise(rb_ePGError, &quot;lo_write failed: %s&quot;, PQerrorMessage(conn));
  }

  return INT2FIX(n);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000134">
                    
                    <a name="M000134"></a><b>loclose</b>(p1)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000085">lo_close</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000122">
                    
                    <a name="M000122"></a><b>locreat</b>(...)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000075">lo_creat</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000123">
                    
                    <a name="M000123"></a><b>locreate</b>(p1)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000076">lo_create</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000125">
                    
                    <a name="M000125"></a><b>loexport</b>(p1, p2)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000078">lo_export</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000124">
                    
                    <a name="M000124"></a><b>loimport</b>(p1)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000077">lo_import</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000129">
                    
                    <a name="M000129"></a><b>lolseek</b>(p1, p2, p3)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000082">lo_lseek</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000126">
                    
                    <a name="M000126"></a><b>loopen</b>(...)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000079">lo_open</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000128">
                    
                    <a name="M000128"></a><b>loread</b>(p1, p2)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000081">lo_read</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000131">
                    
                    <a name="M000131"></a><b>loseek</b>(p1, p2, p3)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000082">lo_lseek</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000132">
                    
                    <a name="M000132"></a><b>lotell</b>(p1)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000083">lo_tell</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000133">
                    
                    <a name="M000133"></a><b>lotruncate</b>(p1, p2)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000084">lo_truncate</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000135">
                    
                    <a name="M000135"></a><b>lounlink</b>(p1)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000086">lo_unlink</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000127">
                    
                    <a name="M000127"></a><b>lowrite</b>(p1, p2)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000080">lo_write</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000042">
                    
                    <a name="M000042"></a><b>conn.make_empty_pgresult( status ) &rarr; PGresult
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Constructs and empty <a href="PGresult.html">PGresult</a> with status
<em>status</em>. <em>status</em> may be one of:
</p>
<ul>
<li><tt>PGRES_EMPTY_QUERY</tt>

</li>
<li><tt>PGRES_COMMAND_OK</tt>

</li>
<li><tt>PGRES_TUPLES_OK</tt>

</li>
<li><tt>PGRES_COPY_OUT</tt>

</li>
<li><tt>PGRES_COPY_IN</tt>

</li>
<li><tt>PGRES_BAD_RESPONSE</tt>

</li>
<li><tt>PGRES_NONFATAL_ERROR</tt>

</li>
<li><tt>PGRES_FATAL_ERROR</tt>

</li>
</ul>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000042_source')" id="l_M000042_source">show</a>
                        
                    </p>
                    <div id="M000042_source" class="dyn-source">
                        <pre>static VALUE
pgconn_make_empty_pgresult(VALUE self, VALUE status)
{
  PGresult *result;
  VALUE rb_pgresult;
  PGconn *conn = get_pgconn(self);
  result = PQmakeEmptyPGresult(conn, NUM2INT(status));
  rb_pgresult = new_pgresult(result, conn);
  pgresult_check(self, rb_pgresult);
  return rb_pgresult;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000119">
                    
                    <a name="M000119"></a><b>nonblocking?</b>()
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000055">isnonblocking</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000058">
                    
                    <a name="M000058"></a><b>conn.notifies()
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns a hash of the unprocessed notifications. If there is no unprocessed
notifier, it returns <tt>nil</tt>.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000058_source')" id="l_M000058_source">show</a>
                        
                    </p>
                    <div id="M000058_source" class="dyn-source">
                        <pre>static VALUE
pgconn_notifies(VALUE self)
{
  PGconn* conn = get_pgconn(self);
  PGnotify *notification;
  VALUE hash;
  VALUE sym_relname, sym_be_pid, sym_extra;
  VALUE relname, be_pid, extra;

  sym_relname = ID2SYM(rb_intern(&quot;relname&quot;));
  sym_be_pid = ID2SYM(rb_intern(&quot;be_pid&quot;));
  sym_extra = ID2SYM(rb_intern(&quot;extra&quot;));

  notification = PQnotifies(conn);
  if (notification == NULL) {
    return Qnil;
  }

  hash = rb_hash_new();
  relname = rb_tainted_str_new2(notification-&gt;relname);
  be_pid = INT2NUM(notification-&gt;be_pid);
  extra = rb_tainted_str_new2(PGNOTIFY_EXTRA(notification));

  rb_hash_aset(hash, sym_relname, relname);
  rb_hash_aset(hash, sym_be_pid, be_pid);
  rb_hash_aset(hash, sym_extra, extra);

  PQfreemem(notification);
  return hash;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000120">
                    
                    <a name="M000120"></a><b>notifies_wait</b>(...)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000071">wait_for_notify</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000026">
                    
                    <a name="M000026"></a><b>conn.options()
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns backend option string.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000026_source')" id="l_M000026_source">show</a>
                        
                    </p>
                    <div id="M000026_source" class="dyn-source">
                        <pre>static VALUE
pgconn_options(VALUE self)
{
  char *options = PQoptions(get_pgconn(self));
  if (!options) return Qnil;
  return rb_tainted_str_new2(options);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000029">
                    
                    <a name="M000029"></a><b>conn.parameter_status( param_name ) &rarr; String
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the setting of parameter <em>param_name</em>, where
<em>param_name</em> is one of
</p>
<ul>
<li><tt><a href="PGconn.html#M000031">server_version</a></tt>

</li>
<li><tt>server_encoding</tt>

</li>
<li><tt>client_encoding</tt>

</li>
<li><tt>is_superuser</tt>

</li>
<li><tt>session_authorization</tt>

</li>
<li><tt>DateStyle</tt>

</li>
<li><tt>TimeZone</tt>

</li>
<li><tt>integer_datetimes</tt>

</li>
<li><tt>standard_conforming_strings</tt>

</li>
</ul>
<p>
Returns nil if the value of the parameter is not known.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000029_source')" id="l_M000029_source">show</a>
                        
                    </p>
                    <div id="M000029_source" class="dyn-source">
                        <pre>static VALUE
pgconn_parameter_status(VALUE self, VALUE param_name)
{
  const char *ret = PQparameterStatus(get_pgconn(self), 
      StringValuePtr(param_name));
  if(ret == NULL)
    return Qnil;
  else
    return rb_tainted_str_new2(ret);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000022">
                    
                    <a name="M000022"></a><b>conn.pass()
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the authenticated user name.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000022_source')" id="l_M000022_source">show</a>
                        
                    </p>
                    <div id="M000022_source" class="dyn-source">
                        <pre>static VALUE
pgconn_pass(VALUE self)
{
  char *user = PQpass(get_pgconn(self));
  if (!user) return Qnil;
  return rb_tainted_str_new2(user);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000024">
                    
                    <a name="M000024"></a><b>conn.port()
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the connected server port number.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000024_source')" id="l_M000024_source">show</a>
                        
                    </p>
                    <div id="M000024_source" class="dyn-source">
                        <pre>static VALUE
pgconn_port(VALUE self)
{
  char* port = PQport(get_pgconn(self));
  return INT2NUM(atol(port));
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000038">
                    
                    <a name="M000038"></a><b>conn.prepare(stmt_name, sql [, param_types ] ) &rarr; PGresult
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Prepares statement <em>sql</em> with name <em>name</em> to be executed
later. Returns a <a href="PGresult.html">PGresult</a> instance on success.
On failure, it raises a <a href="PGError.html">PGError</a> exception.
</p>
<p>
<tt>param_types</tt> is an optional parameter to specify the Oids of the
types of the parameters.
</p>
<p>
If the types are not specified, they will be inferred by PostgreSQL.
Instead of specifying type oids, it&#8217;s recommended to simply add
explicit casts in the query to ensure that the right type is used.
</p>
<p>
For example: &#8220;SELECT $1::int&#8220;
</p>
<p>
PostgreSQL bind parameters are represented as $1, $1, $2, etc., inside the
SQL query.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000038_source')" id="l_M000038_source">show</a>
                        
                    </p>
                    <div id="M000038_source" class="dyn-source">
                        <pre>static VALUE
pgconn_prepare(int argc, VALUE *argv, VALUE self)
{
  PGconn *conn = get_pgconn(self);
  PGresult *result = NULL;
  VALUE rb_pgresult;
  VALUE name, command, in_paramtypes;
  VALUE param;
  int i = 0;
  int nParams = 0;
  Oid *paramTypes = NULL;

  rb_scan_args(argc, argv, &quot;21&quot;, &amp;name, &amp;command, &amp;in_paramtypes);
  Check_Type(name, T_STRING);
  Check_Type(command, T_STRING);

  if(! NIL_P(in_paramtypes)) {
    Check_Type(in_paramtypes, T_ARRAY);
    nParams = RARRAY_LEN(in_paramtypes);
    paramTypes = ALLOC_N(Oid, nParams); 
    for(i = 0; i &lt; nParams; i++) {
      param = rb_ary_entry(in_paramtypes, i);
      Check_Type(param, T_FIXNUM);
      if(param == Qnil)
        paramTypes[i] = 0;
      else
        paramTypes[i] = NUM2INT(param);
    }
  }
  result = PQprepare(conn, StringValuePtr(name), StringValuePtr(command),
      nParams, paramTypes);

  xfree(paramTypes);

  rb_pgresult = new_pgresult(result, conn);
  pgresult_check(self, rb_pgresult);
  return rb_pgresult;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000030">
                    
                    <a name="M000030"></a><b>conn.protocol_version &rarr; Integer
</b>
                    
                </div>
                
                <div class="description">
                  <p>
The 3.0 protocol will normally be used when communicating with PostgreSQL
7.4 or later servers; pre-7.4 servers support only protocol 2.0. (Protocol
1.0 is obsolete and not supported by libpq.)
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000030_source')" id="l_M000030_source">show</a>
                        
                    </p>
                    <div id="M000030_source" class="dyn-source">
                        <pre>static VALUE
pgconn_protocol_version(VALUE self)
{
  return INT2NUM(PQprotocolVersion(get_pgconn(self)));
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000059">
                    
                    <a name="M000059"></a><b>conn.put_copy_data( buffer ) &rarr; Boolean
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Transmits <em>buffer</em> as copy data to the server. Returns true if the
data was sent, false if it was not sent (false is only possible if the
connection is in nonblocking mode, and this command would block).
</p>
<p>
Raises an exception if an error occurs.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000059_source')" id="l_M000059_source">show</a>
                        
                    </p>
                    <div id="M000059_source" class="dyn-source">
                        <pre>static VALUE
pgconn_put_copy_data(self, buffer)
  VALUE self, buffer;
{
  int ret;
  VALUE error;
  PGconn *conn = get_pgconn(self);
  Check_Type(buffer, T_STRING);

  ret = PQputCopyData(conn, RSTRING_PTR(buffer),
      RSTRING_LEN(buffer));
  if(ret == -1) {
    error = rb_exc_new2(rb_ePGError, PQerrorMessage(conn));
    rb_iv_set(error, &quot;@connection&quot;, self);
    rb_exc_raise(error);
  }
  return (ret) ? Qtrue : Qfalse;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000060">
                    
                    <a name="M000060"></a><b>conn.put_copy_end( [ error_message ] ) &rarr; Boolean
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Sends end-of-data indication to the server.
</p>
<p>
<em><a href="PGconn.html#M000032">error_message</a></em> is an optional
parameter, and if set, forces the COPY command to fail with the string
<em><a href="PGconn.html#M000032">error_message</a></em>.
</p>
<p>
Returns true if the end-of-data was sent, false if it was not sent (false
is only possible if the connection is in nonblocking mode, and this command
would block).
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000060_source')" id="l_M000060_source">show</a>
                        
                    </p>
                    <div id="M000060_source" class="dyn-source">
                        <pre>static VALUE
pgconn_put_copy_end(int argc, VALUE *argv, VALUE self)
{
  VALUE str;
  VALUE error;
  int ret;
  char *error_message = NULL;
  PGconn *conn = get_pgconn(self);

  if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;str) == 0)
    error_message = NULL;
  else
    error_message = StringValuePtr(str);

  ret = PQputCopyEnd(conn, error_message);
  if(ret == -1) {
    error = rb_exc_new2(rb_ePGError, PQerrorMessage(conn));
    rb_iv_set(error, &quot;@connection&quot;, self);
    rb_exc_raise(error);
  }
  return (ret) ? Qtrue : Qfalse;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000117">
                    
                    <a name="M000117"></a><b>query</b>(...)
                    
                </div>
                
                <div class="description">
                  <p>
Alias for <a href="PGconn.html#M000037">exec</a>
</p>

                </div>
                
                
                
            </div>
            
            <div class="method">
                <div class="title" id="M000072">
                    
                    <a name="M000072"></a><b>PGconn.quote_ident( str ) &rarr; String
conn.quote_ident( str ) &rarr; String
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns a string that is safe for inclusion in a SQL query as an
identifier. Note: this is not a quote function for values, but for
identifiers.
</p>
<p>
For example, in a typical SQL query: <tt>SELECT FOO FROM MYTABLE</tt> The
identifier <tt>FOO</tt> is folded to lower case, so it actually means
<tt>foo</tt>. If you really want to access the case-sensitive field name
<tt>FOO</tt>, use this function like <tt><a
href="PGconn.html#M000010">PGconn.quote_ident</a>('FOO')</tt>, which will
return <tt>&quot;FOO&quot;</tt> (with double-quotes). PostgreSQL will see
the double-quotes, and it will not fold to lower case.
</p>
<p>
Similarly, this function also protects against special characters, and
other things that might allow SQL injection if the identifier comes from an
untrusted source.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000072_source')" id="l_M000072_source">show</a>
                        
                    </p>
                    <div id="M000072_source" class="dyn-source">
                        <pre>static VALUE
pgconn_s_quote_ident(VALUE self, VALUE in_str)
{
  VALUE ret;
  char *str = StringValuePtr(in_str);
  /* result size at most NAMEDATALEN*2 plus surrounding
   * double-quotes. */
  char buffer[NAMEDATALEN*2+2];
  unsigned int i=0,j=0;

  if(strlen(str) &gt;= NAMEDATALEN) {
    rb_raise(rb_eArgError, 
      &quot;Input string is longer than NAMEDATALEN-1 (%d)&quot;,
      NAMEDATALEN-1);
  }
  buffer[j++] = '&quot;';
  for(i = 0; i &lt; strlen(str) &amp;&amp; str[i]; i++) {
    if(str[i] == '&quot;') 
      buffer[j++] = '&quot;';
    buffer[j++] = str[i];
  }
  buffer[j++] = '&quot;';
  ret = rb_str_new(buffer,j);
  OBJ_INFECT(ret, in_str);
  return ret;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000016">
                    
                    <a name="M000016"></a><b>conn.reset()
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Resets the backend connection. This method closes the backend connection
and tries to re-connect.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000016_source')" id="l_M000016_source">show</a>
                        
                    </p>
                    <div id="M000016_source" class="dyn-source">
                        <pre>static VALUE
pgconn_reset(VALUE self)
{
  PQreset(get_pgconn(self));
  return self;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000018">
                    
                    <a name="M000018"></a><b>conn.reset_poll &rarr; Fixnum
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Checks the status of a connection reset operation. See <a
href="PGconn.html#M000011">PGconn#connect_start</a> and <a
href="PGconn.html#M000014">PGconn#connect_poll</a> for usage information
and return values.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000018_source')" id="l_M000018_source">show</a>
                        
                    </p>
                    <div id="M000018_source" class="dyn-source">
                        <pre>static VALUE
pgconn_reset_poll(VALUE self)
{
  PostgresPollingStatusType status;
  status = PQresetPoll(get_pgconn(self));
  return INT2FIX((int)status);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000017">
                    
                    <a name="M000017"></a><b>conn.reset_start() &rarr; nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Initiate a connection reset in a nonblocking manner. This will close the
current connection and attempt to reconnect using the same connection
parameters. Use <a href="PGconn.html#M000018">PGconn#reset_poll</a> to
check the status of the connection reset.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000017_source')" id="l_M000017_source">show</a>
                        
                    </p>
                    <div id="M000017_source" class="dyn-source">
                        <pre>static VALUE
pgconn_reset_start(VALUE self)
{
  if(PQresetStart(get_pgconn(self)) == 0)
    rb_raise(rb_ePGError, &quot;reset has failed&quot;);
  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000050">
                    
                    <a name="M000050"></a><b>conn.send_describe_portal( portal_name ) &rarr; nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Asynchronously send <em>command</em> to the server. Does not block. Use in
combination with <tt>conn.get_result</tt>.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000050_source')" id="l_M000050_source">show</a>
                        
                    </p>
                    <div id="M000050_source" class="dyn-source">
                        <pre>static VALUE
pgconn_send_describe_portal(VALUE self, VALUE portal)
{
  VALUE error;
  PGconn *conn = get_pgconn(self);
  /* returns 0 on failure */
  if(PQsendDescribePortal(conn,StringValuePtr(portal)) == 0) {
    error = rb_exc_new2(rb_ePGError, PQerrorMessage(conn));
    rb_iv_set(error, &quot;@connection&quot;, self);
    rb_exc_raise(error);
  }
  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000049">
                    
                    <a name="M000049"></a><b>conn.send_describe_prepared( statement_name ) &rarr; nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Asynchronously send <em>command</em> to the server. Does not block. Use in
combination with <tt>conn.get_result</tt>.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000049_source')" id="l_M000049_source">show</a>
                        
                    </p>
                    <div id="M000049_source" class="dyn-source">
                        <pre>static VALUE
pgconn_send_describe_prepared(VALUE self, VALUE stmt_name)
{
  VALUE error;
  PGconn *conn = get_pgconn(self);
  /* returns 0 on failure */
  if(PQsendDescribePrepared(conn,StringValuePtr(stmt_name)) == 0) {
    error = rb_exc_new2(rb_ePGError, PQerrorMessage(conn));
    rb_iv_set(error, &quot;@connection&quot;, self);
    rb_exc_raise(error);
  }
  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000047">
                    
                    <a name="M000047"></a><b>conn.send_prepare( stmt_name, sql [, param_types ] ) &rarr; nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Prepares statement <em>sql</em> with name <em>name</em> to be executed
later. Sends prepare command asynchronously, and returns immediately. On
failure, it raises a <a href="PGError.html">PGError</a> exception.
</p>
<p>
<tt>param_types</tt> is an optional parameter to specify the Oids of the
types of the parameters.
</p>
<p>
If the types are not specified, they will be inferred by PostgreSQL.
Instead of specifying type oids, it&#8217;s recommended to simply add
explicit casts in the query to ensure that the right type is used.
</p>
<p>
For example: &#8220;SELECT $1::int&#8220;
</p>
<p>
PostgreSQL bind parameters are represented as $1, $1, $2, etc., inside the
SQL query.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000047_source')" id="l_M000047_source">show</a>
                        
                    </p>
                    <div id="M000047_source" class="dyn-source">
                        <pre>static VALUE
pgconn_send_prepare(int argc, VALUE *argv, VALUE self)
{
  PGconn *conn = get_pgconn(self);
  int result;
  VALUE name, command, in_paramtypes;
  VALUE param;
  VALUE error;
  int i = 0;
  int nParams = 0;
  Oid *paramTypes = NULL;

  rb_scan_args(argc, argv, &quot;21&quot;, &amp;name, &amp;command, &amp;in_paramtypes);
  Check_Type(name, T_STRING);
  Check_Type(command, T_STRING);

  if(! NIL_P(in_paramtypes)) {
    Check_Type(in_paramtypes, T_ARRAY);
    nParams = RARRAY_LEN(in_paramtypes);
    paramTypes = ALLOC_N(Oid, nParams); 
    for(i = 0; i &lt; nParams; i++) {
      param = rb_ary_entry(in_paramtypes, i);
      Check_Type(param, T_FIXNUM);
      if(param == Qnil)
        paramTypes[i] = 0;
      else
        paramTypes[i] = NUM2INT(param);
    }
  }
  result = PQsendPrepare(conn, StringValuePtr(name), StringValuePtr(command),
      nParams, paramTypes);

  xfree(paramTypes);

  if(result == 0) {
    error = rb_exc_new2(rb_ePGError, PQerrorMessage(conn));
    rb_iv_set(error, &quot;@connection&quot;, self);
    rb_exc_raise(error);
  }
  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000046">
                    
                    <a name="M000046"></a><b>conn.send_query(sql [, params, result_format ] ) &rarr; nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Sends SQL query request specified by <em>sql</em> to PostgreSQL for
asynchronous processing, and immediately returns. On failure, it raises a
<a href="PGError.html">PGError</a> exception.
</p>
<p>
<tt>params</tt> is an optional array of the bind parameters for the SQL
query. Each element of the <tt>params</tt> array may be either:
</p>
<pre>
  a hash of the form:
    {:value  =&gt; String (value of bind parameter)
     :type   =&gt; Fixnum (oid of type of bind parameter)
     :format =&gt; Fixnum (0 for text, 1 for binary)
    }
  or, it may be a String. If it is a string, that is equivalent to the hash:
    { :value =&gt; &lt;string value&gt;, :type =&gt; 0, :format =&gt; 0 }
</pre>
<p>
PostgreSQL bind parameters are represented as $1, $1, $2, etc., inside the
SQL query. The 0th element of the <tt>params</tt> array is bound to $1, the
1st element is bound to $2, etc. <tt>nil</tt> is treated as <tt>NULL</tt>.
</p>
<p>
If the types are not specified, they will be inferred by PostgreSQL.
Instead of specifying type oids, it&#8217;s recommended to simply add
explicit casts in the query to ensure that the right type is used.
</p>
<p>
For example: &#8220;SELECT $1::int&#8220;
</p>
<p>
The optional <tt>result_format</tt> should be 0 for text results, 1 for
binary.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000046_source')" id="l_M000046_source">show</a>
                        
                    </p>
                    <div id="M000046_source" class="dyn-source">
                        <pre>static VALUE
pgconn_send_query(int argc, VALUE *argv, VALUE self)
{
  PGconn *conn = get_pgconn(self);
  int result;
  VALUE command, params, in_res_fmt;
  VALUE param, param_type, param_value, param_format;
  VALUE param_value_tmp;
  VALUE sym_type, sym_value, sym_format;
  VALUE gc_array;
  VALUE error;
  int i=0;
  int nParams;
  Oid *paramTypes;
  char ** paramValues;
  int *paramLengths;
  int *paramFormats;
  int resultFormat;

  rb_scan_args(argc, argv, &quot;12&quot;, &amp;command, &amp;params, &amp;in_res_fmt);
  Check_Type(command, T_STRING);

  /* If called with no parameters, use PQsendQuery */
  if(NIL_P(params)) {
    if(PQsendQuery(conn,StringValuePtr(command)) == 0) {
      error = rb_exc_new2(rb_ePGError, PQerrorMessage(conn));
      rb_iv_set(error, &quot;@connection&quot;, self);
      rb_exc_raise(error);
    }
    return Qnil;
  }

  /* If called with parameters, and optionally result_format,
   * use PQsendQueryParams
   */
  Check_Type(params, T_ARRAY);

  if(NIL_P(in_res_fmt)) {
    resultFormat = 0;
  }
  else {
    resultFormat = NUM2INT(in_res_fmt);
  }

  gc_array = rb_ary_new();
  rb_gc_register_address(&amp;gc_array);
  sym_type = ID2SYM(rb_intern(&quot;type&quot;));
  sym_value = ID2SYM(rb_intern(&quot;value&quot;));
  sym_format = ID2SYM(rb_intern(&quot;format&quot;));
  nParams = RARRAY_LEN(params);
  paramTypes = ALLOC_N(Oid, nParams); 
  paramValues = ALLOC_N(char *, nParams);
  paramLengths = ALLOC_N(int, nParams);
  paramFormats = ALLOC_N(int, nParams);
  for(i = 0; i &lt; nParams; i++) {
    param = rb_ary_entry(params, i);
    if (TYPE(param) == T_HASH) {
      param_type = rb_hash_aref(param, sym_type);
      param_value_tmp = rb_hash_aref(param, sym_value);
      if(param_value_tmp == Qnil)
        param_value = param_value_tmp;
      else
        param_value = rb_obj_as_string(param_value_tmp);
      param_format = rb_hash_aref(param, sym_format);
    }
    else {
      param_type = INT2NUM(0);
      if(param == Qnil)
        param_value = param;
      else
        param_value = rb_obj_as_string(param);
      param_format = INT2NUM(0);
    }

    if(param_type == Qnil)
      paramTypes[i] = 0;
    else
      paramTypes[i] = NUM2INT(param_type);

    if(param_value == Qnil) {
      paramValues[i] = NULL;
      paramLengths[i] = 0;
    }
    else {
      Check_Type(param_value, T_STRING);
      /* make sure param_value doesn't get freed by the GC */
      rb_ary_push(gc_array, param_value);
      paramValues[i] = StringValuePtr(param_value);
      paramLengths[i] = RSTRING_LEN(param_value);
    }

    if(param_format == Qnil)
      paramFormats[i] = 0;
    else
      paramFormats[i] = NUM2INT(param_format);
  }

  result = PQsendQueryParams(conn, StringValuePtr(command), nParams, paramTypes, 
    (const char * const *)paramValues, paramLengths, paramFormats, resultFormat);

  rb_gc_unregister_address(&amp;gc_array); 

  xfree(paramTypes);
  xfree(paramValues);
  xfree(paramLengths);
  xfree(paramFormats);

  if(result == 0) {
    error = rb_exc_new2(rb_ePGError, PQerrorMessage(conn));
    rb_iv_set(error, &quot;@connection&quot;, self);
    rb_exc_raise(error);
  }
  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000048">
                    
                    <a name="M000048"></a><b>conn.send_query_prepared( statement_name [, params, result_format ] )
&rarr; nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Execute prepared named statement specified by <em>statement_name</em>
asynchronously, and returns immediately. On failure, it raises a <a
href="PGError.html">PGError</a> exception.
</p>
<p>
<tt>params</tt> is an array of the optional bind parameters for the SQL
query. Each element of the <tt>params</tt> array may be either:
</p>
<pre>
  a hash of the form:
    {:value  =&gt; String (value of bind parameter)
     :format =&gt; Fixnum (0 for text, 1 for binary)
    }
  or, it may be a String. If it is a string, that is equivalent to the hash:
    { :value =&gt; &lt;string value&gt;, :format =&gt; 0 }
</pre>
<p>
PostgreSQL bind parameters are represented as $1, $1, $2, etc., inside the
SQL query. The 0th element of the <tt>params</tt> array is bound to $1, the
1st element is bound to $2, etc. <tt>nil</tt> is treated as <tt>NULL</tt>.
</p>
<p>
The optional <tt>result_format</tt> should be 0 for text results, 1 for
binary.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000048_source')" id="l_M000048_source">show</a>
                        
                    </p>
                    <div id="M000048_source" class="dyn-source">
                        <pre>static VALUE
pgconn_send_query_prepared(int argc, VALUE *argv, VALUE self)
{
  PGconn *conn = get_pgconn(self);
  int result;
  VALUE name, params, in_res_fmt;
  VALUE param, param_value, param_format;
  VALUE param_value_tmp;
  VALUE sym_value, sym_format;
  VALUE gc_array;
  VALUE error;
  int i = 0;
  int nParams;
  char ** paramValues;
  int *paramLengths;
  int *paramFormats;
  int resultFormat;

  rb_scan_args(argc, argv, &quot;12&quot;, &amp;name, &amp;params, &amp;in_res_fmt);
  Check_Type(name, T_STRING);

  if(NIL_P(params)) {
    params = rb_ary_new2(0);
    resultFormat = 0;
  }
  else {
    Check_Type(params, T_ARRAY);
  }

  if(NIL_P(in_res_fmt)) {
    resultFormat = 0;
  }
  else {
    resultFormat = NUM2INT(in_res_fmt);
  }

  gc_array = rb_ary_new();
  rb_gc_register_address(&amp;gc_array);
  sym_value = ID2SYM(rb_intern(&quot;value&quot;));
  sym_format = ID2SYM(rb_intern(&quot;format&quot;));
  nParams = RARRAY_LEN(params);
  paramValues = ALLOC_N(char *, nParams);
  paramLengths = ALLOC_N(int, nParams);
  paramFormats = ALLOC_N(int, nParams);
  for(i = 0; i &lt; nParams; i++) {
    param = rb_ary_entry(params, i);
    if (TYPE(param) == T_HASH) {
      param_value_tmp = rb_hash_aref(param, sym_value);
      if(param_value_tmp == Qnil)
        param_value = param_value_tmp;
      else
        param_value = rb_obj_as_string(param_value_tmp);
      param_format = rb_hash_aref(param, sym_format);
    }
    else {
      if(param == Qnil)
        param_value = param;
      else
        param_value = rb_obj_as_string(param);
      param_format = INT2NUM(0);
    }

    if(param_value == Qnil) {
      paramValues[i] = NULL;
      paramLengths[i] = 0;
    }
    else {
      Check_Type(param_value, T_STRING);
      /* make sure param_value doesn't get freed by the GC */
      rb_ary_push(gc_array, param_value);
      paramValues[i] = StringValuePtr(param_value);
      paramLengths[i] = RSTRING_LEN(param_value);
    }

    if(param_format == Qnil)
      paramFormats[i] = 0;
    else
      paramFormats[i] = NUM2INT(param_format);
  }

  result = PQsendQueryPrepared(conn, StringValuePtr(name), nParams, 
    (const char * const *)paramValues, paramLengths, paramFormats, 
    resultFormat);

  rb_gc_unregister_address(&amp;gc_array);

  xfree(paramValues);
  xfree(paramLengths);
  xfree(paramFormats);

  if(result == 0) {
    error = rb_exc_new2(rb_ePGError, PQerrorMessage(conn));
    rb_iv_set(error, &quot;@connection&quot;, self);
    rb_exc_raise(error);
  }
  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000031">
                    
                    <a name="M000031"></a><b>conn.server_version &rarr; Integer
</b>
                    
                </div>
                
                <div class="description">
                  <p>
The number is formed by converting the major, minor, and revision numbers
into two-decimal-digit numbers and appending them together. For example,
version 7.4.2 will be returned as 70402, and version 8.1 will be returned
as 80100 (leading zeroes are not shown). Zero is returned if the connection
is bad.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000031_source')" id="l_M000031_source">show</a>
                        
                    </p>
                    <div id="M000031_source" class="dyn-source">
                        <pre>static VALUE
pgconn_server_version(VALUE self)
{
  return INT2NUM(PQserverVersion(get_pgconn(self)));
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000068">
                    
                    <a name="M000068"></a><b>conn.set_client_encoding( encoding )
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Sets the client encoding to the <em>encoding</em> String.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000068_source')" id="l_M000068_source">show</a>
                        
                    </p>
                    <div id="M000068_source" class="dyn-source">
                        <pre>static VALUE
pgconn_set_client_encoding(VALUE self, VALUE str)
{
  Check_Type(str, T_STRING);
  if ((PQsetClientEncoding(get_pgconn(self), StringValuePtr(str))) == -1){
    rb_raise(rb_ePGError, &quot;invalid encoding name: %s&quot;,StringValuePtr(str));
  }
  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000062">
                    
                    <a name="M000062"></a><b>conn.set_error_verbosity( verbosity ) &rarr; Fixnum
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Sets connection&#8217;s verbosity to <em>verbosity</em> and returns the
previous setting. Available settings are:
</p>
<ul>
<li><a href="PGconn.html#PQERRORS_TERSE">PQERRORS_TERSE</a>

</li>
<li><a href="PGconn.html#PQERRORS_DEFAULT">PQERRORS_DEFAULT</a>

</li>
<li><a href="PGconn.html#PQERRORS_VERBOSE">PQERRORS_VERBOSE</a>

</li>
</ul>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000062_source')" id="l_M000062_source">show</a>
                        
                    </p>
                    <div id="M000062_source" class="dyn-source">
                        <pre>static VALUE
pgconn_set_error_verbosity(VALUE self, VALUE in_verbosity)
{
  PGconn *conn = get_pgconn(self);
  PGVerbosity verbosity = NUM2INT(in_verbosity);
  return INT2FIX(PQsetErrorVerbosity(conn, verbosity));
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000066">
                    
                    <a name="M000066"></a><b>conn.set_notice_processor {|message| ... } &rarr; Proc
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Notice and warning messages generated by the server are not returned by the
query execution functions, since they do not imply failure of the query.
Instead they are passed to a notice handling function, and execution
continues normally after the handler returns. The default notice handling
function prints the message on <tt>stderr</tt>, but the application can
override this behavior by supplying its own handling function.
</p>
<p>
This function takes a new block to act as the handler, which should accept
a single parameter that will be a <a href="PGresult.html">PGresult</a>
object, and returns the Proc object previously set, or <tt>nil</tt> if it
was previously the default.
</p>
<p>
If you pass no arguments, it will reset the handler to the default.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000066_source')" id="l_M000066_source">show</a>
                        
                    </p>
                    <div id="M000066_source" class="dyn-source">
                        <pre>static VALUE
pgconn_set_notice_processor(VALUE self)
{
  VALUE proc, old_proc;
  PGconn *conn = get_pgconn(self);

  /* If default_notice_processor is unset, assume that the current 
   * notice processor is the default, and save it to a global variable. 
   * This should not be a problem because the default processor is
   * always the same, so won't vary among connections.
   */
  if(default_notice_processor == NULL)
    default_notice_processor = PQsetNoticeProcessor(conn, NULL, NULL);

  old_proc = rb_iv_get(self, &quot;@notice_processor&quot;);
  if( rb_block_given_p() ) {
    proc = rb_block_proc();
    PQsetNoticeProcessor(conn, notice_processor_proxy, (void *)self);
  } else {
    /* if no block is given, set back to default */
    proc = Qnil;
    PQsetNoticeProcessor(conn, default_notice_processor, NULL);
  }

  rb_iv_set(self, &quot;@notice_processor&quot;, proc);
  return old_proc;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000065">
                    
                    <a name="M000065"></a><b>conn.set_notice_receiver {|result| ... } &rarr; Proc
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Notice and warning messages generated by the server are not returned by the
query execution functions, since they do not imply failure of the query.
Instead they are passed to a notice handling function, and execution
continues normally after the handler returns. The default notice handling
function prints the message on <tt>stderr</tt>, but the application can
override this behavior by supplying its own handling function.
</p>
<p>
This function takes a new block to act as the handler, which should accept
a single parameter that will be a <a href="PGresult.html">PGresult</a>
object, and returns the Proc object previously set, or <tt>nil</tt> if it
was previously the default.
</p>
<p>
If you pass no arguments, it will reset the handler to the default.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000065_source')" id="l_M000065_source">show</a>
                        
                    </p>
                    <div id="M000065_source" class="dyn-source">
                        <pre>static VALUE
pgconn_set_notice_receiver(VALUE self)
{
  VALUE proc, old_proc;
  PGconn *conn = get_pgconn(self);

  /* If default_notice_receiver is unset, assume that the current 
   * notice receiver is the default, and save it to a global variable. 
   * This should not be a problem because the default receiver is
   * always the same, so won't vary among connections.
   */
  if(default_notice_receiver == NULL)
    default_notice_receiver = PQsetNoticeReceiver(conn, NULL, NULL);

  old_proc = rb_iv_get(self, &quot;@notice_receiver&quot;);
  if( rb_block_given_p() ) {
    proc = rb_block_proc();
    PQsetNoticeReceiver(conn, notice_receiver_proxy, (void *)self);
  } else {
    /* if no block is given, set back to default */
    proc = Qnil;
    PQsetNoticeReceiver(conn, default_notice_receiver, NULL);
  }

  rb_iv_set(self, &quot;@notice_receiver&quot;, proc);
  return old_proc;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000054">
                    
                    <a name="M000054"></a><b>conn.setnonblocking(Boolean) &rarr; nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Sets the nonblocking status of the connection. In the blocking state, calls
to <a href="PGconn.html#M000046">PGconn#send_query</a> will block until the
message is sent to the server, but will not wait for the query results. In
the nonblocking state, calls to <a
href="PGconn.html#M000046">PGconn#send_query</a> will return an error if
the socket is not ready for writing. Note: This function does not affect <a
href="PGconn.html#M000037">PGconn#exec</a>, because that function
doesn&#8217;t return until the server has processed the query and returned
the results. Returns <tt>nil</tt>.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000054_source')" id="l_M000054_source">show</a>
                        
                    </p>
                    <div id="M000054_source" class="dyn-source">
                        <pre>static VALUE
pgconn_setnonblocking(self, state)
  VALUE self, state;
{
  int arg;
  VALUE error;
  PGconn *conn = get_pgconn(self);
  if(state == Qtrue)
    arg = 1;
  else if (state == Qfalse)
    arg = 0;
  else
    rb_raise(rb_eArgError, &quot;Boolean value expected&quot;);

  if(PQsetnonblocking(conn, arg) == -1) {
    error = rb_exc_new2(rb_ePGError, PQerrorMessage(conn));
    rb_iv_set(error, &quot;@connection&quot;, self);
    rb_exc_raise(error);
  }
  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000033">
                    
                    <a name="M000033"></a><b>conn.socket() &rarr; Fixnum
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the socket&#8217;s file descriptor for this connection.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000033_source')" id="l_M000033_source">show</a>
                        
                    </p>
                    <div id="M000033_source" class="dyn-source">
                        <pre>static VALUE
pgconn_socket(VALUE self)
{
  int sd;
  if( (sd = PQsocket(get_pgconn(self))) &lt; 0)
    rb_raise(rb_ePGError, &quot;Can't get socket descriptor&quot;);
  return INT2NUM(sd);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000027">
                    
                    <a name="M000027"></a><b>conn.status()
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns status of connection : <a
href="PGconn.html#CONNECTION_OK">CONNECTION_OK</a> or <a
href="PGconn.html#CONNECTION_BAD">CONNECTION_BAD</a>
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000027_source')" id="l_M000027_source">show</a>
                        
                    </p>
                    <div id="M000027_source" class="dyn-source">
                        <pre>static VALUE
pgconn_status(VALUE self)
{
  return INT2NUM(PQstatus(get_pgconn(self)));
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000063">
                    
                    <a name="M000063"></a><b>conn.trace( stream ) &rarr; nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Enables tracing message passing between backend. The trace message will be
written to the stream <em>stream</em>, which must implement a method
<tt>fileno</tt> that returns a writable file descriptor.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000063_source')" id="l_M000063_source">show</a>
                        
                    </p>
                    <div id="M000063_source" class="dyn-source">
                        <pre>static VALUE
pgconn_trace(VALUE self, VALUE stream)
{
  VALUE fileno;
  FILE *new_fp;
  int old_fd, new_fd;
  VALUE new_file;

  if(rb_respond_to(stream,rb_intern(&quot;fileno&quot;)) == Qfalse)
    rb_raise(rb_eArgError, &quot;stream does not respond to method: fileno&quot;);

  fileno = rb_funcall(stream, rb_intern(&quot;fileno&quot;), 0);
  if(fileno == Qnil)
    rb_raise(rb_eArgError, &quot;can't get file descriptor from stream&quot;);

  /* Duplicate the file descriptor and re-open
   * it. Then, make it into a ruby File object
   * and assign it to an instance variable.
   * This prevents a problem when the File
   * object passed to this function is closed
   * before the connection object is. */
  old_fd = NUM2INT(fileno);
  new_fd = dup(old_fd);
  new_fp = fdopen(new_fd, &quot;w&quot;);

  if(new_fp == NULL)
    rb_raise(rb_eArgError, &quot;stream is not writable&quot;);

  new_file = rb_funcall(rb_cIO, rb_intern(&quot;new&quot;), 1, INT2NUM(new_fd));
  rb_iv_set(self, &quot;@trace_stream&quot;, new_file);

  PQtrace(get_pgconn(self), new_fp);
  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000069">
                    
                    <a name="M000069"></a><b>conn.transaction { |conn| ... } &rarr; nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Executes a <tt>BEGIN</tt> at the start of the block, and a <tt>COMMIT</tt>
at the end of the block, or <tt>ROLLBACK</tt> if any exception occurs.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000069_source')" id="l_M000069_source">show</a>
                        
                    </p>
                    <div id="M000069_source" class="dyn-source">
                        <pre>static VALUE
pgconn_transaction(VALUE self)
{
  PGconn *conn = get_pgconn(self);
  PGresult *result;
  VALUE rb_pgresult;
  int status;

  if (rb_block_given_p()) {
    result = PQexec(conn, &quot;BEGIN&quot;);
    rb_pgresult = new_pgresult(result, conn);
    pgresult_check(self, rb_pgresult);
    rb_protect(rb_yield, self, &amp;status);
    if(status == 0) {
      result = PQexec(conn, &quot;COMMIT&quot;);
      rb_pgresult = new_pgresult(result, conn);
      pgresult_check(self, rb_pgresult);
    }
    else {
      /* exception occurred, ROLLBACK and re-raise */
      result = PQexec(conn, &quot;ROLLBACK&quot;);
      rb_pgresult = new_pgresult(result, conn);
      pgresult_check(self, rb_pgresult);
      rb_jump_tag(status);
    }

  }
  else {
    /* no block supplied? */
    rb_raise(rb_eArgError, &quot;Must supply block for PGconn#transaction&quot;);
  }
  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000028">
                    
                    <a name="M000028"></a><b>conn.transaction_status()
</b>
                    
                </div>
                
                <div class="description">
                  <p>
returns one of the following statuses:
</p>
<pre>
  PQTRANS_IDLE    = 0 (connection idle)
  PQTRANS_ACTIVE  = 1 (command in progress)
  PQTRANS_INTRANS = 2 (idle, within transaction block)
  PQTRANS_INERROR = 3 (idle, within failed transaction)
  PQTRANS_UNKNOWN = 4 (cannot determine status)
</pre>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000028_source')" id="l_M000028_source">show</a>
                        
                    </p>
                    <div id="M000028_source" class="dyn-source">
                        <pre>static VALUE
pgconn_transaction_status(VALUE self)
{
  return INT2NUM(PQtransactionStatus(get_pgconn(self)));
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000025">
                    
                    <a name="M000025"></a><b>conn.tty()
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the connected pgtty. (Obsolete)
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000025_source')" id="l_M000025_source">show</a>
                        
                    </p>
                    <div id="M000025_source" class="dyn-source">
                        <pre>static VALUE
pgconn_tty(VALUE self)
{
  char *tty = PQtty(get_pgconn(self));
  if (!tty) return Qnil;
  return rb_tainted_str_new2(tty);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000045">
                    
                    <a name="M000045"></a><b>PGconn.unescape_bytea( string )
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Converts an escaped string representation of binary data into binary data
&#8212; the reverse of <a href="PGconn.html#M000006">escape_bytea</a>. This
is needed when retrieving <tt>bytea</tt> data in text format, but not when
retrieving it in binary format.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000045_source')" id="l_M000045_source">show</a>
                        
                    </p>
                    <div id="M000045_source" class="dyn-source">
                        <pre>static VALUE
pgconn_s_unescape_bytea(VALUE self, VALUE str)
{
  unsigned char *from, *to;
  size_t to_len;
  VALUE ret;

  Check_Type(str, T_STRING);
  from = (unsigned char*)StringValuePtr(str);

  to = PQunescapeBytea(from, &amp;to_len);

  ret = rb_str_new((char*)to, to_len);
  OBJ_INFECT(ret, str);
  PQfreemem(to);
  return ret;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000064">
                    
                    <a name="M000064"></a><b>conn.untrace() &rarr; nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Disables the message tracing.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000064_source')" id="l_M000064_source">show</a>
                        
                    </p>
                    <div id="M000064_source" class="dyn-source">
                        <pre>static VALUE
pgconn_untrace(VALUE self)
{
  VALUE trace_stream;
  PQuntrace(get_pgconn(self));
  trace_stream = rb_iv_get(self, &quot;@trace_stream&quot;);
  rb_funcall(trace_stream, rb_intern(&quot;close&quot;), 0);
  rb_iv_set(self, &quot;@trace_stream&quot;, Qnil);
  return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000021">
                    
                    <a name="M000021"></a><b>conn.user()
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the authenticated user name.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000021_source')" id="l_M000021_source">show</a>
                        
                    </p>
                    <div id="M000021_source" class="dyn-source">
                        <pre>static VALUE
pgconn_user(VALUE self)
{
  char *user = PQuser(get_pgconn(self));
  if (!user) return Qnil;
  return rb_tainted_str_new2(user);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000071">
                    
                    <a name="M000071"></a><b>conn.wait_for_notify( [ timeout ] ) &rarr; String
conn.wait_for_notify( [ timeout ] ) { |event, pid| block }
conn.wait_for_notify( [ timeout ] ) { |event, pid, payload| block } # PostgreSQL 9.0
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Blocks while waiting for notification(s), or until the optional
<em>timeout</em> is reached, whichever comes first. <em>timeout</em> is
measured in seconds and can be fractional.
</p>
<p>
Returns <tt>nil</tt> if <em>timeout</em> is reached, the name of the NOTIFY
event otherwise. If used in block form, passes the name of the NOTIFY
<tt>event</tt> and the generating <tt>pid</tt> into the block.
</p>
<p>
Under PostgreSQL 9.0 and later, if the notification is sent with the
optional <tt>payload</tt> string, it will be given to the block as the
third argument.
</p>

                </div>
                
                
                <div class="aka">
                    This method is also aliased as
                    
                    <a href="PGconn.html#M000120">notifies_wait</a>
                    
                </div>
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000071_source')" id="l_M000071_source">show</a>
                        
                    </p>
                    <div id="M000071_source" class="dyn-source">
                        <pre>static VALUE
pgconn_wait_for_notify(int argc, VALUE *argv, VALUE self)
{
  PGconn *conn = get_pgconn( self );
  PGnotify *notification;
  int sd = PQsocket( conn );
  int ret;
  struct timeval timeout;
  struct timeval *ptimeout = NULL;
  VALUE timeout_in = Qnil, relname = Qnil, be_pid = Qnil, extra = Qnil;
  double timeout_sec;
  fd_set sd_rset;
#ifdef _WIN32
  fd_set crt_sd_rset;
#endif

  if ( sd &lt; 0 )
    rb_bug( &quot;PQsocket(conn): couldn't fetch the connection's socket!&quot; );

  rb_scan_args( argc, argv, &quot;01&quot;, &amp;timeout_in );

  if ( RTEST(timeout_in) ) {
    timeout_sec = NUM2DBL( timeout_in );
    timeout.tv_sec = (long)timeout_sec;
    timeout.tv_usec = (long)( (timeout_sec - (long)timeout_sec) * 1e6 );
    ptimeout = &amp;timeout;
  }

  /* Check for notifications */
  while ( (notification = PQnotifies(conn)) == NULL ) {
    FD_ZERO( &amp;sd_rset );
    FD_SET( sd, &amp;sd_rset );

#ifdef _WIN32
    create_crt_fd(&amp;sd_rset, &amp;crt_sd_rset);
#endif

    /* Wait for the socket to become readable before checking again */
    ret = rb_thread_select( sd+1, &amp;sd_rset, NULL, NULL, ptimeout );

#ifdef _WIN32
    cleanup_crt_fd(&amp;sd_rset, &amp;crt_sd_rset);
#endif

    if ( ret &lt; 0 )
      rb_sys_fail( 0 );

    /* Return nil if the select timed out */
    if ( ret == 0 ) return Qnil;

    /* Read the socket */
    if ( (ret = PQconsumeInput(conn)) != 1 )
      rb_raise( rb_ePGError, &quot;PQconsumeInput == %d: %s&quot;, ret, PQerrorMessage(conn) );
  }

  relname = rb_tainted_str_new2( notification-&gt;relname );
  ASSOCIATE_INDEX( relname, self );
  be_pid = INT2NUM( notification-&gt;be_pid );
#ifdef HAVE_ST_NOTIFY_EXTRA
  if ( *notification-&gt;extra ) {
    extra = rb_tainted_str_new2( notification-&gt;extra );
    ASSOCIATE_INDEX( extra, self );
  }
#endif
  PQfreemem( notification );

  if ( rb_block_given_p() )
    rb_yield_values( 3, relname, be_pid, extra );

  return relname;
}</pre>
                    </div>
                </div>
                
            </div>
            
</div>
    </div>
  </body>
</html>    