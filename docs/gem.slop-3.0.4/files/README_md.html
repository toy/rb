<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>README.md</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../css/reset.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" />
    <script src="../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
    <script src="../js/main.js" type="text/javascript" charset="utf-8"></script>
</head>

<body>     
    <div class="banner">
        <h1>
            README.md
        </h1>
        <ul class="files">
            <li>README.md</li>
            <li>Last modified: Mon Feb 06 01:44:18 +0100 2012</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
    
    <div class="description">
        <p>
<a href="../classes/Slop.html">Slop</a>
</p>
<h4></h4>
<p>
<a href="../classes/Slop.html">Slop</a> is a simple option parser with an
easy to remember syntax and friendly API.
</p>
<p>
This README is targeted at <a href="../classes/Slop.html">Slop</a> v3.
</p>
<p>
Installation
</p>
<hr size="10"></hr><p>
### Rubygems
</p>
<pre>
    gem install slop
</pre>
<p>
### GitHub
</p>
<pre>
    git clone git://github.com/injekt/slop.git
    gem build slop.gemspec
    gem install slop-&lt;version&gt;.gem
</pre>
<p>
Usage
</p>
<hr size="3"></hr><p>
```ruby # parse assumes ARGV, otherwise you can pass it your own Array opts
= <a href="../classes/Slop.html#M000026">Slop.parse</a> do
</p>
<pre>
  banner &quot;ruby foo.rb [options]\n&quot;
  on :name=, 'Your name'
  on :p, :password, 'Your password', :argument =&gt; :optional
  on :v :verbose, 'Enable verbose mode'
</pre>
<p>
end
</p>
<p>
# if ARGV is `&#8212;name Lee -v` opts.verbose? #=> true opts.password? #=>
false opts[:name] #=> &#8216;lee&#8217; ```
</p>
<p>
<a href="../classes/Slop.html">Slop</a> supports several methods of writing
options:
</p>
<p>
```ruby # These options all do the same thing on &#8217;-n&#8217;,
&#8217;&#8212;name&#8217;, &#8216;Your name&#8217;, :argument => true on
&#8216;n&#8217;, :name=, &#8216;Your name&#8217; on :n,
&#8217;&#8212;name=&#8217;, &#8216;Your name&#8217;
</p>
<p>
# As do these on &#8216;p&#8217;, &#8217;&#8212;password&#8217;,
&#8216;Your password&#8217;, :argument => :optional on :p, :password,
&#8216;Your password&#8217;, :optional_argument => true on
&#8217;-p&#8217;, &#8216;password=?&#8217;, &#8216;Your password&#8217; ```
</p>
<p>
You can also return your options as a Hash:
</p>
<p>
```ruby opts.to_hash #=> { :name => &#8216;lee&#8217;, :verbose => nil,
:password => nil } ```
</p>
<p>
Printing Help
</p>
<hr size="10"></hr><p>
<a href="../classes/Slop.html">Slop</a> attempts to build a good looking
help string to print to your users. You can see this by calling `opts.help`
or simply `puts opts`.
</p>
<p>
Configuration Options
</p>
<hr size="10"></hr><p>
All of these options can be sent to `<a
href="../classes/Slop.html#M000030">Slop.new</a>` or `<a
href="../classes/Slop.html#M000026">Slop.parse</a>` in Hash form.
</p>
<ul>
<li>`strict` - Enable strict mode. When processing unknown options, <a
href="../classes/Slop.html">Slop</a> will raise an `InvalidOptionError`.
*<b>default:</b>* <b>false</b>.

</li>
<li>`help` - Automatically add the `&#8212;help` option. *<b>default:</b>*
<b>false</b>.

</li>
<li>`banner` - Set this options banner text. *<b>default:</b>* <b>nil</b>.

</li>
<li>`ignore_case` - When enabled, `-A` will look for the `-a` option if `-A`
does not exist. *<b>default:</b>* <b>false</b>.

</li>
<li>`autocreate` - Autocreate options on the fly. *<b>default:</b>*
<b>false</b>.

</li>
<li>`arguments` - Force all options to expect arguments. *<b>default:</b>*
<b>false</b>.

</li>
<li>`optional_arguments` - Force all options to accept optional arguments.
*<b>default:</b>* <b>false</b>.

</li>
<li>`multiple_switches` - When disabled, <a
href="../classes/Slop.html">Slop</a> will parse `-abc` as the option `a`

<pre>
 with the argument `bc` rather than 3 separate options. **default:** *true*.
</pre>
</li>
<li>`longest_flag` - The longest string flag, used to aid configuring help

<pre>
 text. **default:** *0*.
</pre>
</li>
</ul>
<p>
Features
</p>
<hr size="6"></hr><p>
Check out the following wiki pages for more features:
</p>
<ul>
<li>[Ranges](<a
href="https://github.com/injekt/slop/wiki/Ranges">github.com/injekt/slop/wiki/Ranges</a>)

</li>
<li>[Auto Create](<a
href="https://github.com/injekt/slop/wiki/Auto-Create">github.com/injekt/slop/wiki/Auto-Create</a>)

</li>
</ul>
<p>
Woah woah, why you hating on OptionParser?
</p>
<hr size="10"></hr><p>
I&#8217;m not, honestly! I love OptionParser. I really do, it&#8217;s a
fantastic library. So why did I build <a
href="../classes/Slop.html">Slop</a>? Well, I find myself using
OptionParser to simply gather a bunch of key/value options, usually you
would do something like this:
</p>
<p>
```ruby require &#8216;optparse&#8217;
</p>
<p>
things = {}
</p>
<p>
opt = OptionParser.new do |opt|
</p>
<pre>
  opt.on('-n', '--name NAME', 'Your name') do |name|
    things[:name] = name
  end

  opt.on('-a', '--age AGE', 'Your age') do |age|
    things[:age] = age.to_i
  end

  # you get the point
</pre>
<p>
end
</p>
<p>
opt.parse things #=> { :name => &#8216;lee&#8217;, :age => 105 } ```
</p>
<p>
Which is all great and stuff, but it can lead to some repetition. The same
thing in Slop:
</p>
<p>
```ruby require &#8216;slop&#8217;
</p>
<p>
opts = <a href="../classes/Slop.html#M000026">Slop.parse</a> do
</p>
<pre>
  on :n, :name=, 'Your name'
  on :a, :age=, 'Your age', :as =&gt; :int
</pre>
<p>
end
</p>
<p>
opts.to_hash #=> { :name => &#8216;lee&#8217;, :age => 105 } ```
</p>

    </div>
    

    

    
    

    
    

    

    

    

    

    

    
</div>
    </div>
  </body>
</html>