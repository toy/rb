<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>Net::SCP::Download</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../../../css/reset.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" media="screen" />
    <script src="../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../../js/main.js" type="text/javascript" charset="utf-8"></script>
</head>

<body>     
    <div class="banner">
        <h1>
            <span class="type">Module</span> 
            Net::SCP::Download 
            
        </h1>
        <ul class="files">
            
            <li><a href="../../../files/lib/net/scp/download_rb.html">lib/net/scp/download.rb</a></li>
            
            <li><a href="../../../files/lib/net/scp/download_rb.html">lib/net/scp/download.rb</a></li>
            
        </ul>
    </div>
    <div id="bodyContent">
        <div id="content">
    
    <div class="description">
        <p>
This module implements the state machine for downloading information from a
remote server. It exposes no public methods. See <a
href="../SCP.html#M000026">Net::SCP#download</a> for a discussion of how to
use <a href="../SCP.html">Net::SCP</a> to download data.
</p>
<hr size="1"></hr><p>
This module implements the state machine for downloading information from a
remote server. It exposes no public methods. See <a
href="../SCP.html#M000026">Net::SCP#download</a> for a discussion of how to
use <a href="../SCP.html">Net::SCP</a> to download data.
</p>

    </div>
    

    

    
    

    
    
    <div class="sectiontitle">Methods</div>
    <dl class="methods">
    
        <dt>D</dt>
        <dd>
            <ul>
                
                <li><a href="#M000000">download_start_state</a>,</li>
                
                <li><a href="#M000022">download_start_state</a></li>
                
            </ul>
        </dd>
    
        <dt>F</dt>
        <dd>
            <ul>
                
                <li><a href="#M000031">finish_read_state</a>,</li>
                
                <li><a href="#M000005">finish_read_state</a></li>
                
            </ul>
        </dd>
    
        <dt>P</dt>
        <dd>
            <ul>
                
                <li><a href="#M000007">parse_directive</a>,</li>
                
                <li><a href="#M000032">parse_directive</a></li>
                
            </ul>
        </dd>
    
        <dt>R</dt>
        <dd>
            <ul>
                
                <li><a href="#M000003">read_data_state</a>,</li>
                
                <li><a href="#M000029">read_data_state</a>,</li>
                
                <li><a href="#M000001">read_directive_state</a>,</li>
                
                <li><a href="#M000025">read_directive_state</a>,</li>
                
                <li><a href="#M000035">read_directory</a>,</li>
                
                <li><a href="#M000009">read_directory</a>,</li>
                
                <li><a href="#M000011">read_file</a>,</li>
                
                <li><a href="#M000040">read_file</a></li>
                
            </ul>
        </dd>
    
    </dl>
    

    

    

    

    

    

    
            <div class="sectiontitle">Instance Private methods</div>
            
            <div class="method">
                <div class="title" id="M000000">
                    
                    <a name="M000000"></a><b>download_start_state</b>(channel)
                    
                </div>
                
                <div class="description">
                  <p>
This is the starting state for the download state machine. The
start_command method puts the state machine into this state the first time
the channel is processed. This state does some basic error checking and
scaffolding and then sends a 0-byte to the remote server, indicating
readiness to proceed. Then, the state machine is placed into the
&#8220;read directive&#8221; state (see <a
href="Download.html#M000001">read_directive_state</a>).
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000000_source')" id="l_M000000_source">show</a>
                        
                    </p>
                    <div id="M000000_source" class="dyn-source">
                        <pre>    <span class="ruby-comment cmt"># File lib/net/scp/download.rb, line 17</span>
17:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">download_start_state</span>(<span class="ruby-identifier">channel</span>)
18:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>].<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">:write</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span>][<span class="ruby-identifier">:recursive</span>]
19:         <span class="ruby-identifier">raise</span> <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SCP</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-value str">&quot;cannot recursively download to an in-memory location&quot;</span>
20:       <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>].<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">:write</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span>][<span class="ruby-identifier">:preserve</span>]
21:         <span class="ruby-identifier">lwarn</span> { <span class="ruby-value str">&quot;:preserve option is ignored when downloading to an in-memory buffer&quot;</span> }
22:         <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span>].<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:preserve</span>)
23:       <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span>][<span class="ruby-identifier">:recursive</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-constant">File</span>.<span class="ruby-identifier">exists?</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>])
24:         <span class="ruby-constant">Dir</span>.<span class="ruby-identifier">mkdir</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>])
25:       <span class="ruby-keyword kw">end</span>
26: 
27:       <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">send_data</span>(<span class="ruby-value str">&quot;\0&quot;</span>)
28:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:state</span>] = <span class="ruby-identifier">:read_directive</span>
29:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000022">
                    
                    <a name="M000022"></a><b>download_start_state</b>(channel)
                    
                </div>
                
                <div class="description">
                  <p>
This is the starting state for the download state machine. The
start_command method puts the state machine into this state the first time
the channel is processed. This state does some basic error checking and
scaffolding and then sends a 0-byte to the remote server, indicating
readiness to proceed. Then, the state machine is placed into the
&#8220;read directive&#8221; state (see <a
href="Download.html#M000001">read_directive_state</a>).
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000022_source')" id="l_M000022_source">show</a>
                        
                    </p>
                    <div id="M000022_source" class="dyn-source">
                        <pre>    <span class="ruby-comment cmt"># File lib/net/scp/download.rb, line 17</span>
17:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">download_start_state</span>(<span class="ruby-identifier">channel</span>)
18:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>].<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">:write</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span>][<span class="ruby-identifier">:recursive</span>]
19:         <span class="ruby-identifier">raise</span> <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SCP</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-value str">&quot;cannot recursively download to an in-memory location&quot;</span>
20:       <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>].<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">:write</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span>][<span class="ruby-identifier">:preserve</span>]
21:         <span class="ruby-identifier">lwarn</span> { <span class="ruby-value str">&quot;:preserve option is ignored when downloading to an in-memory buffer&quot;</span> }
22:         <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span>].<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:preserve</span>)
23:       <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span>][<span class="ruby-identifier">:recursive</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-constant">File</span>.<span class="ruby-identifier">exists?</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>])
24:         <span class="ruby-constant">Dir</span>.<span class="ruby-identifier">mkdir</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>])
25:       <span class="ruby-keyword kw">end</span>
26: 
27:       <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">send_data</span>(<span class="ruby-value str">&quot;\0&quot;</span>)
28:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:state</span>] = <span class="ruby-identifier">:read_directive</span>
29:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000031">
                    
                    <a name="M000031"></a><b>finish_read_state</b>(channel)
                    
                </div>
                
                <div class="description">
                  <p>
Finishes off the read, sets the times for the file (if any), and then jumps
to either finish_state (for single-file downloads) or <a
href="Download.html#M000001">read_directive_state</a> (for recursive
downloads). A 0-byte is sent to the server to indicate that the file was
recieved successfully.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000031_source')" id="l_M000031_source">show</a>
                        
                    </p>
                    <div id="M000031_source" class="dyn-source">
                        <pre>    <span class="ruby-comment cmt"># File lib/net/scp/download.rb, line 71</span>
71:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">finish_read_state</span>(<span class="ruby-identifier">channel</span>)
72:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:io</span>].<span class="ruby-identifier">close</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:io</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>]
73: 
74:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span>][<span class="ruby-identifier">:preserve</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:times</span>]
75:         <span class="ruby-constant">File</span>.<span class="ruby-identifier">utime</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:times</span>][<span class="ruby-identifier">:atime</span>],
76:           <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:times</span>][<span class="ruby-identifier">:mtime</span>], <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:name</span>])
77:       <span class="ruby-keyword kw">end</span>
78: 
79:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>] = <span class="ruby-keyword kw">nil</span>
80:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:state</span>] = <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:stack</span>].<span class="ruby-identifier">empty?</span> <span class="ruby-value">? </span><span class="ruby-operator">:</span><span class="ruby-identifier">finish</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">:read_directive</span>
81:       <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">send_data</span>(<span class="ruby-value str">&quot;\0&quot;</span>)
82:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000005">
                    
                    <a name="M000005"></a><b>finish_read_state</b>(channel)
                    
                </div>
                
                <div class="description">
                  <p>
Finishes off the read, sets the times for the file (if any), and then jumps
to either finish_state (for single-file downloads) or <a
href="Download.html#M000001">read_directive_state</a> (for recursive
downloads). A 0-byte is sent to the server to indicate that the file was
recieved successfully.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000005_source')" id="l_M000005_source">show</a>
                        
                    </p>
                    <div id="M000005_source" class="dyn-source">
                        <pre>    <span class="ruby-comment cmt"># File lib/net/scp/download.rb, line 71</span>
71:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">finish_read_state</span>(<span class="ruby-identifier">channel</span>)
72:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:io</span>].<span class="ruby-identifier">close</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:io</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>]
73: 
74:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span>][<span class="ruby-identifier">:preserve</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:times</span>]
75:         <span class="ruby-constant">File</span>.<span class="ruby-identifier">utime</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:times</span>][<span class="ruby-identifier">:atime</span>],
76:           <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:times</span>][<span class="ruby-identifier">:mtime</span>], <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:name</span>])
77:       <span class="ruby-keyword kw">end</span>
78: 
79:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>] = <span class="ruby-keyword kw">nil</span>
80:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:state</span>] = <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:stack</span>].<span class="ruby-identifier">empty?</span> <span class="ruby-value">? </span><span class="ruby-operator">:</span><span class="ruby-identifier">finish</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">:read_directive</span>
81:       <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">send_data</span>(<span class="ruby-value str">&quot;\0&quot;</span>)
82:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000007">
                    
                    <a name="M000007"></a><b>parse_directive</b>(text)
                    
                </div>
                
                <div class="description">
                  <p>
Parses the given <tt>text</tt> to extract which <a
href="../SCP.html">SCP</a> directive it contains. It then returns a hash
with at least one key, :type, which describes what type of directive it is.
The hash may also contain other, directive-specific data.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000007_source')" id="l_M000007_source">show</a>
                        
                    </p>
                    <div id="M000007_source" class="dyn-source">
                        <pre>     <span class="ruby-comment cmt"># File lib/net/scp/download.rb, line 88</span>
 88:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">parse_directive</span>(<span class="ruby-identifier">text</span>)
 89:       <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">type</span> = <span class="ruby-identifier">text</span>[<span class="ruby-value">0</span>]
 90:       <span class="ruby-keyword kw">when</span> <span class="ruby-value">?T</span>
 91:         <span class="ruby-identifier">parts</span> = <span class="ruby-identifier">text</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">split</span>(<span class="ruby-regexp re">/ /</span>, <span class="ruby-value">4</span>).<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>.<span class="ruby-identifier">to_i</span> }
 92:         { <span class="ruby-identifier">:type</span>  =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">:times</span>,
 93:           <span class="ruby-identifier">:mtime</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">at</span>(<span class="ruby-identifier">parts</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">parts</span>[<span class="ruby-value">1</span>]),
 94:           <span class="ruby-identifier">:atime</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">at</span>(<span class="ruby-identifier">parts</span>[<span class="ruby-value">2</span>], <span class="ruby-identifier">parts</span>[<span class="ruby-value">3</span>]) }
 95:       <span class="ruby-keyword kw">when</span> <span class="ruby-value">?C</span>, <span class="ruby-value">?D</span>
 96:         <span class="ruby-identifier">parts</span> = <span class="ruby-identifier">text</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">split</span>(<span class="ruby-regexp re">/ /</span>, <span class="ruby-value">3</span>)
 97:         { <span class="ruby-identifier">:type</span> =<span class="ruby-operator">&gt;</span> (<span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-value">?C</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">:file</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">:directory</span>),
 98:           <span class="ruby-identifier">:mode</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">parts</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">to_i</span>(<span class="ruby-value">8</span>),
 99:           <span class="ruby-identifier">:size</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">parts</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">to_i</span>,
100:           <span class="ruby-identifier">:name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">parts</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">chomp</span> }
101:       <span class="ruby-keyword kw">when</span> <span class="ruby-value">?E</span>
102:         { <span class="ruby-identifier">:type</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">:end</span> }
103:       <span class="ruby-keyword kw">else</span> <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-node">&quot;unknown directive: #{text.inspect}&quot;</span>
104:       <span class="ruby-keyword kw">end</span>
105:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000032">
                    
                    <a name="M000032"></a><b>parse_directive</b>(text)
                    
                </div>
                
                <div class="description">
                  <p>
Parses the given <tt>text</tt> to extract which <a
href="../SCP.html">SCP</a> directive it contains. It then returns a hash
with at least one key, :type, which describes what type of directive it is.
The hash may also contain other, directive-specific data.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000032_source')" id="l_M000032_source">show</a>
                        
                    </p>
                    <div id="M000032_source" class="dyn-source">
                        <pre>     <span class="ruby-comment cmt"># File lib/net/scp/download.rb, line 88</span>
 88:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">parse_directive</span>(<span class="ruby-identifier">text</span>)
 89:       <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">type</span> = <span class="ruby-identifier">text</span>[<span class="ruby-value">0</span>]
 90:       <span class="ruby-keyword kw">when</span> <span class="ruby-value">?T</span>
 91:         <span class="ruby-identifier">parts</span> = <span class="ruby-identifier">text</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">split</span>(<span class="ruby-regexp re">/ /</span>, <span class="ruby-value">4</span>).<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>.<span class="ruby-identifier">to_i</span> }
 92:         { <span class="ruby-identifier">:type</span>  =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">:times</span>,
 93:           <span class="ruby-identifier">:mtime</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">at</span>(<span class="ruby-identifier">parts</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">parts</span>[<span class="ruby-value">1</span>]),
 94:           <span class="ruby-identifier">:atime</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">at</span>(<span class="ruby-identifier">parts</span>[<span class="ruby-value">2</span>], <span class="ruby-identifier">parts</span>[<span class="ruby-value">3</span>]) }
 95:       <span class="ruby-keyword kw">when</span> <span class="ruby-value">?C</span>, <span class="ruby-value">?D</span>
 96:         <span class="ruby-identifier">parts</span> = <span class="ruby-identifier">text</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">split</span>(<span class="ruby-regexp re">/ /</span>, <span class="ruby-value">3</span>)
 97:         { <span class="ruby-identifier">:type</span> =<span class="ruby-operator">&gt;</span> (<span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-value">?C</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">:file</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">:directory</span>),
 98:           <span class="ruby-identifier">:mode</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">parts</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">to_i</span>(<span class="ruby-value">8</span>),
 99:           <span class="ruby-identifier">:size</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">parts</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">to_i</span>,
100:           <span class="ruby-identifier">:name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">parts</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">chomp</span> }
101:       <span class="ruby-keyword kw">when</span> <span class="ruby-value">?E</span>
102:         { <span class="ruby-identifier">:type</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">:end</span> }
103:       <span class="ruby-keyword kw">else</span> <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-node">&quot;unknown directive: #{text.inspect}&quot;</span>
104:       <span class="ruby-keyword kw">end</span>
105:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000003">
                    
                    <a name="M000003"></a><b>read_data_state</b>(channel)
                    
                </div>
                
                <div class="description">
                  <p>
Reads data from the channel for as long as there is data remaining to be
read. As soon as there is no more data to read for the current file, the
state machine switches to <a
href="Download.html#M000005">finish_read_state</a>.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000003_source')" id="l_M000003_source">show</a>
                        
                    </p>
                    <div id="M000003_source" class="dyn-source">
                        <pre>    <span class="ruby-comment cmt"># File lib/net/scp/download.rb, line 58</span>
58:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">read_data_state</span>(<span class="ruby-identifier">channel</span>)
59:       <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:buffer</span>].<span class="ruby-identifier">empty?</span>
60:       <span class="ruby-identifier">data</span> = <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:buffer</span>].<span class="ruby-identifier">read!</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:remaining</span>])
61:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:io</span>].<span class="ruby-identifier">write</span>(<span class="ruby-identifier">data</span>)
62:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:remaining</span>] <span class="ruby-operator">-=</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">length</span>
63:       <span class="ruby-identifier">progress_callback</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:name</span>], <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:size</span>] <span class="ruby-operator">-</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:remaining</span>], <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:size</span>])
64:       <span class="ruby-identifier">await_response</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">:finish_read</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:remaining</span>] <span class="ruby-operator">&lt;=</span> <span class="ruby-value">0</span>
65:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000029">
                    
                    <a name="M000029"></a><b>read_data_state</b>(channel)
                    
                </div>
                
                <div class="description">
                  <p>
Reads data from the channel for as long as there is data remaining to be
read. As soon as there is no more data to read for the current file, the
state machine switches to <a
href="Download.html#M000005">finish_read_state</a>.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000029_source')" id="l_M000029_source">show</a>
                        
                    </p>
                    <div id="M000029_source" class="dyn-source">
                        <pre>    <span class="ruby-comment cmt"># File lib/net/scp/download.rb, line 58</span>
58:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">read_data_state</span>(<span class="ruby-identifier">channel</span>)
59:       <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:buffer</span>].<span class="ruby-identifier">empty?</span>
60:       <span class="ruby-identifier">data</span> = <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:buffer</span>].<span class="ruby-identifier">read!</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:remaining</span>])
61:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:io</span>].<span class="ruby-identifier">write</span>(<span class="ruby-identifier">data</span>)
62:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:remaining</span>] <span class="ruby-operator">-=</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">length</span>
63:       <span class="ruby-identifier">progress_callback</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:name</span>], <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:size</span>] <span class="ruby-operator">-</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:remaining</span>], <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:size</span>])
64:       <span class="ruby-identifier">await_response</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">:finish_read</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:remaining</span>] <span class="ruby-operator">&lt;=</span> <span class="ruby-value">0</span>
65:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000001">
                    
                    <a name="M000001"></a><b>read_directive_state</b>(channel)
                    
                </div>
                
                <div class="description">
                  <p>
This state parses the next full line (up to a new-line) for the next
directive. (See the <a href="../SCP.html">SCP</a> protocol documentation in
<a href="../SCP.html">Net::SCP</a> for the possible directives).
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000001_source')" id="l_M000001_source">show</a>
                        
                    </p>
                    <div id="M000001_source" class="dyn-source">
                        <pre>    <span class="ruby-comment cmt"># File lib/net/scp/download.rb, line 34</span>
34:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">read_directive_state</span>(<span class="ruby-identifier">channel</span>)
35:       <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">line</span> = <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:buffer</span>].<span class="ruby-identifier">read_to</span>(<span class="ruby-value str">&quot;\n&quot;</span>)
36:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:buffer</span>].<span class="ruby-identifier">consume!</span>
37: 
38:       <span class="ruby-identifier">directive</span> = <span class="ruby-identifier">parse_directive</span>(<span class="ruby-identifier">line</span>)
39:       <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">directive</span>[<span class="ruby-identifier">:type</span>]
40:       <span class="ruby-keyword kw">when</span> <span class="ruby-identifier">:times</span> <span class="ruby-keyword kw">then</span>
41:         <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:times</span>] = <span class="ruby-identifier">directive</span>
42:       <span class="ruby-keyword kw">when</span> <span class="ruby-identifier">:directory</span>
43:         <span class="ruby-identifier">read_directory</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">directive</span>)
44:       <span class="ruby-keyword kw">when</span> <span class="ruby-identifier">:file</span>
45:         <span class="ruby-identifier">read_file</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">directive</span>)
46:       <span class="ruby-keyword kw">when</span> <span class="ruby-identifier">:end</span>
47:         <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>] = <span class="ruby-constant">File</span>.<span class="ruby-identifier">dirname</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>])
48:         <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:stack</span>].<span class="ruby-identifier">pop</span>
49:         <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:state</span>] = <span class="ruby-identifier">:finish</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:stack</span>].<span class="ruby-identifier">empty?</span>
50:       <span class="ruby-keyword kw">end</span>
51: 
52:       <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">send_data</span>(<span class="ruby-value str">&quot;\0&quot;</span>)
53:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000025">
                    
                    <a name="M000025"></a><b>read_directive_state</b>(channel)
                    
                </div>
                
                <div class="description">
                  <p>
This state parses the next full line (up to a new-line) for the next
directive. (See the <a href="../SCP.html">SCP</a> protocol documentation in
<a href="../SCP.html">Net::SCP</a> for the possible directives).
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000025_source')" id="l_M000025_source">show</a>
                        
                    </p>
                    <div id="M000025_source" class="dyn-source">
                        <pre>    <span class="ruby-comment cmt"># File lib/net/scp/download.rb, line 34</span>
34:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">read_directive_state</span>(<span class="ruby-identifier">channel</span>)
35:       <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">line</span> = <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:buffer</span>].<span class="ruby-identifier">read_to</span>(<span class="ruby-value str">&quot;\n&quot;</span>)
36:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:buffer</span>].<span class="ruby-identifier">consume!</span>
37: 
38:       <span class="ruby-identifier">directive</span> = <span class="ruby-identifier">parse_directive</span>(<span class="ruby-identifier">line</span>)
39:       <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">directive</span>[<span class="ruby-identifier">:type</span>]
40:       <span class="ruby-keyword kw">when</span> <span class="ruby-identifier">:times</span> <span class="ruby-keyword kw">then</span>
41:         <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:times</span>] = <span class="ruby-identifier">directive</span>
42:       <span class="ruby-keyword kw">when</span> <span class="ruby-identifier">:directory</span>
43:         <span class="ruby-identifier">read_directory</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">directive</span>)
44:       <span class="ruby-keyword kw">when</span> <span class="ruby-identifier">:file</span>
45:         <span class="ruby-identifier">read_file</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">directive</span>)
46:       <span class="ruby-keyword kw">when</span> <span class="ruby-identifier">:end</span>
47:         <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>] = <span class="ruby-constant">File</span>.<span class="ruby-identifier">dirname</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>])
48:         <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:stack</span>].<span class="ruby-identifier">pop</span>
49:         <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:state</span>] = <span class="ruby-identifier">:finish</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:stack</span>].<span class="ruby-identifier">empty?</span>
50:       <span class="ruby-keyword kw">end</span>
51: 
52:       <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">send_data</span>(<span class="ruby-value str">&quot;\0&quot;</span>)
53:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000035">
                    
                    <a name="M000035"></a><b>read_directory</b>(channel, directive)
                    
                </div>
                
                <div class="description">
                  <p>
Sets the new directory as the current directory, creates the directory if
it does not exist, and then falls back into <a
href="Download.html#M000001">read_directive_state</a>.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000035_source')" id="l_M000035_source">show</a>
                        
                    </p>
                    <div id="M000035_source" class="dyn-source">
                        <pre>     <span class="ruby-comment cmt"># File lib/net/scp/download.rb, line 109</span>
109:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">read_directory</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">directive</span>)
110:       <span class="ruby-keyword kw">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span>][<span class="ruby-identifier">:recursive</span>]
111:         <span class="ruby-identifier">raise</span> <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SCP</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-value str">&quot;:recursive not specified for directory download&quot;</span>
112:       <span class="ruby-keyword kw">end</span>
113: 
114:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>] = <span class="ruby-constant">File</span>.<span class="ruby-identifier">join</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>], <span class="ruby-identifier">directive</span>[<span class="ruby-identifier">:name</span>])
115: 
116:       <span class="ruby-keyword kw">if</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">exists?</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>]) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-constant">File</span>.<span class="ruby-identifier">directory?</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>])
117:         <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;#{channel[:local]} already exists and is not a directory&quot;</span>
118:       <span class="ruby-keyword kw">elsif</span> <span class="ruby-operator">!</span><span class="ruby-constant">File</span>.<span class="ruby-identifier">exists?</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>])
119:         <span class="ruby-constant">Dir</span>.<span class="ruby-identifier">mkdir</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>], <span class="ruby-identifier">directive</span>[<span class="ruby-identifier">:mode</span>] <span class="ruby-operator">|</span> <span class="ruby-value">0700</span>)
120:       <span class="ruby-keyword kw">end</span>
121: 
122:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span>][<span class="ruby-identifier">:preserve</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:times</span>]
123:         <span class="ruby-constant">File</span>.<span class="ruby-identifier">utime</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:times</span>][<span class="ruby-identifier">:atime</span>], <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:times</span>][<span class="ruby-identifier">:mtime</span>], <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>])
124:       <span class="ruby-keyword kw">end</span>
125: 
126:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:stack</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">directive</span>
127:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:times</span>] = <span class="ruby-keyword kw">nil</span>
128:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000009">
                    
                    <a name="M000009"></a><b>read_directory</b>(channel, directive)
                    
                </div>
                
                <div class="description">
                  <p>
Sets the new directory as the current directory, creates the directory if
it does not exist, and then falls back into <a
href="Download.html#M000001">read_directive_state</a>.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000009_source')" id="l_M000009_source">show</a>
                        
                    </p>
                    <div id="M000009_source" class="dyn-source">
                        <pre>     <span class="ruby-comment cmt"># File lib/net/scp/download.rb, line 109</span>
109:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">read_directory</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">directive</span>)
110:       <span class="ruby-keyword kw">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span>][<span class="ruby-identifier">:recursive</span>]
111:         <span class="ruby-identifier">raise</span> <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SCP</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-value str">&quot;:recursive not specified for directory download&quot;</span>
112:       <span class="ruby-keyword kw">end</span>
113: 
114:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>] = <span class="ruby-constant">File</span>.<span class="ruby-identifier">join</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>], <span class="ruby-identifier">directive</span>[<span class="ruby-identifier">:name</span>])
115: 
116:       <span class="ruby-keyword kw">if</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">exists?</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>]) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-constant">File</span>.<span class="ruby-identifier">directory?</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>])
117:         <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;#{channel[:local]} already exists and is not a directory&quot;</span>
118:       <span class="ruby-keyword kw">elsif</span> <span class="ruby-operator">!</span><span class="ruby-constant">File</span>.<span class="ruby-identifier">exists?</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>])
119:         <span class="ruby-constant">Dir</span>.<span class="ruby-identifier">mkdir</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>], <span class="ruby-identifier">directive</span>[<span class="ruby-identifier">:mode</span>] <span class="ruby-operator">|</span> <span class="ruby-value">0700</span>)
120:       <span class="ruby-keyword kw">end</span>
121: 
122:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span>][<span class="ruby-identifier">:preserve</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:times</span>]
123:         <span class="ruby-constant">File</span>.<span class="ruby-identifier">utime</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:times</span>][<span class="ruby-identifier">:atime</span>], <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:times</span>][<span class="ruby-identifier">:mtime</span>], <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>])
124:       <span class="ruby-keyword kw">end</span>
125: 
126:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:stack</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">directive</span>
127:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:times</span>] = <span class="ruby-keyword kw">nil</span>
128:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000011">
                    
                    <a name="M000011"></a><b>read_file</b>(channel, directive)
                    
                </div>
                
                <div class="description">
                  <p>
Opens the given file locally, and switches to <a
href="Download.html#M000003">read_data_state</a> to do the actual read.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000011_source')" id="l_M000011_source">show</a>
                        
                    </p>
                    <div id="M000011_source" class="dyn-source">
                        <pre>     <span class="ruby-comment cmt"># File lib/net/scp/download.rb, line 132</span>
132:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">read_file</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">directive</span>)
133:       <span class="ruby-keyword kw">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>].<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">:write</span>)
134:         <span class="ruby-identifier">directive</span>[<span class="ruby-identifier">:name</span>] = (<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span>][<span class="ruby-identifier">:recursive</span>] <span class="ruby-operator">||</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">directory?</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>])) <span class="ruby-operator">?</span>
135:           <span class="ruby-constant">File</span>.<span class="ruby-identifier">join</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>], <span class="ruby-identifier">directive</span>[<span class="ruby-identifier">:name</span>]) <span class="ruby-operator">:</span>
136:           <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>]
137:       <span class="ruby-keyword kw">end</span>
138: 
139:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>] = <span class="ruby-identifier">directive</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">:times</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:times</span>])
140:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:io</span>] = <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>].<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">:write</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>] <span class="ruby-operator">:</span>
141:         <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">directive</span>[<span class="ruby-identifier">:name</span>], <span class="ruby-value str">&quot;wb&quot;</span>, <span class="ruby-identifier">directive</span>[<span class="ruby-identifier">:mode</span>] <span class="ruby-operator">|</span> <span class="ruby-value">0600</span>)
142:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:times</span>] = <span class="ruby-keyword kw">nil</span>
143:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:remaining</span>] = <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:size</span>]
144:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:state</span>] = <span class="ruby-identifier">:read_data</span>
145: 
146:       <span class="ruby-identifier">progress_callback</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:name</span>], <span class="ruby-value">0</span>, <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:size</span>])
147:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000040">
                    
                    <a name="M000040"></a><b>read_file</b>(channel, directive)
                    
                </div>
                
                <div class="description">
                  <p>
Opens the given file locally, and switches to <a
href="Download.html#M000003">read_data_state</a> to do the actual read.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000040_source')" id="l_M000040_source">show</a>
                        
                    </p>
                    <div id="M000040_source" class="dyn-source">
                        <pre>     <span class="ruby-comment cmt"># File lib/net/scp/download.rb, line 132</span>
132:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">read_file</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">directive</span>)
133:       <span class="ruby-keyword kw">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>].<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">:write</span>)
134:         <span class="ruby-identifier">directive</span>[<span class="ruby-identifier">:name</span>] = (<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span>][<span class="ruby-identifier">:recursive</span>] <span class="ruby-operator">||</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">directory?</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>])) <span class="ruby-operator">?</span>
135:           <span class="ruby-constant">File</span>.<span class="ruby-identifier">join</span>(<span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>], <span class="ruby-identifier">directive</span>[<span class="ruby-identifier">:name</span>]) <span class="ruby-operator">:</span>
136:           <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>]
137:       <span class="ruby-keyword kw">end</span>
138: 
139:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>] = <span class="ruby-identifier">directive</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">:times</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:times</span>])
140:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:io</span>] = <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>].<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">:write</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>] <span class="ruby-operator">:</span>
141:         <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">directive</span>[<span class="ruby-identifier">:name</span>], <span class="ruby-value str">&quot;wb&quot;</span>, <span class="ruby-identifier">directive</span>[<span class="ruby-identifier">:mode</span>] <span class="ruby-operator">|</span> <span class="ruby-value">0600</span>)
142:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:times</span>] = <span class="ruby-keyword kw">nil</span>
143:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:remaining</span>] = <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:size</span>]
144:       <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:state</span>] = <span class="ruby-identifier">:read_data</span>
145: 
146:       <span class="ruby-identifier">progress_callback</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:name</span>], <span class="ruby-value">0</span>, <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:file</span>][<span class="ruby-identifier">:size</span>])
147:     <span class="ruby-keyword kw">end</span></pre>
                    </div>
                </div>
                
            </div>
            
</div>
    </div>
  </body>
</html>    