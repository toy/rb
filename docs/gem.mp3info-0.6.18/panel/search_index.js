var search_data = {"index":{"longSearchIndex":["lib/mp3info/id3v2.rb","lib/mp3info/id3v2.rb","lib/mp3info.rb","lib/mp3info.rb","lib/mp3info/extension_modules.rb","id3v2","mp3info","mp3info","id3v2","mp3info","id3v2","mp3info","id3v2","mp3info","mp3info","mp3info","mp3info","id3v2","mp3info","string","mp3info","mp3info","mp3info","mp3info","mp3info","mp3info","id3v2","mp3info","mp3info","mp3info","mp3info","id3v2","id3v2","id3v2","mp3info","mp3info","mp3info","mp3info","mp3info","mp3info","id3v2","id3v2","mp3info","id3v2","id3v2","files/history_txt.html","files/readme_rdoc.html","files/lib/mp3info_rb.html","files/lib/mp3info/extension_modules_rb.html","files/lib/mp3info/id3v2_rb.html"],"info":[["ID3v2","lib/mp3info/id3v2.rb","classes/ID3v2.html"," < DelegateClass(Hash)","This class can be used to decode id3v2 tags from files, like .mp3 or .ape for example. It works like",1],["ID3v2Error","lib/mp3info/id3v2.rb","classes/ID3v2Error.html"," < StandardError","",1],["Mp3Info","lib/mp3info/extension_modules.rb","classes/Mp3Info.html"," < Object","coding:utf-8 License:: Ruby Author:: Guillaume Pierronnet (mailto:moumar_AT__rubyforge_DOT_org) Website::",1],["Mp3InfoError","lib/mp3info.rb","classes/Mp3InfoError.html"," < StandardError","Raised on any kind of error related to ruby-mp3info ",1],["String","lib/mp3info/extension_modules.rb","classes/String.html"," < Object","",1],["add_value_to_tag2","ID3v2","classes/ID3v2.html#M000017","(name, size)","Add data to tag2[\"name\"] read lang_encoding, decode data if unicode and create an array if the key already",2],["audio_content","Mp3Info","classes/Mp3Info.html#M000027","()","this method returns the \"audio-only\" data boundaries of the file, i.e. content stripped form tags. Useful",2],["bits","Mp3Info","classes/Mp3Info.html#M000039","(number, b, a)","returns the selected bit range (b, a) as a number NOTE: b > a  if not, returns 0 ",2],["changed?","ID3v2","classes/ID3v2.html#M000003","()","does this tag has been changed ? ",2],["close","Mp3Info","classes/Mp3Info.html#M000029","()","Flush pending modifications to tags and close the file not used when source IO is a StringIO ",2],["decode_tag","ID3v2","classes/ID3v2.html#M000010","(name, raw_value)","Read a tag from file and perform UNICODE translation if needed ",2],["each_frame","Mp3Info","classes/Mp3Info.html#M000032","()","iterates over each mpeg frame over the file, allowing you to write some funny things, like an mpeg lossless",2],["encode_tag","ID3v2","classes/ID3v2.html#M000007","(name, value, version)","",2],["find_next_frame","Mp3Info","classes/Mp3Info.html#M000036","()","reads through @io from current pos until it finds a valid MPEG header returns the MPEG header as FixNum",2],["flush","Mp3Info","classes/Mp3Info.html#M000030","()","close and reopen the file, i.e. commit changes to disk and reload it (only works with \"true\" files, not",2],["frame_length","Mp3Info","classes/Mp3Info.html#M000028","()","return the length in seconds of one frame ",2],["frame_scan","Mp3Info","classes/Mp3Info.html#M000037","(frame_limit = nil)","",2],["from_io","ID3v2","classes/ID3v2.html#M000005","(io)","gets id3v2 tag information from io object (must support #seek() method) ",2],["get_frames_infos","Mp3Info","classes/Mp3Info.html#M000033","(head)","",2],["getbyte","String","classes/String.html#M000000","(i)","",2],["gettag1","Mp3Info","classes/Mp3Info.html#M000035","()","gets id3v1 tag information from @io assumes @io is pointing to char after \"TAG\" id ",2],["hastag1?","Mp3Info","classes/Mp3Info.html#M000008","(filename_or_io)","Test the presence of an id3v1 tag in file or StringIO +filename_or_io+ ",2],["hastag1?","Mp3Info","classes/Mp3Info.html#M000024","()","Does the file has an id3v1 tag? ",2],["hastag2?","Mp3Info","classes/Mp3Info.html#M000009","(filename_or_io)","Test the presence of an id3v2 tag in file or StringIO +filename_or_io+ ",2],["hastag2?","Mp3Info","classes/Mp3Info.html#M000025","()","Does the file has an id3v2 tag? ",2],["hastag?","Mp3Info","classes/Mp3Info.html#M000023","()","Does the file has an id3v1 or v2 tag? ",2],["new","ID3v2","classes/ID3v2.html#M000001","(options = {})","possible options are described above ('options' attribute) you can access this object like an hash, with",2],["new","Mp3Info","classes/Mp3Info.html#M000014","(filename_or_io, options = {})","Instantiate Mp3Info object with name +filename+. options hash is used for ID3v2#new. Specify :parse_tags",2],["open","Mp3Info","classes/Mp3Info.html#M000019","(*params)","\"block version\" of Mp3Info::new() ",2],["parse_mp3","Mp3Info","classes/Mp3Info.html#M000038","()","",2],["parse_tags","Mp3Info","classes/Mp3Info.html#M000034","()","parses the id3 tags of the currently open @io ",2],["parsed?","ID3v2","classes/ID3v2.html#M000002","()","does this tag has been correctly read ? ",2],["read_id3v2_2_frames","ID3v2","classes/ID3v2.html#M000016","()","reads id3 ver 2.2.x frames and adds the contents to @tag2 hash NOTE: the id3v2 header does not take padding",2],["read_id3v2_3_frames","ID3v2","classes/ID3v2.html#M000013","()","reads id3 ver 2.3.x/2.4.x frames and adds the contents to @tag2 hash NOTE: the id3v2 header does not",2],["reload","Mp3Info","classes/Mp3Info.html#M000015","()","reload (or load for the first time) the file from disk ",2],["removetag1","Mp3Info","classes/Mp3Info.html#M000011","(filename)","Remove id3v1 tag from +filename+ ",2],["removetag1","Mp3Info","classes/Mp3Info.html#M000020","()","Remove id3v1 from mp3 ",2],["removetag2","Mp3Info","classes/Mp3Info.html#M000012","(filename)","Remove id3v2 tag from +filename+ ",2],["removetag2","Mp3Info","classes/Mp3Info.html#M000022","()","Remove id3v2 from mp3 ",2],["rename","Mp3Info","classes/Mp3Info.html#M000026","(new_filename)","write to another filename at close() ",2],["seek_to_v2_end","ID3v2","classes/ID3v2.html#M000018","()","runs thru @file one char at a time looking for best guess of first MPEG frame, which should be first",2],["to_bin","ID3v2","classes/ID3v2.html#M000006","()","dump tag for writing. Version is always 2.#{WRITE_VERSION}.0. ",2],["to_s","Mp3Info","classes/Mp3Info.html#M000031","()","inspect inside Mp3Info ",2],["to_syncsafe","ID3v2","classes/ID3v2.html#M000021","(num)","convert an 32 integer to a syncsafe string ",2],["version","ID3v2","classes/ID3v2.html#M000004","()","full version of this tag (like \"2.3.0\") or nil if tag was not correctly read ",2],["History.txt","files/History_txt.html","files/History_txt.html","","=== 0.6.17 / 2012-01-15  * fixed stringio related problems * cleanup project  === 0.6.16 / 2011-11-10",3],["README.rdoc","files/README_rdoc.html","files/README_rdoc.html","","= mp3info  * http://github.com/toy/mp3info  == DESCRIPTION:  mp3info read low-level informations and",3],["mp3info.rb","files/lib/mp3info_rb.html","files/lib/mp3info_rb.html","","coding:utf-8 License:: Ruby Author:: Guillaume Pierronnet (mailto:moumar_AT__rubyforge_DOT_org) Website::",3],["extension_modules.rb","files/lib/mp3info/extension_modules_rb.html","files/lib/mp3info/extension_modules_rb.html","","coding:utf-8 License:: Ruby Author:: Guillaume Pierronnet (mailto:moumar_AT__rubyforge_DOT_org) Website::",3],["id3v2.rb","files/lib/mp3info/id3v2_rb.html","files/lib/mp3info/id3v2_rb.html","","coding:utf-8 License:: Ruby Author:: Guillaume Pierronnet (mailto:moumar_AT__rubyforge_DOT_org) Website::",3]],"searchIndex":["id3v2","id3v2error","mp3info","mp3infoerror","string","add_value_to_tag2()","audio_content()","bits()","changed?()","close()","decode_tag()","each_frame()","encode_tag()","find_next_frame()","flush()","frame_length()","frame_scan()","from_io()","get_frames_infos()","getbyte()","gettag1()","hastag1?()","hastag1?()","hastag2?()","hastag2?()","hastag?()","new()","new()","open()","parse_mp3()","parse_tags()","parsed?()","read_id3v2_2_frames()","read_id3v2_3_frames()","reload()","removetag1()","removetag1()","removetag2()","removetag2()","rename()","seek_to_v2_end()","to_bin()","to_s()","to_syncsafe()","version()","history.txt","readme.rdoc","mp3info.rb","extension_modules.rb","id3v2.rb"]}}