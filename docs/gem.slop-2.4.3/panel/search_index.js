var search_data = {"index":{"longSearchIndex":["lib/slop.rb","slop","slop","slop","slop","slop","slop","slop","slop","slop::options","slop::option","slop::option","slop::option","slop::option","slop","slop","slop::option","slop","slop","slop","slop","slop","slop","slop","slop","slop::option","slop","slop::option","slop","slop","slop","slop","slop::option","slop::option","slop","slop","slop","slop::option","slop::option","slop","slop","slop","slop","slop","slop","slop","slop","slop","slop","slop","slop","slop","slop","slop","slop","slop","slop","slop","slop","slop","slop::option","slop","slop::option","slop","files/changes_md.html","files/license.html","files/readme_md.html","files/lib/slop_rb.html"],"info":[["Slop","lib/slop.rb","classes/Slop.html"," < Object","",1],["Error","Slop","classes/Slop/Error.html"," < StandardError","Slops standard Error class. All exception classes should inherit from this class ",1],["InvalidArgumentError","Slop","classes/Slop/InvalidArgumentError.html"," < Error","Raised when an option specifies the `:match` attribute and this options argument does not match this",1],["InvalidOptionError","Slop","classes/Slop/InvalidOptionError.html"," < Error","Raised when the `:strict` option is enabled and an unknown or unspecified option is used ",1],["MissingArgumentError","Slop","classes/Slop/MissingArgumentError.html"," < Error","Raised when an option expects an argument and none is given ",1],["MissingOptionError","Slop","classes/Slop/MissingOptionError.html"," < Error","Raised when an option is required but not given ",1],["Option","Slop","classes/Slop/Option.html"," < Struct.new(:short_flag, :long_flag, :description, :tail, :match, :help, :required, :forced, :count)","Each option specified in `Slop#opt` creates an instance of this class ",1],["Options","Slop","classes/Slop/Options.html"," < Array","Used to hold a list of Option objects. This class inherits from Array and overwrites `Array#[]` so we",1],["[]","Slop","classes/Slop.html#M000024","(key)","@param [Symbol] key Option symbol @example opts[:name] #=> \"Emily\" opts.get(:name) #=> \"Emily\" @return",2],["[]","Slop::Options","classes/Slop/Options.html#M000013","(flag)","Fetch an Option object. This method overrides Array#[] to provide a nicer interface for fetching options",2],["accepts_optional_argument?","Slop::Option","classes/Slop/Option.html#M000002","()","@return [Boolean] true if this option accepts an optional argument ",2],["arg_value","Slop::Option","classes/Slop/Option.html#M000011","(value)","",2],["argument_value","Slop::Option","classes/Slop/Option.html#M000005","()","@return [Object] the argument value after it's been cast according to the `:as` option ",2],["argument_value=","Slop::Option","classes/Slop/Option.html#M000004","(value)","Set this options argument value. If this options argument type is expected to be an Array, this method",2],["autocreate","Slop","classes/Slop.html#M000054","(flag, index, items)","If autocreation is enabled this method simply generates an option and add's it to the existing list of",2],["banner","Slop","classes/Slop.html#M000018","(text=nil)","Set or return banner text @param [String] text Displayed banner text @example opts = Slop.parse do banner",2],["call","Slop::Option","classes/Slop/Option.html#M000007","(obj=nil)","Execute the block or callback object associated with this Option @param [Object] The object to be sent",2],["check_optional_argument!","Slop","classes/Slop.html#M000047","(option, flag)","",2],["clean_options","Slop","classes/Slop.html#M000055","(args)","Clean up arguments sent to `on` and return a list of 5 elements: * short flag (or nil) * long flag (or",2],["command","Slop","classes/Slop.html#M000029","(label, options={}, &block)","Namespace options depending on what command is executed @param [Symbol, String] label @param [Hash] options",2],["description","Slop","classes/Slop.html#M000020","(text=nil)","Set or return the description @param [String] text Displayed description text @example opts = Slop.parse",2],["each","Slop","classes/Slop.html#M000023","(&block)","Enumerable interface ",2],["enable_multiple_switches","Slop","classes/Slop.html#M000050","(item)","if multiple_switches is enabled, this method filters through an items characters and attempts to find",2],["execute","Slop","classes/Slop.html#M000034","(args=[], &block)","Add an execution block (for commands) @example opts = Slop.new do command :foo do on :v, :verbose execute",2],["execute_command","Slop","classes/Slop.html#M000053","(items, delete)","attempt to execute a command if one exists, returns a positive (tru-ish) result if the command was found",2],["expects_argument?","Slop::Option","classes/Slop/Option.html#M000001","()","@return [Boolean] true if this option expects an argument ",2],["extract_option","Slop","classes/Slop.html#M000052","(item, flag)","attempt to extract an option from an argument, this method allows us to parse things like 'foo=bar' and",2],["force_argument_value","Slop::Option","classes/Slop/Option.html#M000006","(value)","Force an argument value, used when the desired argument value is negative (false or nil) @param [Object]",2],["get","Slop","classes/Slop.html#M000025","(key)","Alias for #[]",2],["help","Slop","classes/Slop.html#M000043","()","Alias for #to_s",2],["initialize_and_parse","Slop","classes/Slop.html#M000045","(items, delete, options, &block)","",2],["inspect","Slop","classes/Slop.html#M000044","()","@return [String] This Slop object will options and configuration settings revealed ",2],["inspect","Slop::Option","classes/Slop/Option.html#M000010","()","@return [String] ",2],["key","Slop::Option","classes/Slop/Option.html#M000003","()","@return [String] either the long or short flag for this option ",2],["method_missing","Slop","classes/Slop.html#M000039","(meth, *args, &block)","Allows you to check whether an option was specified in the parsed list Merely sugar for `present?` @example",2],["missing","Slop","classes/Slop.html#M000038","()","Fetch a list of options which were missing from the parsed list @example opts = Slop.new do on :n, :name,",2],["new","Slop","classes/Slop.html#M000017","(*opts, &block)","@option opts [Boolean] :help * Automatically add the `help` option @option opts [Boolean] :strict * Raises",2],["new","Slop::Option","classes/Slop/Option.html#M000000","(slop, short, long, description, argument, options, &blk)","@param [Slop] slop The Slop object this Option belongs to @param [String, #to_s] short The short flag",2],["omit_exec?","Slop::Option","classes/Slop/Option.html#M000008","(items)","@param [Array] items The original array of objects passed to `Slop.new` @return [Boolean] true if this",2],["on","Slop","classes/Slop.html#M000028","(*args, &block)","Alias for #option",2],["on_empty","Slop","classes/Slop.html#M000030","(obj=nil, &block)","Trigger an event when Slop has no values to parse @param [Object, #call] obj The object (which can be",2],["on_empty=","Slop","classes/Slop.html#M000031","(obj=nil, &block)","Alias for #on_empty",2],["on_noopts","Slop","classes/Slop.html#M000032","(obj=nil, &block)","Trigger an event when the arguments contain no options @param [Object, #call] obj The object to be triggered",2],["on_optionless","Slop","classes/Slop.html#M000033","(obj=nil, &block)","Alias for #on_noopts",2],["opt","Slop","classes/Slop.html#M000027","(*args, &block)","Alias for #option",2],["option","Slop","classes/Slop.html#M000026","(*args, &block)","Specify an option with a short or long version, description and type @param [*] args Option configuration.",2],["optspec","Slop","classes/Slop.html#M000016","(optspec, *options)","Build options from an optspec string @param [String] optspec The option spec string @param [Array]  options",2],["parse","Slop","classes/Slop.html#M000021","(items=ARGV, &block)","Parse a list of options, leaving the original Array unchanged @param [Array] items A list of items to",2],["parse","Slop","classes/Slop.html#M000014","(items=ARGV, options={}, &block)","Parses the items from a CLI format into a friendly object @param [Array] items Items to parse into options.",2],["parse!","Slop","classes/Slop.html#M000022","(items=ARGV, &block)","Parse a list of options, removing parsed options from the original Array @param [Array] items A list",2],["parse!","Slop","classes/Slop.html#M000015","(items=ARGV, options={}, &block)","Identical to {Slop.parse}, but removes parsed options from the original Array @return [Slop] Returns",2],["parse_items","Slop","classes/Slop.html#M000046","(items, delete=false, &block)","traverse through the list of items sent to parse() or parse!() and attempt to do the following: * Find",2],["present?","Slop","classes/Slop.html#M000041","(*option_names)","Check if an option is specified in the parsed list Does the same as Slop#option? but a convenience method",2],["raise_if_invalid_options!","Slop","classes/Slop.html#M000048","()","",2],["raise_if_missing_required_options!","Slop","classes/Slop.html#M000049","(items)","",2],["respond_to?","Slop","classes/Slop.html#M000040","(method)","Override this method so we can check if an option? method exists ",2],["summary","Slop","classes/Slop.html#M000019","(text=nil)","Set or return the summary @param [String] text Displayed summary text @example opts = Slop.parse do summary",2],["to_h","Slop","classes/Slop.html#M000036","(symbols=true)","Alias for #to_hash",2],["to_hash","Slop","classes/Slop.html#M000035","(symbols=true)","Returns the parsed list into a option/value hash @example opts.to_hash #=> { :name => 'Emily' } # strings!",2],["to_s","Slop","classes/Slop.html#M000042","()","Returns the banner followed by available options listed on the next line @example opts = Slop.parse do",2],["to_s","Slop::Option","classes/Slop/Option.html#M000009","()","This option in a nice pretty string, including a short flag, long flag, and description (if they exist).",2],["to_struct","Slop","classes/Slop.html#M000037","(name=nil)","Return parsed items as a new Class @example opts = Slop.new do on :n, :name, 'Persons name', true on",2],["value_to_range","Slop::Option","classes/Slop/Option.html#M000012","(value)","",2],["wrap_and_indent","Slop","classes/Slop.html#M000051","(string, width, indentation)","",2],["CHANGES.md","files/CHANGES_md.html","files/CHANGES_md.html","","HEAD ----  * Allow the `:as` option to accept an object responding to :call for   custom type conversions",3],["LICENSE","files/LICENSE.html","files/LICENSE.html","","Copyright (c) 2011 Lee Jarvis  Permission is hereby granted, free of charge, to any person obtaining",3],["README.md","files/README_md.html","files/README_md.html","","Slop ====  Slop is a simple, lightweight option parser with an easy to remember syntax and friendly API.",3],["slop.rb","files/lib/slop_rb.html","files/lib/slop_rb.html","","",3]],"searchIndex":["slop","error","invalidargumenterror","invalidoptionerror","missingargumenterror","missingoptionerror","option","options","[]()","[]()","accepts_optional_argument?()","arg_value()","argument_value()","argument_value=()","autocreate()","banner()","call()","check_optional_argument!()","clean_options()","command()","description()","each()","enable_multiple_switches()","execute()","execute_command()","expects_argument?()","extract_option()","force_argument_value()","get()","help()","initialize_and_parse()","inspect()","inspect()","key()","method_missing()","missing()","new()","new()","omit_exec?()","on()","on_empty()","on_empty=()","on_noopts()","on_optionless()","opt()","option()","optspec()","parse()","parse()","parse!()","parse!()","parse_items()","present?()","raise_if_invalid_options!()","raise_if_missing_required_options!()","respond_to?()","summary()","to_h()","to_hash()","to_s()","to_s()","to_struct()","value_to_range()","wrap_and_indent()","changes.md","license","readme.md","slop.rb"]}}