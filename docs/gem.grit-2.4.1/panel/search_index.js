var search_data = {"index":{"longSearchIndex":["lib/grit/git-ruby/repository.rb","lib/grit.rb","grit","grit","grit::blame","grit","grit","grit","grit","grit","grit","grit","grit","grit::git","grit::git","grit","grit::gitruby","grit::gitruby","grit::gitruby","grit::gitruby","grit::gitruby::fileindex","grit::gitruby::fileindex","grit::gitruby","grit::gitruby","grit::gitruby::internal","grit::gitruby::internal","grit::gitruby::internal","grit::gitruby::internal","grit::gitruby::internal","grit::gitruby::internal","grit::gitruby","grit::gitruby","grit::gitruby::repository","grit::gitruby::repository","grit::gitruby","grit::gitruby","grit::gitruby","grit","grit","grit","grit","grit","grit","grit","grit","grit::process","grit::process","grit","grit","grit","grit","grit::status","grit","grit","grit","lib/grit/lazy.rb","lib/grit/ruby1.9.rb","grit::tree","grit::blob","grit::tree","grit::config","grit::gitruby::internal::filewindow","grit::gitruby::internal::loosestorage","grit::gitruby::internal::packstorage","grit::status","grit::config","grit::commit","grit::gitruby::tree","grit::gitruby::tree","grit::index","grit::repo","grit::gitruby::repository","grit::status","grit::repo","grit::repo","grit::git","grit::repo","grit::repo","grit::repo","grit::commit","grit::blob","grit::submodule","grit::tree","grit::repo","grit::blob","grit::repo","grit::gitruby","grit::gitruby::repository","grit::repo","grit::repo","grit::status::statusfile","grit::tree","grit::repo","grit::gitruby::internal::packstorage","grit::gitruby::repository","grit::gitruby::internal::loosestorage","grit::gitruby","grit::gitruby::repository","grit::gitruby::repository","grit::gitruby::repository","grit::gitruby","grit::status","grit::git","grit::gitruby","grit::gitruby::internal::packstorage","grit::gitruby::repository","grit::index","grit::repo","grit::repo","grit::repo","grit::repo","grit::repo","grit::git","grit::repo","grit::repo","grit::repo","grit::repo","grit::repo","grit::gitruby::fileindex","grit::gitruby::fileindex","grit::repo","grit::repo","grit::submodule","grit::config","grit::tree","grit::tree","grit::status","grit::tree","grit::commit","grit::gitruby::fileindex","grit::gitruby::fileindex","grit::blob","grit::commit","grit::submodule","grit::tree","grit::gitruby::repository","grit::blob","grit::commit","grit::submodule","grit::tree","grit::git","grit::head","grit::blob","grit::config","grit::commit","grit::index","grit::status","grit::repo","grit::commit","grit::gitruby","grit::gitruby::repository","grit::repo","grit::status","grit::status","grit::repo","grit::commit","grit::repo","grit::git","grit::status","grit::gitruby::repository","grit::gitruby::internal::packstorage","grit::gitruby::internal::packstorage","grit::repo","grit::process","grit::git","lazy","grit::config","grit::gitruby","grit::gitruby","grit::gitruby","grit::gitruby::fileindex","grit::gitruby::repository","grit::commit","grit::commitstats","grit::ref","grit::tag","grit::gitruby::internal::packstorage","grit::gitruby::internal::packstorage","grit::repo","grit::repo","grit::gitruby::directoryentry","grit::gitruby::directoryentry","grit::gitruby::directoryentry","grit::gitruby::directoryentry","grit::gitruby::blob","grit::gitruby::blob","grit::gitruby::commit","grit::gitruby::commit","grit::gitruby::gitobject","grit::gitruby::object","grit::gitruby::tag","grit::gitruby::tag","grit::gitruby::tree","grit::gitruby::tree","grit::actor","grit::git","grit::git","grit::git","grit::git","grit::git","grit::git","grit::git","grit::repo","grit::repo","grit::gitruby::repository","grit::git","grit::gitruby::internal::loosestorage","grit::gitruby::repository","grit::gitruby::repository","grit::gitruby::repository","grit::gitruby::internal::packstorage","grit::gitruby::repository","string","grit::git","grit::gitruby::repository","grit::repo","grit::repo","grit::commit","grit::gitruby::repository","grit::gitruby::repository","grit::repo","grit::gitruby","grit::gitruby::repository","grit::repo","grit::repo","grit::repo","grit::gitruby::internal::packstorage","grit::gitruby::repository","grit::gitruby::repository","grit::actor","grit::blame","grit::blob","grit::commit","grit::commitstats","grit::diffstat","grit::merge","grit::ref","grit::repo","grit::submodule","grit::tree","grit::repo","grit::config","grit::gitruby::fileindex","lazy","grit::commit","grit::tag","grit::tree","grit::gitruby::internal::loosestorage","grit::commit","grit::commitstats","grit::diff","grit::git","grit::gitruby::repository","grit::gitruby::repository","grit::gitruby::repository","grit::blame","grit::config","grit::gitruby::repository","grit::gitruby::repository","grit","grit::gitruby::repository","grit::repo","grit::gitruby::repository","grit::gitruby","grit::gitruby::repository","grit::status","grit::gitruby","grit::gitruby::repository","grit::gitruby::repository","grit::git","grit::blob","grit::gitruby::internal::packstorage","grit::git","grit::diffstat","grit::actor","grit::blame","grit::blame::blameline","grit::commit","grit::commitdb","grit::commitstats","grit::config","grit::diff","grit::diffstat","grit::git","grit::git::commandfailed","grit::git::gittimeout","grit::gitruby::blob","grit::gitruby::blob","grit::gitruby::commit","grit::gitruby::commit","grit::gitruby::directoryentry","grit::gitruby::directoryentry","grit::gitruby::fileindex","grit::gitruby::gitobject","grit::gitruby::internal::filewindow","grit::gitruby::internal::loosestorage","grit::gitruby::internal::packstorage","grit::gitruby::internal::rawobject","grit::gitruby::object","grit::gitruby::repository","grit::gitruby::tag","grit::gitruby::tag","grit::gitruby::tree","grit::gitruby::tree","grit::gitruby::userinfo","grit::gitruby::userinfo","grit::index","grit::merge","grit::process","grit::ref","grit::repo","grit::status","grit::status::statusfile","grit::commit","grit::git","grit::gitruby::repository","grit::repo","grit::repo","grit::git","grit::actor","grit::gitruby::repository","grit::commit","grit::repo","grit::gitruby::internal::packstorage","grit::tag","grit::gitruby::internal::packstorage","grit::gitruby::internal::packstorage","grit::process","grit::process","grit::ref","grit::status","grit::blame","grit::git","grit::gitruby::internal::loosestorage","grit::gitruby::repository","grit::gitruby::repository","grit::gitruby::directoryentry","grit::gitruby::directoryentry","grit::gitruby::blob","grit::gitruby::blob","grit::gitruby::commit","grit::gitruby::commit","grit::gitruby::gitobject","grit::gitruby::object","grit::gitruby::tag","grit::gitruby::tag","grit::gitruby::tree","grit::gitruby::tree","grit::gitruby::commit","grit::gitruby::commit","grit::process","grit::gitruby","grit::gitruby","grit::gitruby::internal::packstorage","grit::gitruby::fileindex","grit::index","grit::repo","grit::gitruby","grit::repo","grit::repo","grit::repo","grit::repo","grit::repo","grit::repo","grit::repo","grit::repo","grit::commitdb","grit::gitruby","grit::gitruby::repository","grit::gitruby","grit::gitruby","grit::git","grit::git","grit::commitdb","grit::git","grit::commit","grit::gitruby::gitobject","grit::gitruby::internal::rawobject","grit::gitruby::object","grit::git","grit::commit","grit::gitruby::repository","grit::blob","grit::gitruby::fileindex","grit::process","grit::process","grit::commit","grit::repo","grit::process","grit::gitruby","grit::repo","grit::git","grit::commitstats","grit::commit","grit::commitstats","grit::commit","grit::commit","grit::gitruby::userinfo","grit::gitruby::userinfo","grit::git","grit::repo","grit::tree","grit::gitruby::repository","grit::gitruby","grit::gitruby::blob","grit::gitruby::blob","grit::gitruby::commit","grit::gitruby::commit","grit::gitruby::directoryentry","grit::gitruby::directoryentry","grit::gitruby::gitobject","grit::gitruby::object","grit::gitruby::tag","grit::gitruby::tag","grit::gitruby::tree","grit::gitruby::tree","grit::gitruby::directoryentry","grit::gitruby::directoryentry","grit::gitruby::internal::filewindow","grit::gitruby::internal::packstorage","grit::gitruby::internal::packstorage","grit::gitruby::internal::packstorage","grit::gitruby::internal::loosestorage","grit::status","grit::commitdb","grit::repo","grit::submodule","grit::gitruby::internal::loosestorage","grit","grit::process","grit::process","grit::gitruby::repository","grit::git","grit::gitruby::internal::packstorage","grit::gitruby::internal::packstorage","grit::git","grit::index","grit::index","files/history_txt.html","files/license.html","files/readme_md.html","files/lib/grit_rb.html","files/lib/grit/actor_rb.html","files/lib/grit/blame_rb.html","files/lib/grit/blob_rb.html","files/lib/grit/commit_rb.html","files/lib/grit/commit_stats_rb.html","files/lib/grit/config_rb.html","files/lib/grit/diff_rb.html","files/lib/grit/errors_rb.html","files/lib/grit/git-ruby_rb.html","files/lib/grit/git-ruby/commit_db_rb.html","files/lib/grit/git-ruby/file_index_rb.html","files/lib/grit/git-ruby/git_object_rb.html","files/lib/grit/git-ruby/internal/file_window_rb.html","files/lib/grit/git-ruby/internal/loose_rb.html","files/lib/grit/git-ruby/internal/pack_rb.html","files/lib/grit/git-ruby/internal/raw_object_rb.html","files/lib/grit/git-ruby/object_rb.html","files/lib/grit/git-ruby/repository_rb.html","files/lib/grit/git_rb.html","files/lib/grit/index_rb.html","files/lib/grit/jruby_rb.html","files/lib/grit/lazy_rb.html","files/lib/grit/merge_rb.html","files/lib/grit/process_rb.html","files/lib/grit/ref_rb.html","files/lib/grit/repo_rb.html","files/lib/grit/ruby1_9_rb.html","files/lib/grit/status_rb.html","files/lib/grit/submodule_rb.html","files/lib/grit/tag_rb.html","files/lib/grit/tree_rb.html"],"info":[["Difference","lib/grit/git-ruby/repository.rb","classes/Difference.html"," < ","have to do this so it doesn't interfere with Grit::Diff ",1],["Grit","lib/grit/actor.rb","classes/Grit.html"," < ","this implements a file-based 'file index', an simple index of all of the reachable commits in a repo,",1],["Actor","Grit","classes/Grit/Actor.html"," < Object","",1],["Blame","Grit","classes/Grit/Blame.html"," < Object","",1],["BlameLine","Grit::Blame","classes/Grit/Blame/BlameLine.html"," < Object","",1],["Blob","Grit","classes/Grit/Blob.html"," < Object","",1],["Commit","Grit","classes/Grit/Commit.html"," < Object","",1],["CommitDb","Grit","classes/Grit/CommitDb.html"," < Object","",1],["CommitStats","Grit","classes/Grit/CommitStats.html"," < Object","",1],["Config","Grit","classes/Grit/Config.html"," < Object","",1],["Diff","Grit","classes/Grit/Diff.html"," < Object","",1],["DiffStat","Grit","classes/Grit/DiffStat.html"," < Object","",1],["Git","Grit","classes/Grit/Git.html"," < Object","",1],["CommandFailed","Grit::Git","classes/Grit/Git/CommandFailed.html"," < StandardError","Raised when a native git command exits with non-zero. ",1],["GitTimeout","Grit::Git","classes/Grit/Git/GitTimeout.html"," < RuntimeError","",1],["GitRuby","Grit","classes/Grit/GitRuby.html"," < ","the functions in this module intercept the calls to git binary made buy the grit objects and attempts",1],["Blob","Grit::GitRuby","classes/Grit/GitRuby/Blob.html"," < GitObject","",1],["Commit","Grit::GitRuby","classes/Grit/GitRuby/Commit.html"," < GitObject","",1],["DirectoryEntry","Grit::GitRuby","classes/Grit/GitRuby/DirectoryEntry.html"," < Object","",1],["FileIndex","Grit::GitRuby","classes/Grit/GitRuby/FileIndex.html"," < Object","",1],["IndexFileNotFound","Grit::GitRuby::FileIndex","classes/Grit/GitRuby/FileIndex/IndexFileNotFound.html"," < StandardError","",1],["UnsupportedRef","Grit::GitRuby::FileIndex","classes/Grit/GitRuby/FileIndex/UnsupportedRef.html"," < StandardError","",1],["GitObject","Grit::GitRuby","classes/Grit/GitRuby/GitObject.html"," < Object","base class for all git objects (blob, tree, commit, tag) ",1],["Internal","Grit::GitRuby","classes/Grit/GitRuby/Internal.html"," < ","",1],["FileWindow","Grit::GitRuby::Internal","classes/Grit/GitRuby/Internal/FileWindow.html"," < Object","",1],["LooseObjectError","Grit::GitRuby::Internal","classes/Grit/GitRuby/Internal/LooseObjectError.html"," < StandardError","",1],["LooseStorage","Grit::GitRuby::Internal","classes/Grit/GitRuby/Internal/LooseStorage.html"," < Object","",1],["PackFormatError","Grit::GitRuby::Internal","classes/Grit/GitRuby/Internal/PackFormatError.html"," < StandardError","",1],["PackStorage","Grit::GitRuby::Internal","classes/Grit/GitRuby/Internal/PackStorage.html"," < Object","",1],["RawObject","Grit::GitRuby::Internal","classes/Grit/GitRuby/Internal/RawObject.html"," < Object","",1],["Object","Grit::GitRuby","classes/Grit/GitRuby/Object.html"," < Object","base class for all git objects (blob, tree, commit, tag) ",1],["Repository","Grit::GitRuby","classes/Grit/GitRuby/Repository.html"," < Object","",1],["NoSuchPath","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository/NoSuchPath.html"," < StandardError","",1],["NoSuchShaFound","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository/NoSuchShaFound.html"," < StandardError","",1],["Tag","Grit::GitRuby","classes/Grit/GitRuby/Tag.html"," < GitObject","",1],["Tree","Grit::GitRuby","classes/Grit/GitRuby/Tree.html"," < GitObject","",1],["UserInfo","Grit::GitRuby","classes/Grit/GitRuby/UserInfo.html"," < Object","class for author/committer/tagger lines ",1],["Head","Grit","classes/Grit/Head.html"," < Ref","A Head is a named reference to a Commit. Every Head instance contains a name and a Commit object. r =",1],["Index","Grit","classes/Grit/Index.html"," < Object","",1],["InvalidGitRepositoryError","Grit","classes/Grit/InvalidGitRepositoryError.html"," < StandardError","",1],["InvalidObjectType","Grit","classes/Grit/InvalidObjectType.html"," < StandardError","",1],["Merge","Grit","classes/Grit/Merge.html"," < Object","",1],["NoSuchPathError","Grit","classes/Grit/NoSuchPathError.html"," < StandardError","",1],["Note","Grit","classes/Grit/Note.html"," < Ref","",1],["Process","Grit","classes/Grit/Process.html"," < Object","Grit::Process includes logic for executing child processes and reading/writing from their standard input,",1],["MaximumOutputExceeded","Grit::Process","classes/Grit/Process/MaximumOutputExceeded.html"," < StandardError","Exception raised when the total number of bytes output on the command's stderr and stdout streams exceeds",1],["TimeoutExceeded","Grit::Process","classes/Grit/Process/TimeoutExceeded.html"," < StandardError","Exception raised when timeout is exceeded. ",1],["Ref","Grit","classes/Grit/Ref.html"," < Object","",1],["Remote","Grit","classes/Grit/Remote.html"," < Ref","",1],["Repo","Grit","classes/Grit/Repo.html"," < Object","",1],["Status","Grit","classes/Grit/Status.html"," < Object","",1],["StatusFile","Grit::Status","classes/Grit/Status/StatusFile.html"," < Object","",1],["Submodule","Grit","classes/Grit/Submodule.html"," < Object","",1],["Tag","Grit","classes/Grit/Tag.html"," < Ref","",1],["Tree","Grit","classes/Grit/Tree.html"," < Object","",1],["Lazy","lib/grit/lazy.rb","classes/Lazy.html"," < ","Allows attributes to be declared as lazy, meaning that they won't be computed until they are asked for.",1],["String","lib/grit/ruby1.9.rb","classes/String.html"," < Object","",1],["/","Grit::Tree","classes/Grit/Tree.html#M000373","(file)","Find the named object in this tree's contents Examples Repo.new('/path/to/grit').tree/'lib' # => #<Grit::Tree",2],["<=>","Grit::Blob","classes/Grit/Blob.html#M000017","(other)","Compares blobs by name ",2],["<=>","Grit::Tree","classes/Grit/Tree.html#M000380","(other)","Compares trees by name ",2],["[]","Grit::Config","classes/Grit/Config.html#M000051","(key)","",2],["[]","Grit::GitRuby::Internal::FileWindow","classes/Grit/GitRuby/Internal/FileWindow.html#M000103","(*idx)","",2],["[]","Grit::GitRuby::Internal::LooseStorage","classes/Grit/GitRuby/Internal/LooseStorage.html#M000108","(sha1)","",2],["[]","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000122","(sha1)","",2],["[]","Grit::Status","classes/Grit/Status.html#M000318","(file)","enumerable method ",2],["[]=","Grit::Config","classes/Grit/Config.html#M000050","(key, value)","",2],["actor","Grit::Commit","classes/Grit/Commit.html#M000046","(line)","Parse out the actor (author or committer) info Returns [String (actor name and email), Time (acted at",2],["actual_raw","Grit::GitRuby::Tree","classes/Grit/GitRuby/Tree.html#M000159","()","",2],["actual_raw","Grit::GitRuby::Tree","classes/Grit/GitRuby/Tree.html#M000094","()","",2],["add","Grit::Index","classes/Grit/Index.html#M000260","(path, data)","Public: Add a file to the index. path - The String file path including filename (no slash prefix). data",2],["add","Grit::Repo","classes/Grit/Repo.html#M000303","(*files)","Adds files to the index ",2],["add_file","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000241","(name, contents)","",2],["added","Grit::Status","classes/Grit/Status.html#M000310","()","",2],["alternates","Grit::Repo","classes/Grit/Repo.html#M000357","()","The list of alternates for this repo Returns Array[String] (pathnames of alternates) ",2],["alternates=","Grit::Repo","classes/Grit/Repo.html#M000358","(alts)","Sets the alternates +alts+ is the Array of String paths representing the alternates Returns nothing ",2],["apply_patch","Grit::Git","classes/Grit/Git.html#M000239","(head_sha, patch)","Applies the given patch against the given SHA of the current repo. head_sha - String SHA or ref to apply",2],["archive_tar","Grit::Repo","classes/Grit/Repo.html#M000349","(treeish = 'master', prefix = nil)","Archive the given treeish +treeish+ is the treeish name/id (default 'master') +prefix+ is the optional",2],["archive_tar_gz","Grit::Repo","classes/Grit/Repo.html#M000350","(treeish = 'master', prefix = nil)","Archive and gzip the given treeish +treeish+ is the treeish name/id (default 'master') +prefix+ is the",2],["archive_to_file","Grit::Repo","classes/Grit/Repo.html#M000353","(treeish = 'master', prefix = nil, filename = 'archive.tar.gz', format = nil, pipe = \"gzip\")","Write an archive directly to a file +treeish+ is the treeish name/id (default 'master') +prefix+ is the",2],["author_string","Grit::Commit","classes/Grit/Commit.html#M000047","()","",2],["basename","Grit::Blob","classes/Grit/Blob.html#M000015","()","",2],["basename","Grit::Submodule","classes/Grit/Submodule.html#M000351","()","",2],["basename","Grit::Tree","classes/Grit/Tree.html#M000374","()","",2],["batch","Grit::Repo","classes/Grit/Repo.html#M000291","(*shas)","Public: Return the full Git objects from the given SHAs.  Only Commit objects are parsed for now. *shas",2],["blame","Grit::Blob","classes/Grit/Blob.html#M000013","(repo, commit, file)","The blame information for the given file at the given commit Returns Array: [Grit::Commit, Array: [<line>]]",2],["blame","Grit::Repo","classes/Grit/Repo.html#M000295","(file, commit = nil)","",2],["blame_tree","Grit::GitRuby","classes/Grit/GitRuby.html#M000203","(commit, path = nil)","",2],["blame_tree","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000228","(commit_sha, path)","",2],["blame_tree","Grit::Repo","classes/Grit/Repo.html#M000305","(commit, path = nil)","",2],["blob","Grit::Repo","classes/Grit/Repo.html#M000343","(id)","The Blob object for the given id +id+ is the SHA1 id of the blob Returns Grit::Blob (unbaked) ",2],["blob","Grit::Status::StatusFile","classes/Grit/Status/StatusFile.html#M000326","(type = :index)","",2],["blobs","Grit::Tree","classes/Grit/Tree.html#M000379","()","Find only Blob objects from contents ",2],["branches","Grit::Repo","classes/Grit/Repo.html#M000297","()","Alias for #heads",2],["cache_objects","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000117","()","",2],["cached","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000174","(key, object, do_cache = true)","",2],["calculate_sha","Grit::GitRuby::Internal::LooseStorage","classes/Grit/GitRuby/Internal/LooseStorage.html#M000111","(content, type)","simply figure out the sha ",2],["cat_file","Grit::GitRuby","classes/Grit/GitRuby.html#M000181","(options, sha)","",2],["cat_file","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000184","(sha)","returns the raw file contents of this sha ",2],["cat_file_size","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000183","(sha)","returns the file size (as an int) of this sha ",2],["cat_file_type","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000182","(sha)","returns the file type (as a symbol) of this sha ",2],["cat_ref","Grit::GitRuby","classes/Grit/GitRuby.html#M000186","(options, ref)","",2],["changed","Grit::Status","classes/Grit/Status.html#M000309","()","",2],["check_applies","Grit::Git","classes/Grit/Git.html#M000236","(head_sha, applies_sha)","Checks if the patch of a commit can be applied to the given head. head_sha    - String SHA or ref to",2],["clean_paths","Grit::GitRuby","classes/Grit/GitRuby.html#M000208","(commit_array)","",2],["close","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000120","()","",2],["close","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000242","()","",2],["commit","Grit::Index","classes/Grit/Index.html#M000263","(message, parents = nil, actor = nil, last_tree = nil, head = 'master')","Public: Commit the contents of the index.  This method supports two formats for arguments: message -",2],["commit","Grit::Repo","classes/Grit/Repo.html#M000332","(id)","The Commit object for the specified id +id+ is the SHA1 identifier of the commit Returns Grit::Commit",2],["commit_all","Grit::Repo","classes/Grit/Repo.html#M000302","(message)","Commits all tracked and modified files Returns true/false if commit worked ",2],["commit_count","Grit::Repo","classes/Grit/Repo.html#M000330","(start = 'master')","The number of commits reachable by the given branch/commit +start+ is the branch/commit name (default",2],["commit_deltas_from","Grit::Repo","classes/Grit/Repo.html#M000333","(other_repo, ref = \"master\", other_ref = \"master\")","Returns a list of commits that is in +other_repo+ but not in self Returns Grit::Commit[] ",2],["commit_diff","Grit::Repo","classes/Grit/Repo.html#M000347","(commit)","The commit diff for the given commit +commit+ is the commit name/id Returns Grit::Diff[] ",2],["commit_from_sha","Grit::Git","classes/Grit/Git.html#M000235","(id)","",2],["commit_index","Grit::Repo","classes/Grit/Repo.html#M000301","(message)","Commits current index Returns true/false if commit worked ",2],["commit_objects","Grit::Repo","classes/Grit/Repo.html#M000337","(refs)","",2],["commit_stats","Grit::Repo","classes/Grit/Repo.html#M000324","(start = 'master', max_count = 10, skip = 0)","",2],["commits","Grit::Repo","classes/Grit/Repo.html#M000325","(start = 'master', max_count = 10, skip = 0)","An array of Commit objects representing the history of a given ref/commit +start+ is the branch/commit",2],["commits_between","Grit::Repo","classes/Grit/Repo.html#M000328","(from, to)","The Commits objects that are reachable via +to+ but not via +from+ Commits are returned in chronological",2],["commits_for","Grit::GitRuby::FileIndex","classes/Grit/GitRuby/FileIndex.html#M000075","(file)","returns all commits for a file ",2],["commits_from","Grit::GitRuby::FileIndex","classes/Grit/GitRuby/FileIndex.html#M000069","(commit_sha)","builds a list of all commits reachable from a single commit ",2],["commits_since","Grit::Repo","classes/Grit/Repo.html#M000329","(start = 'master', since = '1970-01-01', extra_options = {})","The Commits objects that are newer than the specified date. Commits are returned in chronological order.",2],["config","Grit::Repo","classes/Grit/Repo.html#M000359","()","",2],["config","Grit::Submodule","classes/Grit/Submodule.html#M000348","(repo, ref = \"master\")","The configuration information for the given +repo+ +repo+ is the Repo +ref+ is the committish (defaults",2],["config_lines","Grit::Config","classes/Grit/Config.html#M000056","()","",2],["construct","Grit::Tree","classes/Grit/Tree.html#M000366","(repo, treeish, paths = [])","Construct the contents of the tree +repo+ is the Repo +treeish+ is the reference +paths+ is an optional",2],["construct_initialize","Grit::Tree","classes/Grit/Tree.html#M000368","(repo, id, text)","",2],["construct_status","Grit::Status","classes/Grit/Status.html#M000327","()","",2],["content_from_string","Grit::Tree","classes/Grit/Tree.html#M000372","(repo, text)","Parse a content item and create the appropriate object +repo+ is the Repo +text+ is the single line containing",2],["count","Grit::Commit","classes/Grit/Commit.html#M000025","(repo, ref)","Count the number of commits reachable from this ref +repo+ is the Repo +ref+ is the ref from which to",2],["count","Grit::GitRuby::FileIndex","classes/Grit/GitRuby/FileIndex.html#M000068","(commit_sha)","returns count of all commits reachable from SHA note: originally did this recursively, but ruby gets",2],["count_all","Grit::GitRuby::FileIndex","classes/Grit/GitRuby/FileIndex.html#M000065","()","returns count of all commits ",2],["create","Grit::Blob","classes/Grit/Blob.html#M000007","(repo, atts)","Create an unbaked Blob containing just the specified attributes +repo+ is the Repo +atts+ is a Hash of",2],["create","Grit::Commit","classes/Grit/Commit.html#M000021","(repo, atts)","Create an unbaked Commit containing just the specified attributes +repo+ is the Repo +atts+ is a Hash",2],["create","Grit::Submodule","classes/Grit/Submodule.html#M000340","(repo, atts)","Create a Submodule containing just the specified attributes +repo+ is the Repo +atts+ is a Hash of instance",2],["create","Grit::Tree","classes/Grit/Tree.html#M000370","(repo, atts)","Create an unbaked Tree containing just the specified attributes +repo+ is the Repo +atts+ is a Hash of",2],["create_initial_config","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000240","(bare = false)","",2],["create_initialize","Grit::Blob","classes/Grit/Blob.html#M000008","(repo, atts)","Initializer for Blob.create +repo+ is the Repo +atts+ is a Hash of instance variable data Returns Grit::Blob",2],["create_initialize","Grit::Commit","classes/Grit/Commit.html#M000022","(repo, atts)","Initializer for Commit.create +repo+ is the Repo +atts+ is a Hash of instance variable data Returns Grit::Commit",2],["create_initialize","Grit::Submodule","classes/Grit/Submodule.html#M000341","(repo, atts)","Initializer for Submodule.create +repo+ is the Repo +atts+ is a Hash of instance variable data Returns",2],["create_initialize","Grit::Tree","classes/Grit/Tree.html#M000371","(repo, atts)","Initializer for Tree.create +repo+ is the Repo +atts+ is a Hash of instance variable data Returns Grit::Tree",2],["create_tempfile","Grit::Git","classes/Grit/Git.html#M000234","(seed, unlink = false)","",2],["current","Grit::Head","classes/Grit/Head.html#M000276","(repo, options = {})","Get the HEAD revision of the repo. +repo+ is the Repo +options+ is a Hash of options Returns Grit::Head",2],["data","Grit::Blob","classes/Grit/Blob.html#M000010","()","The binary contents of this blob. Returns String ",2],["data","Grit::Config","classes/Grit/Config.html#M000054","()","",2],["date","Grit::Commit","classes/Grit/Commit.html#M000042","()","",2],["delete","Grit::Index","classes/Grit/Index.html#M000261","(path)","Public: Delete the given file from the index. path - The String file path including filename (no slash",2],["deleted","Grit::Status","classes/Grit/Status.html#M000312","()","",2],["description","Grit::Repo","classes/Grit/Repo.html#M000294","()","The project's description. Taken verbatim from GIT_REPO/description Returns String ",2],["diff","Grit::Commit","classes/Grit/Commit.html#M000033","(repo, a, b = nil, paths = [], options = {})","Show diffs between two trees. repo    - The current Grit::Repo instance. a       - A String named commit.",2],["diff","Grit::GitRuby","classes/Grit/GitRuby.html#M000188","(options, sha1, sha2 = nil)","git diff --full-index 'ec037431382e83c3e95d4f2b3d145afbac8ea55d' 'f1ec1aea10986159456846b8a05615b87828d6c6'",2],["diff","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000209","(commit1, commit2, options = {})","",2],["diff","Grit::Repo","classes/Grit/Repo.html#M000345","(a, b, *paths)","The diff from commit +a+ to commit +b+, optionally restricted to the given file(s) +a+ is the base commit",2],["diff_files","Grit::Status","classes/Grit/Status.html#M000331","()","compares the index and the working directory ",2],["diff_index","Grit::Status","classes/Grit/Status.html#M000334","(treeish)","compares the index and the repository ",2],["diff_objects","Grit::Repo","classes/Grit/Repo.html#M000339","(commit_sha, parents = true)","",2],["diffs","Grit::Commit","classes/Grit/Commit.html#M000038","(options = {})","Shows diffs between the commit's parent and the commit. options - An optional Hash of options, passed",2],["disable_daemon_serve","Grit::Repo","classes/Grit/Repo.html#M000355","()","Disable git-daemon serving of this repository by ensuring there is no git-daemon-export-ok file in its",2],["e","Grit::Git","classes/Grit/Git.html#M000222","(str)","Alias for #shell_escape",2],["each","Grit::Status","classes/Grit/Status.html#M000319","()","",2],["each_alternate_path","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000245","(path)","",2],["each_entry","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000124","()","",2],["each_sha1","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000126","()","",2],["enable_daemon_serve","Grit::Repo","classes/Grit/Repo.html#M000354","()","Enable git-daemon serving of this repository by writing the git-daemon-export-ok file to its git directory",2],["exec!","Grit::Process","classes/Grit/Process.html#M000279","()","Execute command, write input, and read output. This is called immediately when a new instance of this",2],["exist?","Grit::Git","classes/Grit/Git.html#M000213","()","",2],["extended","Lazy","classes/Lazy.html#M000268","(klass)","",2],["fetch","Grit::Config","classes/Grit/Config.html#M000052","(key, default = nil)","",2],["file_index","Grit::GitRuby","classes/Grit/GitRuby.html#M000204","()","",2],["file_size","Grit::GitRuby","classes/Grit/GitRuby.html#M000200","(ref)","",2],["file_type","Grit::GitRuby","classes/Grit/GitRuby.html#M000201","(ref)","",2],["files","Grit::GitRuby::FileIndex","classes/Grit/GitRuby/FileIndex.html#M000074","(commit_sha)","returns files changed at commit sha ",2],["files_changed?","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000220","(tree_sha1, tree_sha2, path_limiter = nil)","returns true if the files in path_limiter were changed, or no path limiter used by the log() function",2],["find_all","Grit::Commit","classes/Grit/Commit.html#M000026","(repo, ref, options = {})","Find all commits matching the given criteria. +repo+ is the Repo +ref+ is the ref from which to begin",2],["find_all","Grit::CommitStats","classes/Grit/CommitStats.html#M000027","(repo, ref, options = {})","Find all commit stats matching the given criteria. +repo+ is the Repo +ref+ is the ref from which to",2],["find_all","Grit::Ref","classes/Grit/Ref.html#M000272","(repo, options = {})","Find all Refs +repo+ is the Repo +options+ is a Hash of options Returns Grit::Ref[] (baked) ",2],["find_all","Grit::Tag","classes/Grit/Tag.html#M000362","(repo, options = {})","",2],["find_object","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000130","(sha1)","",2],["find_object_in_index","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000129","(idx, sha1)","",2],["fork_bare","Grit::Repo","classes/Grit/Repo.html#M000289","(path, options = {})","Public: Create a bare fork of this repository. path    - The String full path of where to create the",2],["fork_bare_from","Grit::Repo","classes/Grit/Repo.html#M000290","(path, options = {})","Public: Fork a bare git repository from another repo. path    - The String full path of the repo from",2],["format_mode","Grit::GitRuby::DirectoryEntry","classes/Grit/GitRuby/DirectoryEntry.html#M000151","()","",2],["format_mode","Grit::GitRuby::DirectoryEntry","classes/Grit/GitRuby/DirectoryEntry.html#M000087","()","",2],["format_type","Grit::GitRuby::DirectoryEntry","classes/Grit/GitRuby/DirectoryEntry.html#M000086","()","",2],["format_type","Grit::GitRuby::DirectoryEntry","classes/Grit/GitRuby/DirectoryEntry.html#M000150","()","",2],["from_raw","Grit::GitRuby::Blob","classes/Grit/GitRuby/Blob.html#M000141","(rawobject, repository)","",2],["from_raw","Grit::GitRuby::Blob","classes/Grit/GitRuby/Blob.html#M000077","(rawobject, repository)","",2],["from_raw","Grit::GitRuby::Commit","classes/Grit/GitRuby/Commit.html#M000095","(rawobject, repository=nil)","",2],["from_raw","Grit::GitRuby::Commit","classes/Grit/GitRuby/Commit.html#M000160","(rawobject, repository=nil)","",2],["from_raw","Grit::GitRuby::GitObject","classes/Grit/GitRuby/GitObject.html#M000067","(rawobject, repository = nil)","",2],["from_raw","Grit::GitRuby::Object","classes/Grit/GitRuby/Object.html#M000135","(rawobject, repository = nil)","",2],["from_raw","Grit::GitRuby::Tag","classes/Grit/GitRuby/Tag.html#M000100","(rawobject, repository=nil)","",2],["from_raw","Grit::GitRuby::Tag","classes/Grit/GitRuby/Tag.html#M000165","(rawobject, repository=nil)","",2],["from_raw","Grit::GitRuby::Tree","classes/Grit/GitRuby/Tree.html#M000155","(rawobject, repository=nil)","",2],["from_raw","Grit::GitRuby::Tree","classes/Grit/GitRuby/Tree.html#M000090","(rawobject, repository=nil)","",2],["from_string","Grit::Actor","classes/Grit/Actor.html#M000001","(str)","Create an Actor from a string. str - The String in this format: 'John Doe <jdoe@example.com>' Returns",2],["fs_chmod","Grit::Git","classes/Grit/Git.html#M000232","(mode, file = '/')","Chmod the the file or dir and everything beneath +file+ is the relative path from the Git dir Returns",2],["fs_delete","Grit::Git","classes/Grit/Git.html#M000227","(file)","Delete a normal file from the filesystem +file+ is the relative path from the Git dir Returns nothing",2],["fs_exist?","Grit::Git","classes/Grit/Git.html#M000223","(file)","Check if a normal file exists on the filesystem +file+ is the relative path from the Git dir Returns",2],["fs_mkdir","Grit::Git","classes/Grit/Git.html#M000230","(dir)","Make a directory +dir+ is the relative path to the directory to create Returns nothing ",2],["fs_move","Grit::Git","classes/Grit/Git.html#M000229","(from, to)","Move a normal file +from+ is the relative path to the current file +to+ is the relative path to the destination",2],["fs_read","Grit::Git","classes/Grit/Git.html#M000224","(file)","Read a normal file from the filesystem. +file+ is the relative path from the Git dir Returns the String",2],["fs_write","Grit::Git","classes/Grit/Git.html#M000226","(file, contents)","Write a normal file to the filesystem. +file+ is the relative path from the Git dir +contents+ is the",2],["gc_auto","Grit::Repo","classes/Grit/Repo.html#M000356","()","",2],["get_head","Grit::Repo","classes/Grit/Repo.html#M000298","(head_name)","",2],["get_object_by_sha1","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000175","(sha1)","returns GitRuby object of any type given a SHA1 ",2],["get_patch","Grit::Git","classes/Grit/Git.html#M000238","(applies_sha)","Gets a patch for a given SHA using `git diff`. applies_sha - String SHA to get the patch from, using",2],["get_raw_object","Grit::GitRuby::Internal::LooseStorage","classes/Grit/GitRuby/Internal/LooseStorage.html#M000109","(buf)","",2],["get_raw_object_by_sha1","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000173","(sha1o)","returns a raw object given a SHA1 ",2],["get_raw_tree","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000191","(sha, recursive = false)","",2],["get_raw_trees","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000192","(sha, path = '')","Grabs tree contents recursively, e.g. `git ls-tree -r sha` ",2],["get_shas","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000121","()","given an index file, list out the shas that it's packfile contains ",2],["get_subtree","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000225","(commit_sha, path)","",2],["getord","String","classes/String.html#M000292","(offset)","",2],["git_binary","Grit::Git","classes/Grit/Git.html#M000217","()","",2],["git_path","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000243","(path)","",2],["head","Grit::Repo","classes/Grit/Repo.html#M000300","()","Object reprsenting the current repo head. Returns Grit::Head (baked) ",2],["heads","Grit::Repo","classes/Grit/Repo.html#M000296","()","An array of Head objects representing the branch heads in this repo Returns Grit::Head[] (baked) ",2],["id_abbrev","Grit::Commit","classes/Grit/Commit.html#M000020","()","",2],["in_loose?","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000180","(sha_hex)","returns true if the hex-packed sha is in the loose objects ",2],["in_packs?","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000179","(sha_hex)","returns true if the hex-packed sha is in the packfiles ",2],["index","Grit::Repo","classes/Grit/Repo.html#M000360","()","",2],["init","Grit::GitRuby","classes/Grit/GitRuby.html#M000178","(options, *args)","",2],["init","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000237","(dir, bare = true)","initialize a git repository ",2],["init","Grit::Repo","classes/Grit/Repo.html#M000283","(path, git_options = {}, repo_options = {})","Public: Initialize a git repository (create it on the filesystem). By default, the newly created repository",2],["init_bare","Grit::Repo","classes/Grit/Repo.html#M000284","(path, git_options = {}, repo_options = {})","Public: Initialize a bare git repository (create it on the filesystem). path         - The String full",2],["init_bare_or_open","Grit::Repo","classes/Grit/Repo.html#M000288","(path, git_options = {}, repo_options = {})","Public: Initialize a bare Git repository (create it on the filesystem) or, if the repo already exists,",2],["init_pack","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000123","()","",2],["initloose","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000244","()","",2],["initpacks","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000249","()","",2],["inspect","Grit::Actor","classes/Grit/Actor.html#M000003","()","Pretty object inspection ",2],["inspect","Grit::Blame","classes/Grit/Blame.html#M000011","()","Pretty object inspection ",2],["inspect","Grit::Blob","classes/Grit/Blob.html#M000016","()","Pretty object inspection ",2],["inspect","Grit::Commit","classes/Grit/Commit.html#M000045","()","Pretty object inspection ",2],["inspect","Grit::CommitStats","classes/Grit/CommitStats.html#M000030","()","Pretty object inspection ",2],["inspect","Grit::DiffStat","classes/Grit/DiffStat.html#M000036","()","",2],["inspect","Grit::Merge","classes/Grit/Merge.html#M000271","()","Pretty object inspection ",2],["inspect","Grit::Ref","classes/Grit/Ref.html#M000275","()","Pretty object inspection ",2],["inspect","Grit::Repo","classes/Grit/Repo.html#M000364","()","Pretty object inspection ",2],["inspect","Grit::Submodule","classes/Grit/Submodule.html#M000352","()","Pretty object inspection ",2],["inspect","Grit::Tree","classes/Grit/Tree.html#M000375","()","Pretty object inspection ",2],["is_head?","Grit::Repo","classes/Grit/Repo.html#M000299","(head_name)","",2],["keys","Grit::Config","classes/Grit/Config.html#M000053","()","",2],["last_commits","Grit::GitRuby::FileIndex","classes/Grit/GitRuby/FileIndex.html#M000079","(commit_sha, files_matcher)","returns the shas of the last commits for all the files in [] from commit_sha files_matcher can be a regexp",2],["lazy_reader","Lazy","classes/Lazy.html#M000269","(*args)","",2],["lazy_source","Grit::Commit","classes/Grit/Commit.html#M000024","()","",2],["lazy_source","Grit::Tag","classes/Grit/Tag.html#M000367","()","",2],["lazy_source","Grit::Tree","classes/Grit/Tree.html#M000369","()","",2],["legacy_loose_object?","Grit::GitRuby::Internal::LooseStorage","classes/Grit/GitRuby/Internal/LooseStorage.html#M000118","(buf)","",2],["list_from_string","Grit::Commit","classes/Grit/Commit.html#M000028","(repo, text)","Parse out commit information into an array of baked Commit objects +repo+ is the Repo +text+ is the text",2],["list_from_string","Grit::CommitStats","classes/Grit/CommitStats.html#M000029","(repo, text)","Parse out commit information into an array of baked Commit objects +repo+ is the Repo +text+ is the text",2],["list_from_string","Grit::Diff","classes/Grit/Diff.html#M000058","(repo, text)","",2],["list_remotes","Grit::Git","classes/Grit/Git.html#M000233","()","",2],["list_tree","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000185","(sha)","returns a 2-d hash of the tree ['blob']['FILENAME'] = {:mode => '100644', :sha => SHA} ['tree']['DIRNAME']",2],["load_alternate_loose","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000247","(path)","",2],["load_alternate_packs","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000250","(path)","",2],["load_blame","Grit::Blame","classes/Grit/Blame.html#M000005","()","",2],["load_config","Grit::Config","classes/Grit/Config.html#M000055","()","",2],["load_loose","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000248","(path)","",2],["load_packs","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000251","(path)","",2],["log","Grit","classes/Grit.html#M000377","(str)","",2],["log","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000197","(sha, options = {})","returns an array of GitRuby Commit objects [ [sha, raw_output], [sha, raw_output], [sha, raw_output]",2],["log","Grit::Repo","classes/Grit/Repo.html#M000344","(commit = 'master', path = nil, options = {})","The commit log for a treeish Returns Grit::Commit[] ",2],["look_for_commits","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000231","(commit_sha, path, looking_for, options = {})","",2],["looking_for","Grit::GitRuby","classes/Grit/GitRuby.html#M000207","(commit, path = nil)","",2],["loose","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000170","()","returns the loose objects object lazily ",2],["ls_files","Grit::Status","classes/Grit/Status.html#M000336","()","",2],["ls_tree","Grit::GitRuby","classes/Grit/GitRuby.html#M000187","(options, treeish, *paths)","lib/grit/tree.rb:16:      output = repo.git.ls_tree({}, treeish, *paths) ",2],["ls_tree","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000189","(sha, paths = [], recursive = false)","returns the raw (cat-file) output for a tree if given a commit sha, it will print the tree of that commit",2],["ls_tree_path","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000194","(sha, path, append = nil)","return array of tree entries TODO : refactor this to remove the fugly ",2],["method_missing","Grit::Git","classes/Grit/Git.html#M000252","(cmd, options={}, *args, &block)","Methods not defined by a library implementation execute the git command using #native, passing the method",2],["mime_type","Grit::Blob","classes/Grit/Blob.html#M000012","()","The mime type of this file (based on the filename) Returns String ",2],["name","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000119","()","",2],["native","Grit::Git","classes/Grit/Git.html#M000246","(cmd, options = {}, *args, &block)","Execute a git command, bypassing any library implementation. cmd - The name of the git command as a Symbol.",2],["net","Grit::DiffStat","classes/Grit/DiffStat.html#M000035","()","",2],["new","Grit::Actor","classes/Grit/Actor.html#M000000","(name, email)","",2],["new","Grit::Blame","classes/Grit/Blame.html#M000004","(repo, file, commit)","",2],["new","Grit::Blame::BlameLine","classes/Grit/Blame/BlameLine.html#M000014","(lineno, oldlineno, commit, line)","",2],["new","Grit::Commit","classes/Grit/Commit.html#M000019","(repo, id, parents, tree, author, authored_date, committer, committed_date, message)","Instantiate a new Commit +id+ is the id of the commit +parents+ is an array of commit ids (will be converted",2],["new","Grit::CommitDb","classes/Grit/CommitDb.html#M000059","(git_obj, index_location = nil)","",2],["new","Grit::CommitStats","classes/Grit/CommitStats.html#M000023","(repo, id, files)","Instantiate a new CommitStats +id+ is the id of the commit +files+ is an array of : [ [filename, adds,",2],["new","Grit::Config","classes/Grit/Config.html#M000049","(repo)","",2],["new","Grit::Diff","classes/Grit/Diff.html#M000057","(repo, a_path, b_path, a_blob, b_blob, a_mode, b_mode, new_file, deleted_file, diff, renamed_file = false, similarity_index = 0)","",2],["new","Grit::DiffStat","classes/Grit/DiffStat.html#M000034","(filename, additions, deletions, total=nil)","",2],["new","Grit::Git","classes/Grit/Git.html#M000219","(git_dir)","",2],["new","Grit::Git::CommandFailed","classes/Grit/Git/CommandFailed.html#M000212","(command, exitstatus, err='')","",2],["new","Grit::Git::GitTimeout","classes/Grit/Git/GitTimeout.html#M000211","(command = nil, bytes_read = nil)","",2],["new","Grit::GitRuby::Blob","classes/Grit/GitRuby/Blob.html#M000142","(content, repository=nil)","",2],["new","Grit::GitRuby::Blob","classes/Grit/GitRuby/Blob.html#M000078","(content, repository=nil)","",2],["new","Grit::GitRuby::Commit","classes/Grit/GitRuby/Commit.html#M000161","(tree, parent, author, committer, message, headers, repository=nil)","",2],["new","Grit::GitRuby::Commit","classes/Grit/GitRuby/Commit.html#M000096","(tree, parent, author, committer, message, headers, repository=nil)","",2],["new","Grit::GitRuby::DirectoryEntry","classes/Grit/GitRuby/DirectoryEntry.html#M000082","(mode, filename, sha1o)","",2],["new","Grit::GitRuby::DirectoryEntry","classes/Grit/GitRuby/DirectoryEntry.html#M000146","(mode, filename, sha1o)","",2],["new","Grit::GitRuby::FileIndex","classes/Grit/GitRuby/FileIndex.html#M000064","(repo_path)","initializes index given repo_path ",2],["new","Grit::GitRuby::GitObject","classes/Grit/GitRuby/GitObject.html#M000070","()","",2],["new","Grit::GitRuby::Internal::FileWindow","classes/Grit/GitRuby/Internal/FileWindow.html#M000101","(file, version = 1)","",2],["new","Grit::GitRuby::Internal::LooseStorage","classes/Grit/GitRuby/Internal/LooseStorage.html#M000107","(directory)","",2],["new","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000112","(file)","",2],["new","Grit::GitRuby::Internal::RawObject","classes/Grit/GitRuby/Internal/RawObject.html#M000127","(type, content)","",2],["new","Grit::GitRuby::Object","classes/Grit/GitRuby/Object.html#M000137","()","",2],["new","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000169","(git_dir, options = {})","",2],["new","Grit::GitRuby::Tag","classes/Grit/GitRuby/Tag.html#M000104","(object, type, tag, tagger, message, repository=nil)","",2],["new","Grit::GitRuby::Tag","classes/Grit/GitRuby/Tag.html#M000166","(object, type, tag, tagger, repository=nil)","",2],["new","Grit::GitRuby::Tree","classes/Grit/GitRuby/Tree.html#M000156","(entries=[], repository = nil)","",2],["new","Grit::GitRuby::Tree","classes/Grit/GitRuby/Tree.html#M000091","(entries=[], repository = nil)","",2],["new","Grit::GitRuby::UserInfo","classes/Grit/GitRuby/UserInfo.html#M000063","(str)","",2],["new","Grit::GitRuby::UserInfo","classes/Grit/GitRuby/UserInfo.html#M000133","(str)","",2],["new","Grit::Index","classes/Grit/Index.html#M000257","(repo)","Initialize a new Index object. repo - The Grit::Repo to which the index belongs. Returns the newly initialized",2],["new","Grit::Merge","classes/Grit/Merge.html#M000270","(str)","",2],["new","Grit::Process","classes/Grit/Process.html#M000277","(argv, env={}, options={})","Create and execute a new process. argv    - Array of [command, arg1, ...] strings to use as the new process's",2],["new","Grit::Ref","classes/Grit/Ref.html#M000274","(name, commit)","Instantiate a new Head +name+ is the name of the head +commit+ is the Commit that the head points to",2],["new","Grit::Repo","classes/Grit/Repo.html#M000281","(path, options = {})","Public: Create a new Repo instance. path    - The String path to either the root git directory or the",2],["new","Grit::Status","classes/Grit/Status.html#M000308","(base)","",2],["new","Grit::Status::StatusFile","classes/Grit/Status/StatusFile.html#M000323","(base, hash)","",2],["notes","Grit::Commit","classes/Grit/Commit.html#M000044","()","",2],["object_exists?","Grit::Git","classes/Grit/Git.html#M000215","(object_id)","",2],["object_exists?","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000177","(sha1)","returns true or false if that sha exists in the db ",2],["objects","Grit::Repo","classes/Grit/Repo.html#M000335","(refs)","",2],["objects_between","Grit::Repo","classes/Grit/Repo.html#M000338","(ref1, ref2 = nil)","",2],["options_to_argv","Grit::Git","classes/Grit/Git.html#M000253","(options)","Transform a ruby-style options hash to command-line arguments sutiable for use with Kernel::exec. No",2],["output","Grit::Actor","classes/Grit/Actor.html#M000002","(time)","Outputs an actor string for Git commits. actor = Actor.new('bob', 'bob@email.com') actor.output(time)",2],["packs","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000171","()","returns the array of pack list objects ",2],["parse_batch","Grit::Commit","classes/Grit/Commit.html#M000018","(repo, sha, size, object)","Parses output from the `git-cat-file --batch'. repo   - Grit::Repo instance. sha    - String SHA of the",2],["parse_batch","Grit::Repo","classes/Grit/Repo.html#M000293","(text)","Parses `git cat-file --batch` output, returning an array of Grit objects. text - Raw String output. Returns",2],["parse_object","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000131","(offset)","",2],["parse_tag_data","Grit::Tag","classes/Grit/Tag.html#M000365","(data)","Parses the results from `cat-file -p` data - String tag object data.  Example: object 7bcc0ee821cdd133d8a53e8e7173a334fef448aa",2],["patch_delta","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000147","(base, delta)","",2],["patch_delta_header_size","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000154","(delta, pos)","",2],["popen4","Grit::Process","classes/Grit/Process.html#M000285","(*argv)","Start a process with spawn options and return popen4([env], command, arg1, arg2, [opt]) env     - The",2],["popen4","Grit::Process","classes/Grit/Process.html#M000264","(*argv)","Use JRuby's built in IO.popen4 but emulate the special spawn env and options arguments as best we can.",2],["prefix","Grit::Ref","classes/Grit/Ref.html#M000273","()","",2],["pretty","Grit::Status","classes/Grit/Status.html#M000314","()","",2],["process_raw_blame","Grit::Blame","classes/Grit/Blame.html#M000006","(output)","",2],["put_raw_object","Grit::Git","classes/Grit/Git.html#M000214","(content, type)","",2],["put_raw_object","Grit::GitRuby::Internal::LooseStorage","classes/Grit/GitRuby/Internal/LooseStorage.html#M000110","(content, type)","currently, I'm using the legacy format because it's easier to do this function takes content and a type",2],["put_raw_object","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000176","(content, type)","writes a raw object into the git repo ",2],["quick_diff","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000210","(tree1, tree2, path = '.', recurse = true)","takes 2 tree shas and recursively walks them to find out what files or directories have been modified",2],["raw","Grit::GitRuby::DirectoryEntry","classes/Grit/GitRuby/DirectoryEntry.html#M000152","()","",2],["raw","Grit::GitRuby::DirectoryEntry","classes/Grit/GitRuby/DirectoryEntry.html#M000088","()","",2],["raw_content","Grit::GitRuby::Blob","classes/Grit/GitRuby/Blob.html#M000081","()","",2],["raw_content","Grit::GitRuby::Blob","classes/Grit/GitRuby/Blob.html#M000145","()","",2],["raw_content","Grit::GitRuby::Commit","classes/Grit/GitRuby/Commit.html#M000098","()","",2],["raw_content","Grit::GitRuby::Commit","classes/Grit/GitRuby/Commit.html#M000163","()","",2],["raw_content","Grit::GitRuby::GitObject","classes/Grit/GitRuby/GitObject.html#M000072","()","",2],["raw_content","Grit::GitRuby::Object","classes/Grit/GitRuby/Object.html#M000139","()","",2],["raw_content","Grit::GitRuby::Tag","classes/Grit/GitRuby/Tag.html#M000105","()","",2],["raw_content","Grit::GitRuby::Tag","classes/Grit/GitRuby/Tag.html#M000167","()","",2],["raw_content","Grit::GitRuby::Tree","classes/Grit/GitRuby/Tree.html#M000158","()","",2],["raw_content","Grit::GitRuby::Tree","classes/Grit/GitRuby/Tree.html#M000093","()","",2],["raw_log","Grit::GitRuby::Commit","classes/Grit/GitRuby/Commit.html#M000099","(sha)","",2],["raw_log","Grit::GitRuby::Commit","classes/Grit/GitRuby/Commit.html#M000164","(sha)","",2],["read_and_write","Grit::Process","classes/Grit/Process.html#M000280","(input, stdin, stdout, stderr, timeout=nil, max=nil)","Start a select loop writing any input on the child's stdin and reading any output from the child's stdout",2],["read_bytes_until","Grit::GitRuby","classes/Grit/GitRuby.html#M000153","(io, char)","",2],["read_bytes_until","Grit::GitRuby","classes/Grit/GitRuby.html#M000089","(io, char)","",2],["read_data_v2","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000125","(idx)","",2],["read_index","Grit::GitRuby::FileIndex","classes/Grit/GitRuby/FileIndex.html#M000083","()","read and parse the file-index data ",2],["read_tree","Grit::Index","classes/Grit/Index.html#M000262","(tree)","Public: Read the contents of the given Tree into the index to use as a starting point for the index.",2],["recent_tag_name","Grit::Repo","classes/Grit/Repo.html#M000311","(committish = nil, options = {})","Finds the most recent annotated tag name that is reachable from a commit. @repo.recent_tag_name('master')",2],["refs","Grit::GitRuby","classes/Grit/GitRuby.html#M000195","(options, prefix)","",2],["refs","Grit::Repo","classes/Grit/Repo.html#M000322","()","An array of Ref objects representing the refs in this repo Returns Grit::Ref[] (baked) ",2],["remote_add","Grit::Repo","classes/Grit/Repo.html#M000317","(name, url)","",2],["remote_fetch","Grit::Repo","classes/Grit/Repo.html#M000320","(name)","",2],["remote_list","Grit::Repo","classes/Grit/Repo.html#M000316","()","",2],["remotes","Grit::Repo","classes/Grit/Repo.html#M000315","()","An array of Remote objects representing the remote branches in this repo Returns Grit::Remote[] (baked)",2],["remotes_fetch_needed","Grit::Repo","classes/Grit/Repo.html#M000321","(remotes)","takes an array of remote names and last pushed dates fetches from all of the remotes where the local",2],["remove","Grit::Repo","classes/Grit/Repo.html#M000304","(*files)","Remove files from the index ",2],["rename","Grit::Repo","classes/Grit/Repo.html#M000363","(name)","Rename the current repository directory. +name+ is the new name Returns nothing ",2],["rev_list","Grit::CommitDb","classes/Grit/CommitDb.html#M000060","(branch, options)","",2],["rev_list","Grit::GitRuby","classes/Grit/GitRuby.html#M000190","(options, ref = 'master')","",2],["rev_list","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000199","(sha, options)","",2],["rev_parse","Grit::GitRuby","classes/Grit/GitRuby.html#M000193","(options, string)","",2],["ruby_git","Grit::GitRuby","classes/Grit/GitRuby.html#M000205","()","",2],["run","Grit::Git","classes/Grit/Git.html#M000255","(prefix, cmd, postfix, options, args, &block)","DEPRECATED OPEN3-BASED COMMAND EXECUTION ",2],["select_existing_objects","Grit::Git","classes/Grit/Git.html#M000216","(object_ids)","",2],["setup_tables","Grit::CommitDb","classes/Grit/CommitDb.html#M000062","()","",2],["sh","Grit::Git","classes/Grit/Git.html#M000256","(command, &block)","",2],["sha","Grit::Commit","classes/Grit/Commit.html#M000041","()","",2],["sha1","Grit::GitRuby::GitObject","classes/Grit/GitRuby/GitObject.html#M000076","()","",2],["sha1","Grit::GitRuby::Internal::RawObject","classes/Grit/GitRuby/Internal/RawObject.html#M000128","()","",2],["sha1","Grit::GitRuby::Object","classes/Grit/GitRuby/Object.html#M000140","()","",2],["shell_escape","Grit::Git","classes/Grit/Git.html#M000221","(str)","",2],["show","Grit::Commit","classes/Grit/Commit.html#M000037","()","",2],["show","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000172","()","prints out the type, shas and content of all of the pack files ",2],["size","Grit::Blob","classes/Grit/Blob.html#M000009","()","The size of this blob in bytes Returns Integer ",2],["sort_commits","Grit::GitRuby::FileIndex","classes/Grit/GitRuby/FileIndex.html#M000073","(sha_array)","",2],["spawn","Grit::Process","classes/Grit/Process.html#M000287","(*argv)","",2],["spawn","Grit::Process","classes/Grit/Process.html#M000282","(env, *argv)","Spawn a child process, perform IO redirection and environment prep, and return the running process's",2],["stats","Grit::Commit","classes/Grit/Commit.html#M000039","()","",2],["status","Grit::Repo","classes/Grit/Repo.html#M000306","()","",2],["success?","Grit::Process","classes/Grit/Process.html#M000278","()","Determine if the process did exit with a zero exit status. ",2],["tags","Grit::GitRuby","classes/Grit/GitRuby.html#M000196","(options, prefix)","",2],["tags","Grit::Repo","classes/Grit/Repo.html#M000307","()","An array of Tag objects that are available in this repo Returns Grit::Tag[] (baked) ",2],["timeout_after","Grit::Git","classes/Grit/Git.html#M000254","(seconds)","Simple wrapper around Timeout::timeout. seconds - Float number of seconds before a Timeout::Error is",2],["to_diffstat","Grit::CommitStats","classes/Grit/CommitStats.html#M000031","()","Convert to an easy-to-traverse structure ",2],["to_hash","Grit::Commit","classes/Grit/Commit.html#M000048","()","",2],["to_hash","Grit::CommitStats","classes/Grit/CommitStats.html#M000032","()","private ",2],["to_patch","Grit::Commit","classes/Grit/Commit.html#M000043","()","",2],["to_s","Grit::Commit","classes/Grit/Commit.html#M000040","()","Convert this Commit to a String which is just the SHA1 id ",2],["to_s","Grit::GitRuby::UserInfo","classes/Grit/GitRuby/UserInfo.html#M000066","()","",2],["to_s","Grit::GitRuby::UserInfo","classes/Grit/GitRuby/UserInfo.html#M000134","()","",2],["transform_options","Grit::Git","classes/Grit/Git.html#M000259","(options)","Transform Ruby style options into git command line options +options+ is a hash of Ruby style options",2],["tree","Grit::Repo","classes/Grit/Repo.html#M000342","(treeish = 'master', paths = [])","The Tree object for the given treeish reference +treeish+ is the reference (default 'master') +paths+",2],["trees","Grit::Tree","classes/Grit/Tree.html#M000376","()","Find only Tree objects from contents ",2],["truncate_arr","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000198","(arr, sha)","",2],["try_run","Grit::GitRuby","classes/Grit/GitRuby.html#M000206","()","",2],["type","Grit::GitRuby::Blob","classes/Grit/GitRuby/Blob.html#M000080","()","",2],["type","Grit::GitRuby::Blob","classes/Grit/GitRuby/Blob.html#M000144","()","",2],["type","Grit::GitRuby::Commit","classes/Grit/GitRuby/Commit.html#M000162","()","",2],["type","Grit::GitRuby::Commit","classes/Grit/GitRuby/Commit.html#M000097","()","",2],["type","Grit::GitRuby::DirectoryEntry","classes/Grit/GitRuby/DirectoryEntry.html#M000084","()","",2],["type","Grit::GitRuby::DirectoryEntry","classes/Grit/GitRuby/DirectoryEntry.html#M000148","()","",2],["type","Grit::GitRuby::GitObject","classes/Grit/GitRuby/GitObject.html#M000071","()","",2],["type","Grit::GitRuby::Object","classes/Grit/GitRuby/Object.html#M000138","()","",2],["type","Grit::GitRuby::Tag","classes/Grit/GitRuby/Tag.html#M000106","()","",2],["type","Grit::GitRuby::Tag","classes/Grit/GitRuby/Tag.html#M000168","()","",2],["type","Grit::GitRuby::Tree","classes/Grit/GitRuby/Tree.html#M000157","()","",2],["type","Grit::GitRuby::Tree","classes/Grit/GitRuby/Tree.html#M000092","()","",2],["type=","Grit::GitRuby::DirectoryEntry","classes/Grit/GitRuby/DirectoryEntry.html#M000149","(type)","",2],["type=","Grit::GitRuby::DirectoryEntry","classes/Grit/GitRuby/DirectoryEntry.html#M000085","(type)","",2],["unmap","Grit::GitRuby::Internal::FileWindow","classes/Grit/GitRuby/Internal/FileWindow.html#M000102","()","",2],["unpack_compressed","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000143","(offset, destsize)","",2],["unpack_deltified","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000136","(packfile, type, offset, obj_offset, size, options = {})","",2],["unpack_object","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000132","(packfile, offset, options = {})","",2],["unpack_object_header_gently","Grit::GitRuby::Internal::LooseStorage","classes/Grit/GitRuby/Internal/LooseStorage.html#M000115","(buf)","private ",2],["untracked","Grit::Status","classes/Grit/Status.html#M000313","()","",2],["update_db","Grit::CommitDb","classes/Grit/CommitDb.html#M000061","(branch = nil)","",2],["update_ref","Grit::Repo","classes/Grit/Repo.html#M000361","(head, commit_sha)","",2],["url","Grit::Submodule","classes/Grit/Submodule.html#M000346","(ref)","The url of this submodule +ref+ is the committish that should be used to look up the url Returns String",2],["verify_header","Grit::GitRuby::Internal::LooseStorage","classes/Grit/GitRuby/Internal/LooseStorage.html#M000114","(type, size)","",2],["version","Grit","classes/Grit.html#M000378","()","",2],["waitpid","Grit::Process","classes/Grit/Process.html#M000286","(pid)","Wait for the child process to exit Returns the Process::Status object obtained by reaping the process.",2],["waitpid","Grit::Process","classes/Grit/Process.html#M000266","(pid)","",2],["walk_log","Grit::GitRuby::Repository","classes/Grit/GitRuby/Repository.html#M000202","(sha, opts, total_size = 0)","called by log() to recursively walk the tree ",2],["wild_sh","Grit::Git","classes/Grit/Git.html#M000258","(command, &block)","",2],["with_idx","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000113","(index_file = nil)","",2],["with_packfile","Grit::GitRuby::Internal::PackStorage","classes/Grit/GitRuby/Internal/PackStorage.html#M000116","()","",2],["with_timeout","Grit::Git","classes/Grit/Git.html#M000218","(timeout = 10.seconds)","",2],["write_blob","Grit::Index","classes/Grit/Index.html#M000267","(data)","Write a blob to the index. data - The String data to write. Returns the String SHA1 of the new blob.",2],["write_tree","Grit::Index","classes/Grit/Index.html#M000265","(tree, now_tree = nil)","Recursively write a tree to the index. tree -     The Hash tree map: key - The String directory or filename.",2],["History.txt","files/History_txt.html","files/History_txt.html","","== 2.4.1 / 2011-01-13   * Minor Enhancements     * Grit::Process is used to implement Grit::Git#check_applies,",3],["LICENSE","files/LICENSE.html","files/LICENSE.html","","(The MIT License)  Copyright (c) 2007-2009 Tom Preston-Werner  Permission is hereby granted, free of",3],["README.md","files/README_md.html","files/README_md.html","","Grit ====  Grit gives you object oriented read/write access to Git repositories via Ruby. The main goals",3],["grit.rb","files/lib/grit_rb.html","files/lib/grit_rb.html","","",3],["actor.rb","files/lib/grit/actor_rb.html","files/lib/grit/actor_rb.html","","",3],["blame.rb","files/lib/grit/blame_rb.html","files/lib/grit/blame_rb.html","","",3],["blob.rb","files/lib/grit/blob_rb.html","files/lib/grit/blob_rb.html","","",3],["commit.rb","files/lib/grit/commit_rb.html","files/lib/grit/commit_rb.html","","",3],["commit_stats.rb","files/lib/grit/commit_stats_rb.html","files/lib/grit/commit_stats_rb.html","","",3],["config.rb","files/lib/grit/config_rb.html","files/lib/grit/config_rb.html","","",3],["diff.rb","files/lib/grit/diff_rb.html","files/lib/grit/diff_rb.html","","",3],["errors.rb","files/lib/grit/errors_rb.html","files/lib/grit/errors_rb.html","","",3],["git-ruby.rb","files/lib/grit/git-ruby_rb.html","files/lib/grit/git-ruby_rb.html","","",3],["commit_db.rb","files/lib/grit/git-ruby/commit_db_rb.html","files/lib/grit/git-ruby/commit_db_rb.html","","",3],["file_index.rb","files/lib/grit/git-ruby/file_index_rb.html","files/lib/grit/git-ruby/file_index_rb.html","","this implements a file-based 'file index', an simple index of all of the reachable commits in a repo,",3],["git_object.rb","files/lib/grit/git-ruby/git_object_rb.html","files/lib/grit/git-ruby/git_object_rb.html","","converted from the gitrb project authors: Matthias Lederhofer <matled@gmx.net> Simon 'corecode' Schubert",3],["file_window.rb","files/lib/grit/git-ruby/internal/file_window_rb.html","files/lib/grit/git-ruby/internal/file_window_rb.html","","converted from the gitrb project authors: Matthias Lederhofer <matled@gmx.net> Simon 'corecode' Schubert",3],["loose.rb","files/lib/grit/git-ruby/internal/loose_rb.html","files/lib/grit/git-ruby/internal/loose_rb.html","","converted from the gitrb project authors: Matthias Lederhofer <matled@gmx.net> Simon 'corecode' Schubert",3],["pack.rb","files/lib/grit/git-ruby/internal/pack_rb.html","files/lib/grit/git-ruby/internal/pack_rb.html","","converted from the gitrb project authors: Matthias Lederhofer <matled@gmx.net> Simon 'corecode' Schubert",3],["raw_object.rb","files/lib/grit/git-ruby/internal/raw_object_rb.html","files/lib/grit/git-ruby/internal/raw_object_rb.html","","converted from the gitrb project authors: Matthias Lederhofer <matled@gmx.net> Simon 'corecode' Schubert",3],["object.rb","files/lib/grit/git-ruby/object_rb.html","files/lib/grit/git-ruby/object_rb.html","","converted from the gitrb project authors: Matthias Lederhofer <matled@gmx.net> Simon 'corecode' Schubert",3],["repository.rb","files/lib/grit/git-ruby/repository_rb.html","files/lib/grit/git-ruby/repository_rb.html","","converted from the gitrb project authors: Matthias Lederhofer <matled@gmx.net> Simon 'corecode' Schubert",3],["git.rb","files/lib/grit/git_rb.html","files/lib/grit/git_rb.html","","",3],["index.rb","files/lib/grit/index_rb.html","files/lib/grit/index_rb.html","","",3],["jruby.rb","files/lib/grit/jruby_rb.html","files/lib/grit/jruby_rb.html","","",3],["lazy.rb","files/lib/grit/lazy_rb.html","files/lib/grit/lazy_rb.html","","Allows attributes to be declared as lazy, meaning that they won't be computed until they are asked for.",3],["merge.rb","files/lib/grit/merge_rb.html","files/lib/grit/merge_rb.html","","",3],["process.rb","files/lib/grit/process_rb.html","files/lib/grit/process_rb.html","","",3],["ref.rb","files/lib/grit/ref_rb.html","files/lib/grit/ref_rb.html","","",3],["repo.rb","files/lib/grit/repo_rb.html","files/lib/grit/repo_rb.html","","",3],["ruby1.9.rb","files/lib/grit/ruby1_9_rb.html","files/lib/grit/ruby1_9_rb.html","","",3],["status.rb","files/lib/grit/status_rb.html","files/lib/grit/status_rb.html","","",3],["submodule.rb","files/lib/grit/submodule_rb.html","files/lib/grit/submodule_rb.html","","",3],["tag.rb","files/lib/grit/tag_rb.html","files/lib/grit/tag_rb.html","","",3],["tree.rb","files/lib/grit/tree_rb.html","files/lib/grit/tree_rb.html","","",3]],"searchIndex":["difference","grit","actor","blame","blameline","blob","commit","commitdb","commitstats","config","diff","diffstat","git","commandfailed","gittimeout","gitruby","blob","commit","directoryentry","fileindex","indexfilenotfound","unsupportedref","gitobject","internal","filewindow","looseobjecterror","loosestorage","packformaterror","packstorage","rawobject","object","repository","nosuchpath","nosuchshafound","tag","tree","userinfo","head","index","invalidgitrepositoryerror","invalidobjecttype","merge","nosuchpatherror","note","process","maximumoutputexceeded","timeoutexceeded","ref","remote","repo","status","statusfile","submodule","tag","tree","lazy","string","/()","<=>()","<=>()","[]()","[]()","[]()","[]()","[]()","[]=()","actor()","actual_raw()","actual_raw()","add()","add()","add_file()","added()","alternates()","alternates=()","apply_patch()","archive_tar()","archive_tar_gz()","archive_to_file()","author_string()","basename()","basename()","basename()","batch()","blame()","blame()","blame_tree()","blame_tree()","blame_tree()","blob()","blob()","blobs()","branches()","cache_objects()","cached()","calculate_sha()","cat_file()","cat_file()","cat_file_size()","cat_file_type()","cat_ref()","changed()","check_applies()","clean_paths()","close()","close()","commit()","commit()","commit_all()","commit_count()","commit_deltas_from()","commit_diff()","commit_from_sha()","commit_index()","commit_objects()","commit_stats()","commits()","commits_between()","commits_for()","commits_from()","commits_since()","config()","config()","config_lines()","construct()","construct_initialize()","construct_status()","content_from_string()","count()","count()","count_all()","create()","create()","create()","create()","create_initial_config()","create_initialize()","create_initialize()","create_initialize()","create_initialize()","create_tempfile()","current()","data()","data()","date()","delete()","deleted()","description()","diff()","diff()","diff()","diff()","diff_files()","diff_index()","diff_objects()","diffs()","disable_daemon_serve()","e()","each()","each_alternate_path()","each_entry()","each_sha1()","enable_daemon_serve()","exec!()","exist?()","extended()","fetch()","file_index()","file_size()","file_type()","files()","files_changed?()","find_all()","find_all()","find_all()","find_all()","find_object()","find_object_in_index()","fork_bare()","fork_bare_from()","format_mode()","format_mode()","format_type()","format_type()","from_raw()","from_raw()","from_raw()","from_raw()","from_raw()","from_raw()","from_raw()","from_raw()","from_raw()","from_raw()","from_string()","fs_chmod()","fs_delete()","fs_exist?()","fs_mkdir()","fs_move()","fs_read()","fs_write()","gc_auto()","get_head()","get_object_by_sha1()","get_patch()","get_raw_object()","get_raw_object_by_sha1()","get_raw_tree()","get_raw_trees()","get_shas()","get_subtree()","getord()","git_binary()","git_path()","head()","heads()","id_abbrev()","in_loose?()","in_packs?()","index()","init()","init()","init()","init_bare()","init_bare_or_open()","init_pack()","initloose()","initpacks()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","is_head?()","keys()","last_commits()","lazy_reader()","lazy_source()","lazy_source()","lazy_source()","legacy_loose_object?()","list_from_string()","list_from_string()","list_from_string()","list_remotes()","list_tree()","load_alternate_loose()","load_alternate_packs()","load_blame()","load_config()","load_loose()","load_packs()","log()","log()","log()","look_for_commits()","looking_for()","loose()","ls_files()","ls_tree()","ls_tree()","ls_tree_path()","method_missing()","mime_type()","name()","native()","net()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","notes()","object_exists?()","object_exists?()","objects()","objects_between()","options_to_argv()","output()","packs()","parse_batch()","parse_batch()","parse_object()","parse_tag_data()","patch_delta()","patch_delta_header_size()","popen4()","popen4()","prefix()","pretty()","process_raw_blame()","put_raw_object()","put_raw_object()","put_raw_object()","quick_diff()","raw()","raw()","raw_content()","raw_content()","raw_content()","raw_content()","raw_content()","raw_content()","raw_content()","raw_content()","raw_content()","raw_content()","raw_log()","raw_log()","read_and_write()","read_bytes_until()","read_bytes_until()","read_data_v2()","read_index()","read_tree()","recent_tag_name()","refs()","refs()","remote_add()","remote_fetch()","remote_list()","remotes()","remotes_fetch_needed()","remove()","rename()","rev_list()","rev_list()","rev_list()","rev_parse()","ruby_git()","run()","select_existing_objects()","setup_tables()","sh()","sha()","sha1()","sha1()","sha1()","shell_escape()","show()","show()","size()","sort_commits()","spawn()","spawn()","stats()","status()","success?()","tags()","tags()","timeout_after()","to_diffstat()","to_hash()","to_hash()","to_patch()","to_s()","to_s()","to_s()","transform_options()","tree()","trees()","truncate_arr()","try_run()","type()","type()","type()","type()","type()","type()","type()","type()","type()","type()","type()","type()","type=()","type=()","unmap()","unpack_compressed()","unpack_deltified()","unpack_object()","unpack_object_header_gently()","untracked()","update_db()","update_ref()","url()","verify_header()","version()","waitpid()","waitpid()","walk_log()","wild_sh()","with_idx()","with_packfile()","with_timeout()","write_blob()","write_tree()","history.txt","license","readme.md","grit.rb","actor.rb","blame.rb","blob.rb","commit.rb","commit_stats.rb","config.rb","diff.rb","errors.rb","git-ruby.rb","commit_db.rb","file_index.rb","git_object.rb","file_window.rb","loose.rb","pack.rb","raw_object.rb","object.rb","repository.rb","git.rb","index.rb","jruby.rb","lazy.rb","merge.rb","process.rb","ref.rb","repo.rb","ruby1.9.rb","status.rb","submodule.rb","tag.rb","tree.rb"]}}