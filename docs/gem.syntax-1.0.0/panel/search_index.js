var search_data = {"index":{"info":[["Syntax","lib/syntax/convertors/abstract.rb","classes/Syntax.html"," < ","",1],["Convertors","Syntax","classes/Syntax/Convertors.html"," < ","",1],["Abstract","Syntax::Convertors","classes/Syntax/Convertors/Abstract.html"," < Object","The abstract ancestor class for all convertors. It implements a few convenience methods to provide a",1],["HTML","Syntax::Convertors","classes/Syntax/Convertors/HTML.html"," < Abstract","A simple class for converting a text into HTML. ",1],["Default","Syntax","classes/Syntax/Default.html"," < Object","A default tokenizer for handling syntaxes that are not explicitly handled elsewhere. It simply yields",1],["Ruby","Syntax","classes/Syntax/Ruby.html"," < Tokenizer","A tokenizer for the Ruby language. It recognizes all common syntax (and some less common syntax) but",1],["Token","Syntax","classes/Syntax/Token.html"," < String","A single token extracted by a tokenizer. It is simply the lexeme itself, decorated with a 'group' attribute",1],["Tokenizer","Syntax","classes/Syntax/Tokenizer.html"," < Object","The base class of all tokenizers. It sets up the scanner and manages the looping until all tokens have",1],["Version","Syntax","classes/Syntax/Version.html"," < ","",1],["XML","Syntax","classes/Syntax/XML.html"," < Tokenizer","A simple implementation of an XML lexer. It handles most cases. It is not a validating lexer, meaning",1],["YAML","Syntax","classes/Syntax/YAML.html"," < Tokenizer","A simple implementation of an YAML lexer. It handles most cases. It is not a validating lexer. ",1],["all","Syntax","classes/Syntax.html#M000032","()","Return an array of the names of supported syntaxes. ",2],["all","Syntax","classes/Syntax.html#M000032","()","Return an array of the names of supported syntaxes. ",2],["append","Syntax::Tokenizer","classes/Syntax/Tokenizer.html#M000014","( data )","Append the given data to the currently active chunk. ",2],["convert","Syntax::Convertors::HTML","classes/Syntax/Convertors/HTML.html#M000013","( text, pre=true )","Converts the given text to HTML, using spans to represent token groups of any type but <tt>:normal</tt>",2],["delegate","Syntax::Tokenizer","classes/Syntax/Tokenizer.html#M000011","( sym )","A convenience for delegating method calls to the scanner. ",2],["end_region","Syntax::Tokenizer","classes/Syntax/Tokenizer.html#M000018","( gr, data=nil )","",2],["finish","Syntax::Tokenizer","classes/Syntax/Tokenizer.html#M000005","()","Finish tokenizing. This flushes the buffer, yielding any remaining text to the client. ",2],["flush_chunk","Syntax::Tokenizer","classes/Syntax/Tokenizer.html#M000019","()","",2],["for_syntax","Syntax::Convertors::Abstract","classes/Syntax/Convertors/Abstract.html#M000000","( syntax )","A convenience method for instantiating a new convertor for a specific syntax. ",2],["html_escape","Syntax::Convertors::HTML","classes/Syntax/Convertors/HTML.html#M000017","( string )","Replaces some characters with their corresponding HTML entities. ",2],["load","Syntax","classes/Syntax.html#M000031","( syntax )","Load the implementation of the requested syntax. If the syntax cannot be found, or if it cannot be loaded",2],["load","Syntax","classes/Syntax.html#M000031","( syntax )","Load the implementation of the requested syntax. If the syntax cannot be found, or if it cannot be loaded",2],["new","Syntax::Convertors::Abstract","classes/Syntax/Convertors/Abstract.html#M000002","( tokenizer )","Creates a new convertor that uses the given tokenizer. ",2],["new","Syntax::Token","classes/Syntax/Token.html#M000001","( text, group, instruction = :none )","Create a new Token representing the given text, and belonging to the given group. ",2],["option","Syntax::Tokenizer","classes/Syntax/Tokenizer.html#M000010","(opt)","Get the value of the specified option. ",2],["scan_delimited_region","Syntax::Ruby","classes/Syntax/Ruby.html#M000027","( delim_group, inner_group, starter, exprs, delim=nil, heredoc=false )","Scan a delimited region of text. This handles the simple cases (strings delimited with quotes) as well",2],["scan_heredoc","Syntax::Ruby","classes/Syntax/Ruby.html#M000029","(float, type, delim)","Scan a heredoc beginning at the current position. * +float+ indicates whether the delimiter may be floated",2],["scan_string","Syntax::XML","classes/Syntax/XML.html#M000025","( delim )","Scan the string starting at the current position, with the given delimiter character. ",2],["scan_string","Syntax::YAML","classes/Syntax/YAML.html#M000028","( delim )","",2],["set","Syntax::Tokenizer","classes/Syntax/Tokenizer.html#M000009","( opts={} )","Specify a set of tokenizer-specific options. Each tokenizer may (or may not) publish any options, but",2],["setup","Syntax::Ruby","classes/Syntax/Ruby.html#M000023","()","Perform ruby-specific setup ",2],["setup","Syntax::Tokenizer","classes/Syntax/Tokenizer.html#M000004","()","Subclasses may override this method to provide implementation-specific setup logic. ",2],["setup","Syntax::XML","classes/Syntax/XML.html#M000021","()","Initialize the lexer. ",2],["start","Syntax::Tokenizer","classes/Syntax/Tokenizer.html#M000003","( text, &block )","Start tokenizing. This sets up the state in preparation for tokenization, such as creating a new scanner",2],["start_group","Syntax::Tokenizer","classes/Syntax/Tokenizer.html#M000015","( gr, data=nil )","Request that a new group be started. If the current group is the same as the group being requested, a",2],["start_region","Syntax::Tokenizer","classes/Syntax/Tokenizer.html#M000016","( gr, data=nil )","",2],["step","Syntax::Ruby","classes/Syntax/Ruby.html#M000024","()","Step through a single iteration of the tokenization process. ",2],["step","Syntax::Tokenizer","classes/Syntax/Tokenizer.html#M000007","()","Subclasses must implement this method, which is called for each iteration of the tokenization process.",2],["step","Syntax::XML","classes/Syntax/XML.html#M000022","()","Step through a single iteration of the tokenization process. This will yield (potentially) many tokens,",2],["step","Syntax::YAML","classes/Syntax/YAML.html#M000026","()","Step through a single iteration of the tokenization process. This will yield (potentially) many tokens,",2],["subgroup","Syntax::Tokenizer","classes/Syntax/Tokenizer.html#M000012","(n)","Access the n-th subgroup from the most recent match. ",2],["subtokenize","Syntax::Tokenizer","classes/Syntax/Tokenizer.html#M000020","( syntax, text )","",2],["teardown","Syntax::Tokenizer","classes/Syntax/Tokenizer.html#M000006","()","Subclasses may override this method to provide implementation-specific teardown logic. ",2],["tokenize","Syntax::Default","classes/Syntax/Default.html#M000030","( text )","Yield the given text as a single token. ",2],["tokenize","Syntax::Tokenizer","classes/Syntax/Tokenizer.html#M000008","( text, &block )","Begins tokenizing the given text, calling #step until the text has been exhausted. ",2],["syntax.rb","files/lib/syntax_rb.html","files/lib/syntax_rb.html","","",3],["common.rb","files/lib/syntax/common_rb.html","files/lib/syntax/common_rb.html","","",3],["abstract.rb","files/lib/syntax/convertors/abstract_rb.html","files/lib/syntax/convertors/abstract_rb.html","","",3],["html.rb","files/lib/syntax/convertors/html_rb.html","files/lib/syntax/convertors/html_rb.html","","",3],["ruby.rb","files/lib/syntax/lang/ruby_rb.html","files/lib/syntax/lang/ruby_rb.html","","",3],["xml.rb","files/lib/syntax/lang/xml_rb.html","files/lib/syntax/lang/xml_rb.html","","",3],["yaml.rb","files/lib/syntax/lang/yaml_rb.html","files/lib/syntax/lang/yaml_rb.html","","",3],["version.rb","files/lib/syntax/version_rb.html","files/lib/syntax/version_rb.html","","",3]],"searchIndex":["syntax","convertors","abstract","html","default","ruby","token","tokenizer","version","xml","yaml","all()","all()","append()","convert()","delegate()","end_region()","finish()","flush_chunk()","for_syntax()","html_escape()","load()","load()","new()","new()","option()","scan_delimited_region()","scan_heredoc()","scan_string()","scan_string()","set()","setup()","setup()","setup()","start()","start_group()","start_region()","step()","step()","step()","step()","subgroup()","subtokenize()","teardown()","tokenize()","tokenize()","syntax.rb","common.rb","abstract.rb","html.rb","ruby.rb","xml.rb","yaml.rb","version.rb"],"longSearchIndex":["lib/syntax.rb","syntax","syntax::convertors","syntax::convertors","syntax","syntax","syntax","syntax","syntax","syntax","syntax","syntax","syntax","syntax::tokenizer","syntax::convertors::html","syntax::tokenizer","syntax::tokenizer","syntax::tokenizer","syntax::tokenizer","syntax::convertors::abstract","syntax::convertors::html","syntax","syntax","syntax::convertors::abstract","syntax::token","syntax::tokenizer","syntax::ruby","syntax::ruby","syntax::xml","syntax::yaml","syntax::tokenizer","syntax::ruby","syntax::tokenizer","syntax::xml","syntax::tokenizer","syntax::tokenizer","syntax::tokenizer","syntax::ruby","syntax::tokenizer","syntax::xml","syntax::yaml","syntax::tokenizer","syntax::tokenizer","syntax::tokenizer","syntax::default","syntax::tokenizer","files/lib/syntax_rb.html","files/lib/syntax/common_rb.html","files/lib/syntax/convertors/abstract_rb.html","files/lib/syntax/convertors/html_rb.html","files/lib/syntax/lang/ruby_rb.html","files/lib/syntax/lang/xml_rb.html","files/lib/syntax/lang/yaml_rb.html","files/lib/syntax/version_rb.html"]}}